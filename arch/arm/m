diff --unified -r mach-msm/acpuclock-8064.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-8064.c
--- mach-msm/acpuclock-8064.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-8064.c	2013-12-17 17:08:05.606151173 -0800
@@ -131,6 +131,7 @@
 	[12] = { { 1026000, HFPLL, 1, 0x26 }, 1150000, 1150000, 5 },
 	[13] = { { 1080000, HFPLL, 1, 0x28 }, 1150000, 1150000, 5 },
 	[14] = { { 1134000, HFPLL, 1, 0x2A }, 1150000, 1150000, 5 },
+	[15] = { { 1188000, HFPLL, 1, 0x2C }, 1150000, 1150000, 5 },
 	{ }
 };
 
@@ -148,15 +149,15 @@
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1100000 },
 	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(5),  1125000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1125000 },
-	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(14), 1175000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1175000 },
-	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(14), 1200000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1200000 },
-	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(14), 1225000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1225000 },
-	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(14), 1237500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1237500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1250000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1175000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1175000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1200000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1200000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1225000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1225000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1237500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1237500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1250000 },
 	{ 0, { 0 } }
 };
 
@@ -174,15 +175,15 @@
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1050000 },
 	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(5),  1075000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1075000 },
-	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(14), 1125000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1125000 },
-	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(14), 1150000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1150000 },
-	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(14), 1175000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1175000 },
-	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(14), 1187500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1187500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1200000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1125000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1125000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1150000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1150000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1175000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1175000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1187500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1187500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1200000 },
 	{ 0, { 0 } }
 };
 
@@ -200,15 +201,15 @@
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1000000 },
 	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(5),  1025000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1025000 },
-	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(14), 1075000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1075000 },
-	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(14), 1100000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1100000 },
-	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(14), 1125000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1125000 },
-	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(14), 1137500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1137500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1150000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1075000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1075000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1100000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1100000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1125000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1125000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1137500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1137500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1150000 },
 	{ 0, { 0 } }
 };
 
@@ -226,15 +227,15 @@
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   975000 },
 	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(5),  1000000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1000000 },
-	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(14), 1050000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1050000 },
-	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(14), 1075000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1075000 },
-	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(14), 1100000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1100000 },
-	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(14), 1112500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1112500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1125000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1050000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1050000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1075000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1075000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1100000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1100000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1112500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1112500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1125000 },
 	{ 0, { 0 } }
 };
 
@@ -246,11 +247,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),  1000000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1025000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1037500 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1075000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1087500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1125000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1150000 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1162500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1075000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1087500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1125000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1150000 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1162500 },
 	{ 0, { 0 } }
 };
 
@@ -262,11 +263,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   975000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1000000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1012500 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1037500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1050000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1087500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1112500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1125000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1037500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1050000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1087500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1112500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1125000 },
 	{ 0, { 0 } }
 };
 
@@ -278,11 +279,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   937500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   950000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   975000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1000000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1012500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1037500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1075000 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1087500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1000000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1012500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1037500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1075000 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1087500 },
 	{ 0, { 0 } }
 };
 
@@ -294,11 +295,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   900000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   925000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   950000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  975000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  987500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1000000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1037500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1050000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  975000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  987500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1000000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1037500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1050000 },
 	{ 0, { 0 } }
 };
 
@@ -310,11 +311,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  950000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  962500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  975000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1000000 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1012500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  950000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  962500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  975000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1000000 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1012500 },
 	{ 0, { 0 } }
 };
 
@@ -326,11 +327,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  987500 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1000000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  987500 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1000000 },
 	{ 0, { 0 } }
 };
 
@@ -342,11 +343,11 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  975000 },
-	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14),  987500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  975000 },
+	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(15),  987500 },
 	{ 0, { 0 } }
 };
 
@@ -358,13 +359,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),  1000000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1025000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1037500 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1075000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1087500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1125000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1150000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1175000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1225000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1250000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1075000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1087500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1125000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1150000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1175000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1225000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1250000 },
 	{ 0, { 0 } }
 };
 
@@ -376,13 +377,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   975000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),  1000000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1012500 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1037500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1050000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1087500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1112500 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1150000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1187500 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1200000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1037500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1050000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1087500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1112500 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1150000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1187500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1200000 },
 	{ 0, { 0 } }
 };
 
@@ -394,13 +395,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   937500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   950000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   975000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1000000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1012500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1037500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1075000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1100000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1137500 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1162500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1000000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1012500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1037500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1075000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1100000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1137500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1162500 },
 	{ 0, { 0 } }
 };
 
@@ -412,13 +413,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   900000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   925000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   950000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  975000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  987500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1000000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1037500 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1062500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1100000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1125000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  975000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  987500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1000000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1037500 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1062500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1100000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1125000 },
 	{ 0, { 0 } }
 };
 
@@ -430,13 +431,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  950000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  962500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  975000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1000000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1037500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1075000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1100000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  950000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  962500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  975000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1000000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1037500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1075000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1100000 },
 	{ 0, { 0 } }
 };
 
@@ -448,13 +449,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  987500 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1012500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1050000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1075000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  987500 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1012500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1050000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1075000 },
 	{ 0, { 0 } }
 };
 
@@ -466,13 +467,13 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  975000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1000000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1025000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1050000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  975000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1000000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1025000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1050000 },
 	{ 0, { 0 } }
 };
 
@@ -484,14 +485,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   962500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   975000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),  1000000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1025000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1037500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1062500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1100000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1125000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1175000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1225000 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1287500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1025000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1037500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1062500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1100000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1125000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1175000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1225000 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1287500 },
 	{ 0, { 0 } }
 };
 
@@ -503,14 +504,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   937500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   950000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   975000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14), 1000000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14), 1012500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1037500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1075000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1100000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1137500 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1187500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1250000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1000000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1012500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1037500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1075000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1100000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1137500 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1187500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1250000 },
 	{ 0, { 0 } }
 };
 
@@ -522,14 +523,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   912500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   925000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   950000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  975000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  987500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1012500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1050000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1075000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1112500 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1162500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1212500 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  975000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  987500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1012500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1050000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1075000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1112500 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1162500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1212500 },
 	{ 0, { 0 } }
 };
 
@@ -541,14 +542,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   900000 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   912500 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   937500 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  962500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  975000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1000000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1025000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1050000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1087500 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1137500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1175000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  962500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  975000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1000000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1025000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1050000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1087500 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1137500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1175000 },
 	{ 0, { 0 } }
 };
 
@@ -560,14 +561,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  950000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  962500 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  975000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1000000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1037500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1075000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1112500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1150000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  950000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  962500 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  975000 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1000000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1037500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1075000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1112500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1150000 },
 	{ 0, { 0 } }
 };
 
@@ -579,14 +580,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  987500 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1012500 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1050000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1087500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1125000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  987500 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1012500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1050000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1087500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1125000 },
 	{ 0, { 0 } }
 };
 
@@ -598,14 +599,14 @@
 	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(5),   887500 },
 	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(5),   900000 },
 	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(5),   925000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(14),  937500 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(14),  950000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  975000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(14), 1000000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(14), 1025000 },
-	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(14), 1062500 },
-	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1100000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  937500 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15),  950000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15),  962500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15),  975000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1000000 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1025000 },
+	{ 1, {  1782000, HFPLL, 1, 0x42 }, L2(15), 1062500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(15), 1100000 },
 	{ 0, { 0 } }
 };
 
diff --unified -r mach-msm/acpuclock-8930ab.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-8930ab.c
--- mach-msm/acpuclock-8930ab.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-8930ab.c	2013-12-17 17:08:05.606151173 -0800
@@ -130,8 +130,9 @@
 	.name = "acpuclk-8930ab",
 };
 
+/* TODO: Update new L2 freqs once they are available */
 static struct l2_level l2_freq_tbl[] __initdata = {
-	[0]  = { {  384000, PLL_8, 0, 0x00 },  LVL_LOW, 1050000, 1 },
+	[0]  = { {  384000, PLL_8, 0, 0x00 },  LVL_NOM, 1050000, 1 },
 	[1]  = { {  432000, HFPLL, 2, 0x20 },  LVL_NOM, 1050000, 2 },
 	[2]  = { {  486000, HFPLL, 2, 0x24 },  LVL_NOM, 1050000, 2 },
 	[3]  = { {  540000, HFPLL, 2, 0x28 },  LVL_NOM, 1050000, 2 },
@@ -150,140 +151,101 @@
 	{ }
 };
 
-static struct acpu_level tbl_PVS0_1700MHz[] __initdata = {
-	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),  1000000 },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),  1000000 },
+static struct acpu_level acpu_freq_tbl_slow[] __initdata = {
+	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   950000 },
+	{ 0, {   432000, HFPLL, 2, 0x20 }, L2(5),   975000 },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   975000 },
+	{ 0, {   540000, HFPLL, 2, 0x28 }, L2(5),  1000000 },
 	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),  1000000 },
+	{ 0, {   648000, HFPLL, 1, 0x18 }, L2(5),  1025000 },
 	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),  1025000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10), 1050000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1075000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1100000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1125000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1150000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1175000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1200000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1225000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1250000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1275000 },
+	{ 0, {   756000, HFPLL, 1, 0x1C }, L2(10), 1075000 },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10), 1075000 },
+	{ 0, {   864000, HFPLL, 1, 0x20 }, L2(10), 1100000 },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1100000 },
+	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(10), 1125000 },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1125000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1175000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1175000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1200000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1200000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1225000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1225000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1237500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1237500 },
+	{ 0, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1250000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1250000 },
+	{ 0, {  1620000, HFPLL, 1, 0x3C }, L2(15), 1262500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1262500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1287500 },
 	{ 0, { 0 } }
 };
 
-static struct acpu_level tbl_PVS1_1700MHz[] __initdata = {
-	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   975000 },
+static struct acpu_level acpu_freq_tbl_nom[] __initdata = {
+	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   950000 },
+	{ 0, {   432000, HFPLL, 2, 0x20 }, L2(5),   975000 },
 	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   975000 },
+	{ 0, {   540000, HFPLL, 2, 0x28 }, L2(5),  1000000 },
 	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),  1000000 },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),  1000000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10), 1025000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1050000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1075000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1100000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1125000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1150000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1175000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1200000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1225000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1250000 },
+	{ 0, {   648000, HFPLL, 1, 0x18 }, L2(5),  1025000 },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),  1025000 },
+	{ 0, {   756000, HFPLL, 1, 0x1C }, L2(10), 1075000 },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10), 1075000 },
+	{ 0, {   864000, HFPLL, 1, 0x20 }, L2(10), 1100000 },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1100000 },
+	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(10), 1125000 },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1125000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1175000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1175000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1200000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1200000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1225000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1225000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1237500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1237500 },
+	{ 0, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1250000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1250000 },
+	{ 0, {  1620000, HFPLL, 1, 0x3C }, L2(15), 1262500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1262500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1287500 },
 	{ 0, { 0 } }
 };
 
-static struct acpu_level tbl_PVS2_1700MHz[] __initdata = {
+static struct acpu_level acpu_freq_tbl_fast[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   950000 },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   950000 },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),   950000 },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),   975000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10), 1000000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1025000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1050000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1075000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1100000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1125000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1150000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1175000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1200000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1225000 },
-	{ 0, { 0 } }
-};
-
-static struct acpu_level tbl_PVS3_1700MHz[] __initdata = {
-	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   925000 },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   925000 },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),   925000 },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),   950000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10),  975000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1000000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1025000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1050000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1075000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1100000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1125000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1150000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1175000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1200000 },
-	{ 0, { 0 } }
-};
-
-static struct acpu_level tbl_PVS4_1700MHz[] __initdata = {
-	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   925000 },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   925000 },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),   925000 },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),   925000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10),  950000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10),  975000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1000000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1025000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1050000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1075000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1100000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1125000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1150000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1175000 },
-	{ 0, { 0 } }
-};
-
-static struct acpu_level tbl_PVS5_1700MHz[] __initdata = {
-	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   900000 },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   900000 },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),   900000 },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),   900000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10),  925000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10),  950000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10),  975000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1000000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1025000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1050000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1075000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1100000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1125000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1150000 },
-	{ 0, { 0 } }
-};
-
-static struct acpu_level tbl_PVS6_1700MHz[] __initdata = {
-	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   875000 },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   875000 },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),   875000 },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),   875000 },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10),  900000 },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10),  925000 },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10),  950000 },
-	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15),  975000 },
-	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1000000 },
-	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1025000 },
-	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1050000 },
-	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1075000 },
-	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1100000 },
-	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1125000 },
+	{ 0, {   432000, HFPLL, 2, 0x20 }, L2(5),   975000 },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(5),   975000 },
+	{ 0, {   540000, HFPLL, 2, 0x28 }, L2(5),  1000000 },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(5),  1000000 },
+	{ 0, {   648000, HFPLL, 1, 0x18 }, L2(5),  1025000 },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(5),  1025000 },
+	{ 0, {   756000, HFPLL, 1, 0x1C }, L2(10), 1075000 },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(10), 1075000 },
+	{ 0, {   864000, HFPLL, 1, 0x20 }, L2(10), 1100000 },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(10), 1100000 },
+	{ 0, {   972000, HFPLL, 1, 0x24 }, L2(10), 1125000 },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(10), 1125000 },
+	{ 0, {  1080000, HFPLL, 1, 0x28 }, L2(15), 1175000 },
+	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(15), 1175000 },
+	{ 0, {  1188000, HFPLL, 1, 0x2C }, L2(15), 1200000 },
+	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(15), 1200000 },
+	{ 0, {  1296000, HFPLL, 1, 0x30 }, L2(15), 1225000 },
+	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(15), 1225000 },
+	{ 0, {  1404000, HFPLL, 1, 0x34 }, L2(15), 1237500 },
+	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(15), 1237500 },
+	{ 0, {  1512000, HFPLL, 1, 0x38 }, L2(15), 1250000 },
+	{ 1, {  1566000, HFPLL, 1, 0x3A }, L2(15), 1250000 },
+	{ 0, {  1620000, HFPLL, 1, 0x3C }, L2(15), 1262500 },
+	{ 1, {  1674000, HFPLL, 1, 0x3E }, L2(15), 1262500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(15), 1287500 },
 	{ 0, { 0 } }
 };
 
+/* TODO: Update boost voltage once the pvs data is available */
 static struct pvs_table pvs_tables[NUM_SPEED_BINS][NUM_PVS] __initdata = {
-	[0][0] = { tbl_PVS0_1700MHz, sizeof(tbl_PVS0_1700MHz), 0 },
-	[0][1] = { tbl_PVS1_1700MHz, sizeof(tbl_PVS1_1700MHz), 25000 },
-	[0][2] = { tbl_PVS2_1700MHz, sizeof(tbl_PVS2_1700MHz), 25000 },
-	[0][3] = { tbl_PVS3_1700MHz, sizeof(tbl_PVS3_1700MHz), 25000 },
-	[0][4] = { tbl_PVS4_1700MHz, sizeof(tbl_PVS4_1700MHz), 25000 },
-	[0][5] = { tbl_PVS5_1700MHz, sizeof(tbl_PVS5_1700MHz), 25000 },
-	[0][6] = { tbl_PVS6_1700MHz, sizeof(tbl_PVS6_1700MHz), 25000 },
+[0][PVS_SLOW]    = { acpu_freq_tbl_slow, sizeof(acpu_freq_tbl_slow), 0 },
+[0][PVS_NOMINAL] = { acpu_freq_tbl_nom,  sizeof(acpu_freq_tbl_nom),  25000 },
+[0][PVS_FAST]    = { acpu_freq_tbl_fast, sizeof(acpu_freq_tbl_fast), 25000 },
 };
 
 static struct acpuclk_krait_params acpuclk_8930ab_params __initdata = {
diff --unified -r mach-msm/acpuclock-8960ab.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-8960ab.c
--- mach-msm/acpuclock-8960ab.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-8960ab.c	2013-12-17 17:08:05.606151173 -0800
@@ -109,12 +109,12 @@
 
 static struct acpu_level freq_tbl_PVS0[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   950000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   950000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   975000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),  1000000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),  1025000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),  1050000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),  1075000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   950000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   975000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),  1000000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),  1025000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),  1050000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),  1075000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),  1100000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),  1125000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1150000, AVS(0x0) },
@@ -127,12 +127,12 @@
 
 static struct acpu_level freq_tbl_PVS1[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   925000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   925000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   950000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),   975000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),  1000000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),  1025000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),  1050000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   925000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   950000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),   975000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),  1000000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),  1025000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),  1050000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),  1075000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),  1100000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1125000, AVS(0x0) },
@@ -145,12 +145,12 @@
 
 static struct acpu_level freq_tbl_PVS2[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   900000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   900000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   925000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),   950000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),   975000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),  1000000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),  1025000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   900000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   925000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),   950000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),   975000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),  1000000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),  1025000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),  1050000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),  1075000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1100000, AVS(0x0) },
@@ -163,12 +163,12 @@
 
 static struct acpu_level freq_tbl_PVS3[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   900000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   900000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   900000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),   925000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),   950000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),   975000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),  1000000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   900000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   900000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),   925000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),   950000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),   975000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),  1000000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),  1025000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),  1050000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1075000, AVS(0x0) },
@@ -181,12 +181,12 @@
 
 static struct acpu_level freq_tbl_PVS4[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   875000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   875000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   875000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),   900000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),   925000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),   950000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),   975000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   875000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   875000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),   900000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),   925000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),   950000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),   975000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),  1000000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),  1025000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1050000, AVS(0x0) },
@@ -199,12 +199,12 @@
 
 static struct acpu_level freq_tbl_PVS5[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   875000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   875000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   875000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),   875000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),   900000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),   925000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),   950000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   875000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   875000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),   875000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),   900000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),   925000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),   950000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),   975000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),  1000000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1025000, AVS(0x0) },
@@ -217,12 +217,12 @@
 
 static struct acpu_level freq_tbl_PVS6[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   850000, AVS(0x70001F) },
-	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(4),   850000, AVS(0x0) },
-	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(4),   850000, AVS(0x0) },
-	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(4),   850000, AVS(0x0) },
-	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(4),   875000, AVS(0x0) },
-	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(4),   900000, AVS(0x0) },
-	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(4),   925000, AVS(0x0) },
+	{ 1, {   486000, HFPLL, 2, 0x24 }, L2(3),   850000, AVS(0x0) },
+	{ 1, {   594000, HFPLL, 1, 0x16 }, L2(3),   850000, AVS(0x0) },
+	{ 1, {   702000, HFPLL, 1, 0x1A }, L2(3),   850000, AVS(0x0) },
+	{ 1, {   810000, HFPLL, 1, 0x1E }, L2(3),   875000, AVS(0x0) },
+	{ 1, {   918000, HFPLL, 1, 0x22 }, L2(3),   900000, AVS(0x0) },
+	{ 1, {  1026000, HFPLL, 1, 0x26 }, L2(3),   925000, AVS(0x0) },
 	{ 1, {  1134000, HFPLL, 1, 0x2A }, L2(9),   950000, AVS(0x70000D) },
 	{ 1, {  1242000, HFPLL, 1, 0x2E }, L2(9),   975000, AVS(0x0) },
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(9),  1000000, AVS(0x0) },
diff --unified -r mach-msm/acpuclock-krait.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-krait.c
--- mach-msm/acpuclock-krait.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/acpuclock-krait.c	2013-12-17 17:08:05.606151173 -0800
@@ -645,9 +645,8 @@
 		writel_relaxed(drv.hfpll_data->droop_val,
 			       sc->hfpll_base + drv.hfpll_data->droop_offset);
 
-	/* Set an initial rate and enable the PLL. */
+	/* Set an initial PLL rate. */
 	hfpll_set_rate(sc, tgt_s);
-	hfpll_enable(sc, false);
 }
 
 static int __cpuinit rpm_regulator_init(struct scalable *sc, enum vregs vreg,
@@ -818,7 +817,9 @@
 	regval &= ~(0x3 << 6);
 	set_l2_indirect_reg(sc->l2cpmr_iaddr, regval);
 
-	/* Switch to the target clock source. */
+	/* Enable and switch to the target clock source. */
+	if (tgt_s->src == HFPLL)
+		hfpll_enable(sc, false);
 	set_pri_clk_src(sc, tgt_s->pri_src_sel);
 	sc->cur_speed = tgt_s;
 
diff --unified -r mach-msm/bam_dmux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/bam_dmux.c
--- mach-msm/bam_dmux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/bam_dmux.c	2013-12-17 17:08:05.606151173 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -28,7 +28,7 @@
 #include <linux/wakelock.h>
 #include <linux/kfifo.h>
 #include <linux/of.h>
-#include <mach/msm_ipc_logging.h>
+
 #include <mach/sps.h>
 #include <mach/bam_dmux.h>
 #include <mach/msm_smsm.h>
@@ -300,57 +300,93 @@
 #define bam_ch_is_in_reset(x)			\
 	(bam_ch[(x)].status & BAM_CH_IN_RESET)
 
+#define LOG_MESSAGE_MAX_SIZE 80
 struct kfifo bam_dmux_state_log;
+static uint32_t bam_dmux_state_logging_disabled;
+static DEFINE_SPINLOCK(bam_dmux_logging_spinlock);
 static int bam_dmux_uplink_vote;
 static int bam_dmux_power_state;
 
+static void bam_dmux_log(const char *fmt, ...)
+					__printf(1, 2);
+
 
 #define DMUX_LOG_KERR(fmt...) \
 do { \
-	BAM_DMUX_LOG(fmt); \
+	bam_dmux_log(fmt); \
 	pr_err(fmt); \
 } while (0)
 
-static void *bam_ipc_log_txt;
-
-#define BAM_IPC_LOG_PAGES 5
-
 /**
  * Log a state change along with a small message.
- * Complete size of messsage is limited to @todo.
- * Logging is done using IPC Logging infrastructure.
  *
- * States
- * D: 1 = Power collapse disabled
- * R: 1 = in global reset
- * P: 1 = BAM is powered up
- * A: 1 = BAM initialized and ready for data
- * V: 1 = Uplink vote for power
- * U: 1 = Uplink active
- * W: 1 = Uplink Wait-for-ack
- * A: 1 = Uplink ACK received
- * #: >=1 On-demand uplink vote
- * D: 1 = Disconnect ACK active
+ * Complete size of messsage is limited to @todo.
  */
+static void bam_dmux_log(const char *fmt, ...)
+{
+	char buff[LOG_MESSAGE_MAX_SIZE];
+	unsigned long flags;
+	va_list arg_list;
+	unsigned long long t_now;
+	unsigned long nanosec_rem;
+	int len = 0;
 
-#define BAM_DMUX_LOG(fmt, args...) \
-do { \
-	if (bam_ipc_log_txt) { \
-		ipc_log_string(bam_ipc_log_txt, \
-		"<DMUX> %c%c%c%c %c%c%c%c%d%c " fmt, \
-		a2_pc_disabled ? 'D' : 'd', \
-		in_global_reset ? 'R' : 'r', \
-		bam_dmux_power_state ? 'P' : 'p', \
-		bam_connection_is_active ? 'A' : 'a', \
-		bam_dmux_uplink_vote ? 'V' : 'v', \
-		bam_is_connected ?  'U' : 'u', \
-		wait_for_ack ? 'W' : 'w', \
-		ul_wakeup_ack_completion.done ? 'A' : 'a', \
-		atomic_read(&ul_ondemand_vote), \
-		disconnect_ack ? 'D' : 'd', \
-		args); \
-	} \
-} while (0)
+	if (bam_dmux_state_logging_disabled)
+		return;
+
+	t_now = sched_clock();
+	nanosec_rem = do_div(t_now, 1000000000U);
+
+	/*
+	 * States
+	 * D: 1 = Power collapse disabled
+	 * R: 1 = in global reset
+	 * P: 1 = BAM is powered up
+	 * A: 1 = BAM initialized and ready for data
+	 *
+	 * V: 1 = Uplink vote for power
+	 * U: 1 = Uplink active
+	 * W: 1 = Uplink Wait-for-ack
+	 * A: 1 = Uplink ACK received
+	 * #: >=1 On-demand uplink vote
+	 * D: 1 = Disconnect ACK active
+	 */
+	len += scnprintf(buff, sizeof(buff),
+		"<DMUX> %u.%09lu %c%c%c%c %c%c%c%c%d%c ",
+		(unsigned)t_now, nanosec_rem,
+		a2_pc_disabled ? 'D' : 'd',
+		in_global_reset ? 'R' : 'r',
+		bam_dmux_power_state ? 'P' : 'p',
+		bam_connection_is_active ? 'A' : 'a',
+		bam_dmux_uplink_vote ? 'V' : 'v',
+		bam_is_connected ?  'U' : 'u',
+		wait_for_ack ? 'W' : 'w',
+		ul_wakeup_ack_completion.done ? 'A' : 'a',
+		atomic_read(&ul_ondemand_vote),
+		disconnect_ack ? 'D' : 'd'
+		);
+
+	va_start(arg_list, fmt);
+	len += vscnprintf(buff + len, sizeof(buff) - len, fmt, arg_list);
+	va_end(arg_list);
+	memset(buff + len, 0x0, sizeof(buff) - len);
+
+	spin_lock_irqsave(&bam_dmux_logging_spinlock, flags);
+	if (kfifo_avail(&bam_dmux_state_log) < LOG_MESSAGE_MAX_SIZE) {
+		char junk[LOG_MESSAGE_MAX_SIZE];
+		int ret;
+
+		ret = kfifo_out(&bam_dmux_state_log, junk, sizeof(junk));
+		if (ret != LOG_MESSAGE_MAX_SIZE) {
+			pr_err("%s: unable to empty log %d\n", __func__, ret);
+			spin_unlock_irqrestore(&bam_dmux_logging_spinlock,
+					flags);
+			return;
+		}
+	}
+	kfifo_in(&bam_dmux_state_log, buff, sizeof(buff));
+	spin_unlock_irqrestore(&bam_dmux_logging_spinlock, flags);
+}
 
 static inline void set_tx_timestamp(struct tx_pkt_info *pkt)
 {
@@ -370,12 +406,12 @@
 	spin_lock_irqsave(&bam_tx_pool_spinlock, flags);
 	list_for_each_entry(info, &bam_tx_pool, list_node) {
 		if (!reported) {
-			BAM_DMUX_LOG("%s: tx pool not empty\n", func);
+			bam_dmux_log("%s: tx pool not empty\n", func);
 			if (!in_global_reset)
 				pr_err("%s: tx pool not empty\n", func);
 			reported = 1;
 		}
-		BAM_DMUX_LOG("%s: node=%p ts=%u.%09lu\n", __func__,
+		bam_dmux_log("%s: node=%p ts=%u.%09lu\n", __func__,
 			&info->list_node, info->ts_sec, info->ts_nsec);
 		if (!in_global_reset)
 			pr_err("%s: node=%p ts=%u.%09lu\n", __func__,
@@ -503,7 +539,7 @@
 
 	mutex_lock(&bam_pdev_mutexlock);
 	if (in_global_reset) {
-		BAM_DMUX_LOG("%s: open cid %d aborted due to ssr\n",
+		bam_dmux_log("%s: open cid %d aborted due to ssr\n",
 				__func__, rx_hdr->ch_id);
 		mutex_unlock(&bam_pdev_mutexlock);
 		queue_rx();
@@ -567,18 +603,18 @@
 		bam_mux_process_data(rx_skb);
 		break;
 	case BAM_MUX_HDR_CMD_OPEN:
-		BAM_DMUX_LOG("%s: opening cid %d PC enabled\n", __func__,
+		bam_dmux_log("%s: opening cid %d PC enabled\n", __func__,
 				rx_hdr->ch_id);
 		handle_bam_mux_cmd_open(rx_hdr);
 		if (!(rx_hdr->reserved & ENABLE_DISCONNECT_ACK)) {
-			BAM_DMUX_LOG("%s: deactivating disconnect ack\n",
+			bam_dmux_log("%s: deactivating disconnect ack\n",
 								__func__);
 			disconnect_ack = 0;
 		}
 		dev_kfree_skb_any(rx_skb);
 		break;
 	case BAM_MUX_HDR_CMD_OPEN_NO_A2_PC:
-		BAM_DMUX_LOG("%s: opening cid %d PC disabled\n", __func__,
+		bam_dmux_log("%s: opening cid %d PC disabled\n", __func__,
 				rx_hdr->ch_id);
 
 		if (!a2_pc_disabled) {
@@ -591,11 +627,11 @@
 		break;
 	case BAM_MUX_HDR_CMD_CLOSE:
 		/* probably should drop pending write */
-		BAM_DMUX_LOG("%s: closing cid %d\n", __func__,
+		bam_dmux_log("%s: closing cid %d\n", __func__,
 				rx_hdr->ch_id);
 		mutex_lock(&bam_pdev_mutexlock);
 		if (in_global_reset) {
-			BAM_DMUX_LOG("%s: close cid %d aborted due to ssr\n",
+			bam_dmux_log("%s: close cid %d aborted due to ssr\n",
 					__func__, rx_hdr->ch_id);
 			mutex_unlock(&bam_pdev_mutexlock);
 			break;
@@ -912,10 +948,8 @@
 	if (!bam_is_connected) {
 		read_unlock(&ul_wakeup_lock);
 		ul_wakeup();
-		if (unlikely(in_global_reset == 1)) {
-			kfree(hdr);
+		if (unlikely(in_global_reset == 1))
 			return -EFAULT;
-		}
 		read_lock(&ul_wakeup_lock);
 		notify_all(BAM_DMUX_UL_CONNECTED, (unsigned long)(NULL));
 	}
@@ -1342,6 +1376,60 @@
 	return i;
 }
 
+static int debug_log(char *buff, int max, loff_t *ppos)
+{
+	unsigned long flags;
+	int i = 0;
+
+	if (bam_dmux_state_logging_disabled) {
+		i += scnprintf(buff - i, max - i, "Logging disabled\n");
+		return i;
+	}
+
+	if (*ppos == 0) {
+		i += scnprintf(buff - i, max - i,
+			"<DMUX> timestamp FLAGS [Message]\n"
+			"FLAGS:\n"
+			"\tD: 1 = Power collapse disabled\n"
+			"\tR: 1 = in global reset\n"
+			"\tP: 1 = BAM is powered up\n"
+			"\tA: 1 = BAM initialized and ready for data\n"
+			"\n"
+			"\tV: 1 = Uplink vote for power\n"
+			"\tU: 1 = Uplink active\n"
+			"\tW: 1 = Uplink Wait-for-ack\n"
+			"\tA: 1 = Uplink ACK received\n"
+			"\t#: >=1 On-demand uplink vote\n"
+			"\tD: 1 = Disconnect ACK active\n"
+				);
+		buff += i;
+	}
+
+	spin_lock_irqsave(&bam_dmux_logging_spinlock, flags);
+	while (kfifo_len(&bam_dmux_state_log)
+			&& (i + LOG_MESSAGE_MAX_SIZE) < max) {
+		int k_len;
+		k_len = kfifo_out(&bam_dmux_state_log,
+				buff, LOG_MESSAGE_MAX_SIZE);
+		if (k_len != LOG_MESSAGE_MAX_SIZE) {
+			pr_err("%s: retrieve failure %d\n", __func__, k_len);
+			break;
+		}
+
+		/* keep non-null portion of string and add line break */
+		k_len = strnlen(buff, LOG_MESSAGE_MAX_SIZE);
+		buff += k_len;
+		i += k_len;
+		if (k_len && *(buff - 1) != '\n') {
+			*buff++ = '\n';
+			++i;
+		}
+	}
+	spin_unlock_irqrestore(&bam_dmux_logging_spinlock, flags);
+
+	return i;
+}
+
 #define DEBUG_BUFMAX 4096
 static char debug_buffer[DEBUG_BUFMAX];
 
@@ -1353,6 +1441,30 @@
 	return simple_read_from_buffer(buf, count, ppos, debug_buffer, bsize);
 }
 
+static ssize_t debug_read_multiple(struct file *file, char __user *buff,
+				size_t count, loff_t *ppos)
+{
+	int (*util_func)(char *buf, int max, loff_t *) = file->private_data;
+	char *buffer;
+	int bsize;
+
+	buffer = kmalloc(count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	bsize = util_func(buffer, count, ppos);
+
+	if (bsize >= 0) {
+		if (copy_to_user(buff, buffer, bsize)) {
+			kfree(buffer);
+			return -EFAULT;
+		}
+		*ppos += bsize;
+	}
+	kfree(buffer);
+	return bsize;
+}
+
 static int debug_open(struct inode *inode, struct file *file)
 {
 	file->private_data = inode->i_private;
@@ -1365,6 +1477,11 @@
 	.open = debug_open,
 };
 
+static const struct file_operations debug_ops_multiple = {
+	.read = debug_read_multiple,
+	.open = debug_open,
+};
+
 static void debug_create(const char *name, mode_t mode,
 				struct dentry *dent,
 				int (*fill)(char *buf, int max))
@@ -1377,6 +1494,17 @@
 				(int)PTR_ERR(file));
 }
 
+static void debug_create_multiple(const char *name, mode_t mode,
+				struct dentry *dent,
+				int (*fill)(char *buf, int max, loff_t *ppos))
+{
+	struct dentry *file;
+
+	file = debugfs_create_file(name, mode, dent, fill, &debug_ops_multiple);
+	if (IS_ERR(file))
+		pr_err("%s: debugfs create failed %d\n", __func__,
+				(int)PTR_ERR(file));
+}
 #endif
 
 static void notify_all(int event, unsigned long data)
@@ -1388,7 +1516,7 @@
 	for (i = 0; i < BAM_DMUX_NUM_CHANNELS; ++i) {
 		if (bam_ch_is_open(i)) {
 			bam_ch[i].notify(bam_ch[i].priv, event, data);
-			BAM_DMUX_LOG("%s: cid=%d, event=%d, data=%lu\n",
+			bam_dmux_log("%s: cid=%d, event=%d, data=%lu\n",
 					__func__, i, event, data);
 		}
 	}
@@ -1431,11 +1559,11 @@
 
 static void power_vote(int vote)
 {
-	BAM_DMUX_LOG("%s: curr=%d, vote=%d\n", __func__,
+	bam_dmux_log("%s: curr=%d, vote=%d\n", __func__,
 			bam_dmux_uplink_vote, vote);
 
 	if (bam_dmux_uplink_vote == vote)
-		BAM_DMUX_LOG("%s: warning - duplicate power vote\n", __func__);
+		bam_dmux_log("%s: warning - duplicate power vote\n", __func__);
 
 	bam_dmux_uplink_vote = vote;
 	if (vote)
@@ -1449,7 +1577,7 @@
  */
 static inline void ul_powerdown(void)
 {
-	BAM_DMUX_LOG("%s: powerdown\n", __func__);
+	bam_dmux_log("%s: powerdown\n", __func__);
 	verify_tx_queue_is_empty(__func__);
 
 	if (a2_pc_disabled) {
@@ -1561,7 +1689,7 @@
 		}
 
 		if (ul_packet_written || atomic_read(&ul_ondemand_vote)) {
-			BAM_DMUX_LOG("%s: pkt written %d\n",
+			bam_dmux_log("%s: pkt written %d\n",
 				__func__, ul_packet_written);
 			ul_packet_written = 0;
 			schedule_delayed_work(&ul_timeout_work,
@@ -1576,14 +1704,10 @@
 
 static int ssrestart_check(void)
 {
-	int ret = 0;
-
-	DMUX_LOG_KERR("%s: modem timeout: BAM DMUX disabled for SSR\n",
-								__func__);
+	DMUX_LOG_KERR("%s: modem timeout: BAM DMUX disabled\n", __func__);
 	in_global_reset = 1;
-	ret = subsystem_restart("modem");
-	if (ret == -ENODEV)
-		panic("modem subsystem restart failed\n");
+	if (get_restart_level() <= RESET_SOC)
+		DMUX_LOG_KERR("%s: ssrestart not enabled\n", __func__);
 	return 1;
 }
 
@@ -1594,7 +1718,7 @@
 
 	mutex_lock(&wakeup_lock);
 	if (bam_is_connected) { /* bam got connected before lock grabbed */
-		BAM_DMUX_LOG("%s Already awake\n", __func__);
+		bam_dmux_log("%s Already awake\n", __func__);
 		mutex_unlock(&wakeup_lock);
 		return;
 	}
@@ -1657,35 +1781,35 @@
 	 * instead of waiting
 	 */
 	if (wait_for_ack) {
-		BAM_DMUX_LOG("%s waiting for previous ack\n", __func__);
+		bam_dmux_log("%s waiting for previous ack\n", __func__);
 		ret = wait_for_completion_timeout(
 					&ul_wakeup_ack_completion, HZ);
 		wait_for_ack = 0;
 		if (unlikely(ret == 0) && ssrestart_check()) {
 			mutex_unlock(&wakeup_lock);
-			BAM_DMUX_LOG("%s timeout previous ack\n", __func__);
+			bam_dmux_log("%s timeout previous ack\n", __func__);
 			return;
 		}
 	}
 	INIT_COMPLETION(ul_wakeup_ack_completion);
 	power_vote(1);
-	BAM_DMUX_LOG("%s waiting for wakeup ack\n", __func__);
+	bam_dmux_log("%s waiting for wakeup ack\n", __func__);
 	ret = wait_for_completion_timeout(&ul_wakeup_ack_completion, HZ);
 	if (unlikely(ret == 0) && ssrestart_check()) {
 		mutex_unlock(&wakeup_lock);
-		BAM_DMUX_LOG("%s timeout wakeup ack\n", __func__);
+		bam_dmux_log("%s timeout wakeup ack\n", __func__);
 		return;
 	}
-	BAM_DMUX_LOG("%s waiting completion\n", __func__);
+	bam_dmux_log("%s waiting completion\n", __func__);
 	ret = wait_for_completion_timeout(&bam_connection_completion, HZ);
 	if (unlikely(ret == 0) && ssrestart_check()) {
 		mutex_unlock(&wakeup_lock);
-		BAM_DMUX_LOG("%s timeout power on\n", __func__);
+		bam_dmux_log("%s timeout power on\n", __func__);
 		return;
 	}
 
 	bam_is_connected = 1;
-	BAM_DMUX_LOG("%s complete\n", __func__);
+	bam_dmux_log("%s complete\n", __func__);
 	schedule_delayed_work(&ul_timeout_work,
 				msecs_to_jiffies(UL_TIMEOUT_DELAY));
 	mutex_unlock(&wakeup_lock);
@@ -1742,7 +1866,7 @@
 	/* handle disconnect during active UL */
 	write_lock_irqsave(&ul_wakeup_lock, flags);
 	if (bam_is_connected) {
-		BAM_DMUX_LOG("%s: UL active - forcing powerdown\n", __func__);
+		bam_dmux_log("%s: UL active - forcing powerdown\n", __func__);
 		ul_powerdown();
 	}
 	write_unlock_irqrestore(&ul_wakeup_lock, flags);
@@ -1781,10 +1905,10 @@
 {
 	int rc;
 
-	BAM_DMUX_LOG("%s\n", __func__);
+	bam_dmux_log("%s\n", __func__);
 	mutex_lock(&dfab_status_lock);
 	if (dfab_is_on) {
-		BAM_DMUX_LOG("%s: dfab is already on\n", __func__);
+		bam_dmux_log("%s: dfab is already on\n", __func__);
 		mutex_unlock(&dfab_status_lock);
 		return;
 	}
@@ -1806,7 +1930,7 @@
 
 static void unvote_dfab(void)
 {
-	BAM_DMUX_LOG("%s\n", __func__);
+	bam_dmux_log("%s\n", __func__);
 	mutex_lock(&dfab_status_lock);
 	if (!dfab_is_on) {
 		DMUX_LOG_KERR("%s: dfab is already off\n", __func__);
@@ -1828,7 +1952,7 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&wakelock_reference_lock, flags);
-	BAM_DMUX_LOG("%s: ref count = %d\n", __func__,
+	bam_dmux_log("%s: ref count = %d\n", __func__,
 						wakelock_reference_count);
 	if (wakelock_reference_count == 0)
 		wake_lock(&bam_wakelock);
@@ -1847,7 +1971,7 @@
 		spin_unlock_irqrestore(&wakelock_reference_lock, flags);
 		return;
 	}
-	BAM_DMUX_LOG("%s: ref count = %d\n", __func__,
+	bam_dmux_log("%s: ref count = %d\n", __func__,
 						wakelock_reference_count);
 	--wakelock_reference_count;
 	if (wakelock_reference_count == 0)
@@ -1868,7 +1992,7 @@
 	if (code != SUBSYS_AFTER_SHUTDOWN)
 		return NOTIFY_DONE;
 
-	BAM_DMUX_LOG("%s: begin\n", __func__);
+	bam_dmux_log("%s: begin\n", __func__);
 	in_global_reset = 1;
 
 	/* Handle uplink Powerdown */
@@ -1926,7 +2050,7 @@
 	}
 	spin_unlock_irqrestore(&bam_tx_pool_spinlock, flags);
 
-	BAM_DMUX_LOG("%s: complete\n", __func__);
+	bam_dmux_log("%s: complete\n", __func__);
 	return NOTIFY_DONE;
 }
 
@@ -2173,7 +2297,7 @@
 {
 	static unsigned int clear_bit; /* 0 = set the bit, else clear bit */
 
-	BAM_DMUX_LOG("%s: apps ack %d->%d\n", __func__,
+	bam_dmux_log("%s: apps ack %d->%d\n", __func__,
 			clear_bit & 0x1, ~clear_bit & 0x1);
 	smsm_change_state(SMSM_APPS_STATE,
 				clear_bit & SMSM_A2_POWER_CONTROL_ACK,
@@ -2189,10 +2313,10 @@
 	mutex_lock(&smsm_cb_lock);
 	bam_dmux_power_state = new_state & SMSM_A2_POWER_CONTROL ? 1 : 0;
 	DBG_INC_A2_POWER_CONTROL_IN_CNT();
-	BAM_DMUX_LOG("%s: 0x%08x -> 0x%08x\n", __func__, old_state,
+	bam_dmux_log("%s: 0x%08x -> 0x%08x\n", __func__, old_state,
 			new_state);
 	if (last_processed_state == (new_state & SMSM_A2_POWER_CONTROL)) {
-		BAM_DMUX_LOG("%s: already processed this state\n", __func__);
+		bam_dmux_log("%s: already processed this state\n", __func__);
 		mutex_unlock(&smsm_cb_lock);
 		return;
 	}
@@ -2200,23 +2324,23 @@
 	last_processed_state = new_state & SMSM_A2_POWER_CONTROL;
 
 	if (bam_mux_initialized && new_state & SMSM_A2_POWER_CONTROL) {
-		BAM_DMUX_LOG("%s: reconnect\n", __func__);
+		bam_dmux_log("%s: reconnect\n", __func__);
 		grab_wakelock();
 		reconnect_to_bam();
 	} else if (bam_mux_initialized &&
 					!(new_state & SMSM_A2_POWER_CONTROL)) {
-		BAM_DMUX_LOG("%s: disconnect\n", __func__);
+		bam_dmux_log("%s: disconnect\n", __func__);
 		disconnect_to_bam();
 		release_wakelock();
 	} else if (new_state & SMSM_A2_POWER_CONTROL) {
-		BAM_DMUX_LOG("%s: init\n", __func__);
+		bam_dmux_log("%s: init\n", __func__);
 		grab_wakelock();
 		if (cpu_is_msm9615())
 			msm9615_bam_init();
 		else
 			bam_init();
 	} else {
-		BAM_DMUX_LOG("%s: bad state change\n", __func__);
+		bam_dmux_log("%s: bad state change\n", __func__);
 		pr_err("%s: unsupported state change\n", __func__);
 	}
 	mutex_unlock(&smsm_cb_lock);
@@ -2227,7 +2351,7 @@
 						uint32_t new_state)
 {
 	DBG_INC_ACK_IN_CNT();
-	BAM_DMUX_LOG("%s: 0x%08x -> 0x%08x\n", __func__, old_state,
+	bam_dmux_log("%s: 0x%08x -> 0x%08x\n", __func__, old_state,
 			new_state);
 	complete_all(&ul_wakeup_ack_completion);
 }
@@ -2266,12 +2390,12 @@
 
 	xo_clk = clk_get(&pdev->dev, "xo");
 	if (IS_ERR(xo_clk)) {
-		BAM_DMUX_LOG("%s: did not get xo clock\n", __func__);
+		bam_dmux_log("%s: did not get xo clock\n", __func__);
 		xo_clk = NULL;
 	}
 	dfab_clk = clk_get(&pdev->dev, "bus_clk");
 	if (IS_ERR(dfab_clk)) {
-		BAM_DMUX_LOG("%s: did not get dfab clock\n", __func__);
+		bam_dmux_log("%s: did not get dfab clock\n", __func__);
 		dfab_clk = NULL;
 	} else {
 		rc = clk_set_rate(dfab_clk, 64000000);
@@ -2368,6 +2492,7 @@
 
 static int __init bam_dmux_init(void)
 {
+	int ret;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dent;
 
@@ -2376,12 +2501,13 @@
 		debug_create("tbl", 0444, dent, debug_tbl);
 		debug_create("ul_pkt_cnt", 0444, dent, debug_ul_pkt_cnt);
 		debug_create("stats", 0444, dent, debug_stats);
+		debug_create_multiple("log", 0444, dent, debug_log);
 	}
 #endif
-
-	bam_ipc_log_txt = ipc_log_context_create(BAM_IPC_LOG_PAGES, "bam_dmux");
-	if (!bam_ipc_log_txt) {
-		pr_err("%s : unable to create IPC Logging Context", __func__);
+	ret = kfifo_alloc(&bam_dmux_state_log, PAGE_SIZE, GFP_KERNEL);
+	if (ret) {
+		pr_err("%s: failed to allocate log %d\n", __func__, ret);
+		bam_dmux_state_logging_disabled = 1;
 	}
 
 	rx_timer_interval = DEFAULT_POLLING_MIN_SLEEP;
Only in mach-msm: batterydata-lib.c
diff --unified -r mach-msm/bms-batterydata.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/bms-batterydata.c
--- mach-msm/bms-batterydata.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/bms-batterydata.c	2013-12-17 17:08:05.606151173 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -10,7 +10,7 @@
  * GNU General Public License for more details.
  */
 
-#include <linux/mfd/pm8xxx/batterydata-lib.h>
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
 
 static struct single_row_lut fcc_temp = {
 	.x		= {-20, 0, 25, 40, 65},
@@ -99,11 +99,10 @@
 	}
 };
 
-struct bms_battery_data palladium_1500_data = {
+struct pm8921_bms_battery_data palladium_1500_data = {
 	.fcc			= 1500,
 	.fcc_temp_lut		= &fcc_temp,
 	.pc_temp_ocv_lut	= &pc_temp_ocv,
 	.rbatt_sf_lut		= &rbatt_sf,
 	.default_rbatt_mohm	= 236,
-	.rbatt_capacitive_mohm	= 50,
 };
diff --unified -r mach-msm/bms-batterydata-desay.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/bms-batterydata-desay.c
--- mach-msm/bms-batterydata-desay.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/bms-batterydata-desay.c	2013-12-17 17:08:05.606151173 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -10,7 +10,7 @@
  * GNU General Public License for more details.
  */
 
-#include <linux/mfd/pm8xxx/batterydata-lib.h>
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
 
 static struct single_row_lut desay_5200_fcc_temp = {
 	.x		= {-20, 0, 25, 40},
@@ -76,12 +76,11 @@
 	},
 };
 
-struct bms_battery_data desay_5200_data = {
+struct pm8921_bms_battery_data desay_5200_data = {
 	.fcc			= 5200,
 	.fcc_temp_lut		= &desay_5200_fcc_temp,
 	.fcc_sf_lut		= &desay_5200_fcc_sf,
 	.pc_temp_ocv_lut	= &desay_5200_pc_temp_ocv,
 	.pc_sf_lut		= &desay_5200_pc_sf,
 	.default_rbatt_mohm	= 156,
-	.rbatt_capacitive_mohm	= 50,
 };
diff --unified -r mach-msm/board-8064.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064.c
--- mach-msm/board-8064.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064.c	2013-12-17 17:08:05.606151173 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -69,14 +69,12 @@
 #include <linux/msm_tsens.h>
 #include <mach/msm_xo.h>
 #include <mach/msm_rtb.h>
-#include <mach/msm_serial_hs.h>
 #include <sound/cs8427.h>
 #include <media/gpio-ir-recv.h>
 #include <linux/fmem.h>
 #include <mach/msm_pcie.h>
 #include <mach/restart.h>
 #include <mach/msm_iomap.h>
-#include <mach/msm_serial_hs.h>
 
 #include "msm_watchdog.h"
 #include "board-8064.h"
@@ -88,7 +86,6 @@
 #include "pm-boot.h"
 #include "devices-msm8x60.h"
 #include "smd_private.h"
-#include "sysmon.h"
 
 #ifdef CONFIG_SEC_THERMISTOR
 #include <mach/sec_thermistor.h>
@@ -105,10 +102,9 @@
 
 #ifdef CONFIG_MSM_MULTIMEDIA_USE_ION
 #define HOLE_SIZE		0x20000
-#define MSM_ION_MFC_META_SIZE  0x40000 /* 256 Kbytes */
 #define MSM_CONTIG_MEM_SIZE  0x65000
 #ifdef CONFIG_MSM_IOMMU
-#define MSM_ION_MM_SIZE		0x4800000
+#define MSM_ION_MM_SIZE		0x3800000
 #define MSM_ION_SF_SIZE		0
 #define MSM_ION_QSECOM_SIZE	0x780000 /* (7.5MB) */
 #define MSM_ION_HEAP_NUM	8
@@ -119,7 +115,7 @@
 #define MSM_ION_HEAP_NUM	8
 #endif
 #define MSM_ION_MM_FW_SIZE	(0x200000 - HOLE_SIZE) /* (2MB - 128KB) */
-#define MSM_ION_MFC_SIZE	(SZ_8K + MSM_ION_MFC_META_SIZE)
+#define MSM_ION_MFC_SIZE	SZ_8K
 #define MSM_ION_AUDIO_SIZE	MSM_PMEM_AUDIO_SIZE
 #else
 #define MSM_CONTIG_MEM_SIZE  0x110C000
@@ -225,13 +221,6 @@
 #endif /* CONFIG_MSM_MULTIMEDIA_USE_ION */
 #endif /* CONFIG_ANDROID_PMEM */
 
-#ifdef CONFIG_BATTERY_BCL
-static struct platform_device battery_bcl_device = {
-	.name = "battery_current_limit",
-	.id = -1,
-	};
-#endif
-
 struct fmem_platform_data apq8064_fmem_pdata = {
 };
 
@@ -250,8 +239,6 @@
 {
 #if defined(CONFIG_MSM_RTB)
 	apq8064_reserve_table[MEMTYPE_EBI1].size += apq8064_rtb_pdata.size;
-	pr_info("mem_map: rtb reserved with size 0x%x in pool\n",
-			apq8064_rtb_pdata.size);
 #endif
 }
 
@@ -285,8 +272,6 @@
 	reserve_memory_for(&android_pmem_audio_pdata);
 #endif /*CONFIG_MSM_MULTIMEDIA_USE_ION*/
 	apq8064_reserve_table[MEMTYPE_EBI1].size += msm_contig_mem_size;
-	pr_info("mem_map: contig_mem reserved with size 0x%x in pool\n",
-			msm_contig_mem_size);
 #endif /*CONFIG_ANDROID_PMEM*/
 }
 
@@ -475,9 +460,6 @@
 
 	ret = memblock_remove(reserve_info->fixed_area_start,
 		reserve_info->fixed_area_size);
-	pr_info("mem_map: fixed_area reserved at 0x%lx with size 0x%lx\n",
-			reserve_info->fixed_area_start,
-			reserve_info->fixed_area_size);
 	BUG_ON(ret);
 #endif
 }
@@ -547,7 +529,7 @@
 
 			if (fixed_position != NOT_FIXED)
 				fixed_size += heap->size;
-			else if (!use_cma)
+			else
 				reserve_mem_for_ion(MEMTYPE_EBI1, heap->size);
 
 			if (fixed_position == FIXED_LOW) {
@@ -591,9 +573,6 @@
 		BUG_ON(!IS_ALIGNED(fixed_low_size + HOLE_SIZE, SECTION_SIZE));
 		ret = memblock_remove(fixed_low_start,
 				      fixed_low_size + HOLE_SIZE);
-		pr_info("mem_map: fixed_low_area reserved at 0x%lx with size \
-				0x%x\n", fixed_low_start,
-				fixed_low_size + HOLE_SIZE);
 		BUG_ON(ret);
 	}
 
@@ -604,9 +583,6 @@
 	} else {
 		BUG_ON(!IS_ALIGNED(fixed_middle_size, SECTION_SIZE));
 		ret = memblock_remove(fixed_middle_start, fixed_middle_size);
-		pr_info("mem_map: fixed_middle_area reserved at 0x%lx with \
-				size 0x%x\n", fixed_middle_start,
-				fixed_middle_size);
 		BUG_ON(ret);
 	}
 
@@ -618,9 +594,6 @@
 		/* This is the end of the fixed area so it's okay to round up */
 		fixed_high_size = ALIGN(fixed_high_size, SECTION_SIZE);
 		ret = memblock_remove(fixed_high_start, fixed_high_size);
-		pr_info("mem_map: fixed_high_area reserved at 0x%lx with size \
-				0x%x\n", fixed_high_start,
-				fixed_high_size);
 		BUG_ON(ret);
 	}
 
@@ -688,8 +661,6 @@
 	total = apq8064_cache_dump_pdata.l1_size +
 		apq8064_cache_dump_pdata.l2_size;
 	apq8064_reserve_table[MEMTYPE_EBI1].size += total;
-	pr_info("mem_map: cache_dump reserved with size 0x%x in pool\n",
-			total);
 #endif
 }
 
@@ -1810,87 +1781,21 @@
 
 static struct gpiomux_setting mdm2ap_status_gpio_run_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 static struct mdm_platform_data mdm_platform_data = {
 	.mdm_version = "3.0",
 	.ramdump_delay_ms = 2000,
-	.early_power_on = 1,
-	.sfr_query = 1,
-	.send_shdn = 1,
-	.vddmin_resource = &mdm_vddmin_rscs,
-	.peripheral_platform_device = &apq8064_device_hsic_host,
-	.ramdump_timeout_ms = 120000,
-	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM,
-};
-
-static struct mdm_platform_data amdm_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-	.early_power_on = 1,
-	.sfr_query = 1,
-	.send_shdn = 1,
-	.vddmin_resource = &mdm_vddmin_rscs,
-	.peripheral_platform_device = &apq8064_device_hsic_host,
-	.ramdump_timeout_ms = 120000,
-	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM,
-	.no_a2m_errfatal_on_ssr = 1,
-};
-
-static struct mdm_vddmin_resource bmdm_vddmin_rscs = {
-	.rpm_id = MSM_RPM_ID_VDDMIN_GPIO,
-	.ap2mdm_vddmin_gpio = 30,
-	.modes  = 0x03,
-	.drive_strength = 8,
-	.mdm2ap_vddmin_gpio = 64,
-};
-
-static struct mdm_platform_data bmdm_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-	.sfr_query = 1,
-	.send_shdn = 1,
-	.vddmin_resource = &bmdm_vddmin_rscs,
-	.peripheral_platform_device = &apq8064_device_ehci_host3,
-	.ramdump_timeout_ms = 120000,
-	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM2,
-	.no_a2m_errfatal_on_ssr = 1,
-};
-
-static struct mdm_platform_data sglte2_mdm_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
+	  /* delay between two PS_HOLDs */
+	.ps_hold_delay_ms = 500,
 	.early_power_on = 1,
 	.sfr_query = 1,
 	.vddmin_resource = &mdm_vddmin_rscs,
 	.peripheral_platform_device = &apq8064_device_hsic_host,
 	.ramdump_timeout_ms = 120000,
 	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM,
-	.no_a2m_errfatal_on_ssr = 1,
-	.subsys_name = "external_modem_mdm",
-};
-
-static struct mdm_platform_data sglte2_qsc_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-     /* delay between two PS_HOLDs */
-	.ps_hold_delay_ms = 500,
-	.ramdump_timeout_ms = 600000,
-	.no_powerdown_after_ramdumps = 1,
-	.image_upgrade_supported = 1,
-	.no_a2m_errfatal_on_ssr = 1,
-	.kpd_not_inverted = 1,
-	.subsys_name = "external_modem",
 };
 
 static struct tsens_platform_data apq_tsens_pdata  = {
@@ -1912,9 +1817,6 @@
 	.limit_temp_degC = 60,
 	.temp_hysteresis_degC = 10,
 	.freq_step = 2,
-	.core_limit_temp_degC = 80,
-	.core_temp_hysteresis_degC = 10,
-	.core_control_mask = 0xe,
 };
 
 #define MSM_SHARED_RAM_PHYS 0x80000000
@@ -2402,6 +2304,7 @@
 static struct platform_device *common_not_mpq_devices[] __initdata = {
 	&apq8064_device_qup_i2c_gsbi1,
 	&apq8064_device_qup_i2c_gsbi3,
+	&apq8064_device_qup_i2c_gsbi4,
 };
 
 static struct platform_device *early_common_devices[] __initdata = {
@@ -2418,6 +2321,7 @@
 	&apq8064_device_ext_3p3v_vreg,
 	&apq8064_device_ssbi_pmic1,
 	&apq8064_device_ssbi_pmic2,
+	&apq8064_device_ext_ts_sw_vreg,
 };
 
 static struct platform_device *pm8917_common_devices[] __initdata = {
@@ -2425,6 +2329,7 @@
 	&apq8064_device_ext_3p3v_vreg,
 	&apq8064_device_ssbi_pmic1,
 	&apq8064_device_ssbi_pmic2,
+	&apq8064_device_ext_ts_sw_vreg,
 };
 
 static struct platform_device *common_devices[] __initdata = {
@@ -2648,20 +2553,6 @@
 }
 late_initcall(rf4ce_gpio_init);
 
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data mpq8064_gsbi6_uartdm_pdata = {
-	.config_gpio		= 4,
-	.uart_tx_gpio		= 14,
-	.uart_rx_gpio		= 15,
-	.uart_cts_gpio		= 16,
-	.uart_rfr_gpio		= 17,
-	.inject_rx_on_wakeup	= 1,
-	.rx_to_inject		= 0xFD,
-};
-#else
-static struct msm_serial_hs_platform_data msm_uart_dm9_pdata;
-#endif
-
 static struct platform_device *mpq_devices[] __initdata = {
 	&msm_device_sps_apq8064,
 	&mpq8064_device_qup_i2c_gsbi5,
@@ -2754,13 +2645,8 @@
 					&apq8064_i2c_qup_gsbi3_pdata;
 	apq8064_device_qup_i2c_gsbi1.dev.platform_data =
 					&apq8064_i2c_qup_gsbi1_pdata;
-
-	/* Add GSBI4 I2C pdata for non-fusion3 SGLTE2 */
-	if (socinfo_get_platform_subtype() !=
-				PLATFORM_SUBTYPE_SGLTE2) {
-		apq8064_device_qup_i2c_gsbi4.dev.platform_data =
+	apq8064_device_qup_i2c_gsbi4.dev.platform_data =
 					&apq8064_i2c_qup_gsbi4_pdata;
-	}
 	mpq8064_device_qup_i2c_gsbi5.dev.platform_data =
 					&mpq8064_i2c_qup_gsbi5_pdata;
 	apq8064_device_qup_i2c_gsbi7.dev.platform_data =
@@ -3219,6 +3105,20 @@
 	}
 }
 
+static void enable_ddr3_regulator(void)
+{
+	static struct regulator *ext_ddr3;
+
+	/* Use MPP7 output state as a flag for PCDDR3 presence. */
+	if (gpio_get_value_cansleep(PM8921_MPP_PM_TO_SYS(7)) > 0) {
+		ext_ddr3 = regulator_get(NULL, "ext_ddr3");
+		if (IS_ERR(ext_ddr3) || ext_ddr3 == NULL)
+			pr_err("Could not get MPP7 regulator\n");
+		else
+			regulator_enable(ext_ddr3);
+	}
+}
+
 static void enable_avc_i2c_bus(void)
 {
 	int avc_i2c_en_mpp = PM8921_MPP_PM_TO_SYS(8);
@@ -3239,18 +3139,6 @@
 	cdp_keys_data.nbuttons = ARRAY_SIZE(cdp_keys_pm8917);
 }
 
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data apq8064_uartdm_gsbi4_pdata = {
-	.config_gpio	= 4,
-	.uart_tx_gpio	= 10,
-	.uart_rx_gpio	= 11,
-	.uart_cts_gpio	= 12,
-	.uart_rfr_gpio	= 13,
-};
-#else
-static struct msm_serial_hs_platform_data apq8064_uartdm_gsbi4_pdata;
-#endif
-
 static void __init apq8064ab_update_retention_spm(void)
 {
 	int i;
@@ -3270,21 +3158,11 @@
 
 static void __init apq8064_common_init(void)
 {
-	u32 platform_version = socinfo_get_platform_version();
+	u32 platform_version;
 
 	if (socinfo_get_pmic_model() == PMIC_MODEL_PM8917)
 		apq8064_pm8917_pdata_fixup();
 	platform_device_register(&msm_gpio_device);
-	if (cpu_is_apq8064ab())
-		apq8064ab_update_krait_spm();
-	if (cpu_is_krait_v3()) {
-		msm_pm_set_tz_retention_flag(0);
-		apq8064ab_update_retention_spm();
-	} else {
-		msm_pm_set_tz_retention_flag(1);
-	}
-	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
-	msm_spm_l2_init(msm_spm_l2_data);
 	msm_tsens_early_init(&apq_tsens_pdata);
 	msm_thermal_init(&msm_thermal_pdata);
 	if (socinfo_init() < 0)
@@ -3325,61 +3203,26 @@
 	else
 		platform_add_devices(pm8917_common_devices,
 					ARRAY_SIZE(pm8917_common_devices));
-
-	if (!machine_is_apq8064_mtp())
-		platform_device_register(&apq8064_device_ext_ts_sw_vreg);
-
 	platform_add_devices(common_devices, ARRAY_SIZE(common_devices));
 	if (!(machine_is_mpq8064_cdp() || machine_is_mpq8064_hrd() ||
-			machine_is_mpq8064_dtv())) {
+			machine_is_mpq8064_dtv()))
 		platform_add_devices(common_not_mpq_devices,
 			ARRAY_SIZE(common_not_mpq_devices));
-
-		/* Add GSBI4 I2C Device for non-fusion3 platform */
-		if (socinfo_get_platform_subtype() !=
-					PLATFORM_SUBTYPE_SGLTE2) {
-			platform_device_register(&apq8064_device_qup_i2c_gsbi4);
-		}
-	}
-
+	enable_ddr3_regulator();
 	msm_hsic_pdata.swfi_latency =
 		msm_rpmrs_levels[0].latency_us;
 	if (machine_is_apq8064_mtp()) {
 		msm_hsic_pdata.log2_irq_thresh = 5,
 		apq8064_device_hsic_host.dev.platform_data = &msm_hsic_pdata;
 		device_initialize(&apq8064_device_hsic_host.dev);
-		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_DSDA2) {
-			apq8064_device_ehci_host3.dev.platform_data =
-				&msm_ehci_host_pdata3;
-			device_initialize(&apq8064_device_ehci_host3.dev);
-		}
 	}
 	apq8064_pm8xxx_gpio_mpp_init();
 	apq8064_init_mmc();
 
 	if (machine_is_apq8064_mtp()) {
-		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_DSDA2) {
-			amdm_8064_device.dev.platform_data =
-				&amdm_platform_data;
-			platform_device_register(&amdm_8064_device);
-			bmdm_8064_device.dev.platform_data =
-				&bmdm_platform_data;
-			platform_device_register(&bmdm_8064_device);
-		} else if (socinfo_get_platform_subtype() ==
-				   PLATFORM_SUBTYPE_SGLTE2) {
-			sglte_mdm_8064_device.dev.platform_data =
-				&sglte2_mdm_platform_data;
-			platform_device_register(&sglte_mdm_8064_device);
-			sglte2_qsc_8064_device.dev.platform_data =
-				&sglte2_qsc_platform_data;
-			platform_device_register(&sglte2_qsc_8064_device);
-
-			/* GSBI4 UART device for Primay IPC */
-			apq8064_uartdm_gsbi4_pdata.wakeup_irq = gpio_to_irq(11);
-			apq8064_device_uartdm_gsbi4.dev.platform_data =
-						&apq8064_uartdm_gsbi4_pdata;
-			platform_device_register(&apq8064_device_uartdm_gsbi4);
-		} else if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
+		mdm_8064_device.dev.platform_data = &mdm_platform_data;
+		platform_version = socinfo_get_platform_version();
+		if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
 			i2s_mdm_8064_device.dev.platform_data =
 				&mdm_platform_data;
 			platform_device_register(&i2s_mdm_8064_device);
@@ -3395,6 +3238,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_apq8064ab())
+		apq8064ab_update_krait_spm();
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
+	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
+	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
 }
@@ -3432,16 +3285,6 @@
 	apq8064_init_cam();
 #endif
 
-	if (machine_is_mpq8064_hrd() || machine_is_mpq8064_dtv()) {
-#ifdef CONFIG_SERIAL_MSM_HS
-		/* GSBI6(2) - UARTDM_RX */
-		mpq8064_gsbi6_uartdm_pdata.wakeup_irq = gpio_to_irq(15);
-		mpq8064_device_uartdm_gsbi6.dev.platform_data =
-					&mpq8064_gsbi6_uartdm_pdata;
-#endif
-		platform_device_register(&mpq8064_device_uartdm_gsbi6);
-	}
-
 	if (machine_is_apq8064_cdp() || machine_is_apq8064_liquid())
 		platform_device_register(&cdp_kp_pdev);
 
diff --unified -r mach-msm/board-8064-gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-gpiomux.c
--- mach-msm/board-8064-gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-gpiomux.c	2013-12-17 17:08:05.606151173 -0800
@@ -797,38 +797,38 @@
 
 static struct gpiomux_setting ap2mdm_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting mdm2ap_status_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting mdm2ap_errfatal_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_16MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting mdm2ap_pblrdy = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_16MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 
 static struct gpiomux_setting ap2mdm_soft_reset_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting ap2mdm_wakeup = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
@@ -885,105 +885,6 @@
 	},
 };
 
-static struct msm_gpiomux_config amdm_configs[] __initdata = {
-	/* AP2MDM_STATUS */
-	{
-		.gpio = 48,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 49,
-		.settings = {
-			[GPIOMUX_ACTIVE] = &mdm2ap_status_cfg,
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 19,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-	/* AP2MDM_ERRFATAL */
-	{
-		.gpio = 18,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* AP2MDM_SOFT_RESET, aka AP2MDM_PON_RESET_N */
-	{
-		.gpio = 27,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_soft_reset_cfg,
-		}
-	},
-	/* AP2MDM_WAKEUP */
-	{
-		.gpio = 35,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_wakeup,
-		}
-	},
-	/* MDM2AP_PBL_READY*/
-	{
-		.gpio = 31,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_pblrdy,
-		}
-	},
-};
-
-static struct msm_gpiomux_config bmdm_configs[] __initdata = {
-	/* AP2MDM_STATUS */
-	{
-		.gpio = 56,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 32,
-		.settings = {
-			[GPIOMUX_ACTIVE] = &mdm2ap_status_cfg,
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 81,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-	/* AP2MDM_ERRFATAL */
-	{
-		.gpio = 18,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* AP2MDM_SOFT_RESET, aka AP2MDM_PON_RESET_N */
-	{
-		.gpio = 3,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_soft_reset_cfg,
-		}
-	},
-	/* AP2MDM_WAKEUP */
-	{
-		.gpio = 29,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_wakeup,
-		}
-	},
-};
-
 static struct msm_gpiomux_config mdm_i2s_configs[] __initdata = {
 	/* AP2MDM_STATUS */
 	{
@@ -1366,109 +1267,6 @@
 	},
 };
 
-static struct msm_gpiomux_config sglte2_qsc_configs[] __initdata = {
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 51,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 52,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-};
-
-static struct gpiomux_setting gsbi4_uartdm_active = {
-	.func = GPIOMUX_FUNC_1,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct gpiomux_setting gsbi4_uartdm_suspended = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct gpiomux_setting gsbi6_uartdm_active = {
-	.func = GPIOMUX_FUNC_2,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct gpiomux_setting gsbi6_uartdm_suspended = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct msm_gpiomux_config apq8064_uartdm_gsbi4_configs[] __initdata = {
-	{
-		.gpio      = 11,        /* GSBI4 UARTDM RX */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-	{
-		.gpio      = 10,       /* GSBI4 UARTDM TX */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-	{
-		.gpio      = 13,        /* GSBI4 UARTDM RFR */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-	{
-		.gpio      = 12,        /* GSBI4 UARTDM CTS */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-};
-
-static struct msm_gpiomux_config mpq8064_uartdm_configs[] __initdata = {
-	{ /* UARTDM_TX */
-		.gpio      = 14,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-	{ /* UARTDM_RX */
-		.gpio      = 15,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-	{ /* UARTDM_CTS */
-		.gpio      = 16,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-	{ /* UARTDM_RFR */
-		.gpio      = 17,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-};
-
 void __init apq8064_init_gpiomux(void)
 {
 	int rc;
@@ -1530,28 +1328,12 @@
 			ARRAY_SIZE(apq8064_ext_regulator_configs));
 
 	if (machine_is_apq8064_mtp()) {
-		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_DSDA2) {
-			msm_gpiomux_install(amdm_configs,
-					ARRAY_SIZE(amdm_configs));
-			msm_gpiomux_install(bmdm_configs,
-				ARRAY_SIZE(bmdm_configs));
-		} else if (socinfo_get_platform_subtype() ==
-					PLATFORM_SUBTYPE_SGLTE2) {
-			msm_gpiomux_install(mdm_configs,
-					ARRAY_SIZE(mdm_configs));
-			msm_gpiomux_install(sglte2_qsc_configs,
-					ARRAY_SIZE(sglte2_qsc_configs));
-
-			/* GSBI4 UART GPIOs for Primary IPC */
-			msm_gpiomux_install(apq8064_uartdm_gsbi4_configs,
-				ARRAY_SIZE(apq8064_uartdm_gsbi4_configs));
-		} else if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
+		if (SOCINFO_VERSION_MINOR(platform_version) == 1)
 			msm_gpiomux_install(mdm_i2s_configs,
 					ARRAY_SIZE(mdm_i2s_configs));
-		} else {
+		else
 			msm_gpiomux_install(mdm_configs,
 					ARRAY_SIZE(mdm_configs));
-		}
 	}
 
 	if (machine_is_apq8064_mtp()) {
@@ -1593,7 +1375,4 @@
 
 	msm_gpiomux_install(apq8064_sdc3_configs,
 			ARRAY_SIZE(apq8064_sdc3_configs));
-	 if (machine_is_mpq8064_hrd() || machine_is_mpq8064_dtv())
-		msm_gpiomux_install(mpq8064_uartdm_configs,
-				ARRAY_SIZE(mpq8064_uartdm_configs));
 }
diff --unified -r mach-msm/board-8064-gpu.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-gpu.c
--- mach-msm/board-8064-gpu.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-gpu.c	2013-12-17 17:08:05.606151173 -0800
@@ -93,13 +93,13 @@
 		.src = MSM_BUS_MASTER_GRAPHICS_3D,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab = 0,
-		.ib = KGSL_CONVERT_TO_MBPS(1700),
+		.ib = KGSL_CONVERT_TO_MBPS(1000),
 	},
 	{
 		.src = MSM_BUS_MASTER_GRAPHICS_3D_PORT1,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab = 0,
-		.ib = KGSL_CONVERT_TO_MBPS(1700),
+		.ib = KGSL_CONVERT_TO_MBPS(1000),
 	},
 };
 
@@ -182,6 +182,12 @@
 	{
 		.name = KGSL_3D0_REG_MEMORY,
 		.start = 0x04300000, /* GFX3D address */
+		.end = 0x0430ffff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name = KGSL_3D0_SHADER_MEMORY,
+		.start = 0x04310000, /* Shader Mem Address */
 		.end = 0x0431ffff,
 		.flags = IORESOURCE_MEM,
 	},
@@ -249,8 +255,7 @@
 	.num_levels = 5,
 	.set_grp_async = NULL,
 	.idle_timeout = HZ/10,
-	.nap_allowed = true,
-	.strtstp_sleepwake = false,
+	.strtstp_sleepwake = true,
 	.clk_map = KGSL_CLK_CORE | KGSL_CLK_IFACE | KGSL_CLK_MEM_IFACE,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.bus_scale_table = &grp3d_bus_scale_pdata,
diff --unified -r mach-msm/board-8064-pmic.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-pmic.c
--- mach-msm/board-8064-pmic.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-pmic.c	2013-12-17 17:08:05.606151173 -0800
@@ -143,10 +143,6 @@
 	PM8921_GPIO_INPUT(17, PM_GPIO_PULL_UP_1P5),	/* SD_WP */
 };
 
-static struct pm8xxx_gpio_init pm8921_mpq8064_hrd_gpios[] __initdata = {
-	PM8921_GPIO_OUTPUT(37, 0, LOW),	/* MUX1_SEL */
-};
-
 /* Initial PM8917 GPIO configurations */
 static struct pm8xxx_gpio_init pm8917_gpios[] __initdata = {
 	PM8921_GPIO_OUTPUT(14, 1, HIGH),	/* HDMI Mux Selector */
@@ -155,7 +151,7 @@
 	PM8921_GPIO_OUTPUT(26, 1, HIGH), /* Backlight: on */
 	PM8921_GPIO_OUTPUT_BUFCONF(36, 1, LOW, OPEN_DRAIN),
 	PM8921_GPIO_OUTPUT_FUNC(38, 0, PM_GPIO_FUNC_2),
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 	PM8921_GPIO_OUTPUT(33, 0, LOW), /* FLASH_SET */
 	PM8921_GPIO_OUTPUT(24, 0, LOW), /* FLASH_EN */
 #else
@@ -170,7 +166,7 @@
 	PM8921_GPIO_INPUT(12, PM_GPIO_PULL_UP_30),     /* PCIE_WAKE_N */
 };
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 #else
 /* Initial PM8917 SD Card Detection Pin */
 static struct pm8xxx_gpio_init pm8917_sd_det[] __initdata = {
@@ -190,10 +186,6 @@
 	PM8921_GPIO_INPUT(17, PM_GPIO_PULL_UP_1P5),	/* SD_WP */
 };
 
-static struct pm8xxx_gpio_init pm8921_8917_cdp_ts_gpios[] __initdata = {
-	PM8921_GPIO_OUTPUT(23, 0, HIGH),	/* touchscreen power FET */
-};
-
 static struct pm8xxx_gpio_init pm8921_mpq_gpios[] __initdata = {
 	PM8921_GPIO_INIT(27, PM_GPIO_DIR_IN, PM_GPIO_OUT_BUF_CMOS, 0,
 			PM_GPIO_PULL_NO, PM_GPIO_VIN_VPH, PM_GPIO_STRENGTH_NO,
@@ -206,11 +198,6 @@
 	PM8921_MPP_INIT(8, A_INPUT, PM8XXX_MPP_AIN_AMUX_CH8, AOUT_CTRL_DISABLE),
 };
 
-static struct pm8xxx_gpio_init pm8921_sglte2_gpios[] __initdata = {
-	PM8921_GPIO_OUTPUT(23, 1, HIGH),		/* PM2QSC_SOFT_RESET */
-	PM8921_GPIO_OUTPUT(21, 1, HIGH),		/* PM2QSC_KEYPADPWR */
-};
-
 void __init apq8064_configure_gpios(struct pm8xxx_gpio_init *data, int len)
 {
 	int i, rc;
@@ -227,7 +214,7 @@
 {
 	int i, rc;
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 	printk("%s Enter \n", __func__);
 	if (socinfo_get_pmic_model() != PMIC_MODEL_PM8917)
 		printk("PM8921 system_rev = %d\n", system_rev);
@@ -240,7 +227,7 @@
 	else {
 		apq8064_configure_gpios(pm8917_gpios, ARRAY_SIZE(pm8917_gpios));
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 #else
 #if defined(CONFIG_MACH_JF_ATT) || defined(CONFIG_MACH_JF_TMO) || defined(CONFIG_MACH_JF_EUR)
 		if (system_rev >= BOARD_REV09)
@@ -265,30 +252,17 @@
 		else
 			apq8064_configure_gpios(pm8917_cdp_kp_gpios,
 					ARRAY_SIZE(pm8917_cdp_kp_gpios));
-
-		apq8064_configure_gpios(pm8921_8917_cdp_ts_gpios,
-				ARRAY_SIZE(pm8921_8917_cdp_ts_gpios));
 	}
 
-	if (machine_is_apq8064_mtp()) {
+	if (machine_is_apq8064_mtp())
 		apq8064_configure_gpios(pm8921_mtp_kp_gpios,
 					ARRAY_SIZE(pm8921_mtp_kp_gpios));
-		if (socinfo_get_platform_subtype() ==
-					PLATFORM_SUBTYPE_SGLTE2) {
-			apq8064_configure_gpios(pm8921_sglte2_gpios,
-					ARRAY_SIZE(pm8921_sglte2_gpios));
-		}
-	}
 
 	if (machine_is_mpq8064_cdp() || machine_is_mpq8064_hrd()
 	    || machine_is_mpq8064_dtv())
 		apq8064_configure_gpios(pm8921_mpq_gpios,
 					ARRAY_SIZE(pm8921_mpq_gpios));
 
-	if (machine_is_mpq8064_hrd())
-		apq8064_configure_gpios(pm8921_mpq8064_hrd_gpios,
-					ARRAY_SIZE(pm8921_mpq8064_hrd_gpios));
-
 	for (i = 0; i < ARRAY_SIZE(pm8xxx_mpps); i++) {
 		rc = pm8xxx_mpp_config(pm8xxx_mpps[i].mpp,
 					&pm8xxx_mpps[i].config);
@@ -480,7 +454,7 @@
 
 static struct pm8xxx_rtc_platform_data
 apq8064_pm8921_rtc_pdata = {
-	.rtc_write_enable       = false,
+	.rtc_write_enable       = true,
 	.rtc_alarm_powerup      = false,
 };
 
@@ -495,17 +469,16 @@
 #define CHG_TERM_MA		100
 static struct pm8921_charger_platform_data
 apq8064_pm8921_chg_pdata __devinitdata = {
+	.safety_time		= 180,
 	.update_time		= 60000,
 	.max_voltage		= MAX_VOLTAGE_MV,
 	.min_voltage		= 3200,
 	.uvd_thresh_voltage	= 4050,
-	.alarm_low_mv		= 3400,
-	.alarm_high_mv		= 4000,
-	.resume_voltage_delta	= 60,
-	.resume_charge_percent	= 99,
+	.alarm_voltage		= 3400,
+	.resume_voltage_delta	= 100,
 	.term_current		= CHG_TERM_MA,
 	.cool_temp		= 10,
-	.warm_temp		= 45,
+	.warm_temp		= 40,
 	.temp_check_period	= 1,
 	.max_bat_chg_current	= 1100,
 	.cool_bat_chg_current	= 350,
@@ -514,37 +487,24 @@
 	.warm_bat_voltage	= 4100,
 	.thermal_mitigation	= apq8064_pm8921_therm_mitigation,
 	.thermal_levels		= ARRAY_SIZE(apq8064_pm8921_therm_mitigation),
-	.rconn_mohm		= 18,
-	.enable_tcxo_warmup_delay = true,
 };
 
 static struct pm8xxx_ccadc_platform_data
 apq8064_pm8xxx_ccadc_pdata = {
-	.r_sense_uohm		= 10000,
+	.r_sense		= 10,
 	.calib_delay_ms		= 600000,
 };
 
 static struct pm8921_bms_platform_data
 apq8064_pm8921_bms_pdata __devinitdata = {
 	.battery_type			= BATT_UNKNOWN,
-	.r_sense_uohm			= 10000,
+	.r_sense			= 10,
 	.v_cutoff			= 3400,
 	.max_voltage_uv			= MAX_VOLTAGE_MV * 1000,
 	.rconn_mohm			= 18,
 	.shutdown_soc_valid_limit	= 20,
 	.adjust_soc_low_threshold	= 25,
 	.chg_term_ua			= CHG_TERM_MA * 1000,
-	.normal_voltage_calc_ms		= 20000,
-	.low_voltage_calc_ms		= 1000,
-	.alarm_low_mv			= 3400,
-	.alarm_high_mv			= 4000,
-	.high_ocv_correction_limit_uv	= 50,
-	.low_ocv_correction_limit_uv	= 100,
-	.hold_soc_est			= 3,
-	.enable_fcc_learning		= 1,
-	.min_fcc_learning_soc		= 20,
-	.min_fcc_ocv_pc			= 30,
-	.min_fcc_learning_samples	= 5,
 };
 
 static struct pm8921_platform_data
@@ -624,10 +584,4 @@
 	} else if (machine_is_apq8064_cdp()) {
 		apq8064_pm8921_chg_pdata.has_dc_supply = true;
 	}
-
-	if (!machine_is_apq8064_mtp() && !machine_is_apq8064_liquid())
-		apq8064_pm8921_chg_pdata.battery_less_hardware = 1;
-
-	if (machine_is_mpq8064_hrd())
-		apq8064_pm8921_chg_pdata.disable_chg_rmvl_wrkarnd = 1;
 }
diff --unified -r mach-msm/board-8064-regulator.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-regulator.c
--- mach-msm/board-8064-regulator.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-regulator.c	2013-12-17 17:08:05.606151173 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -37,9 +37,9 @@
 	REGULATOR_SUPPLY("mipi_csi_vdd",	"msm_csid.2"),
 	REGULATOR_SUPPLY("lvds_pll_vdda",	"lvds.0"),
 	REGULATOR_SUPPLY("dsi1_pll_vdda",	"mipi_dsi.1"),
-	REGULATOR_SUPPLY("dsi_pll_vdda",	"mdp.0"),
 	REGULATOR_SUPPLY("HRD_VDDD_CDC_D",		"tabla2x-slim"),
 	REGULATOR_SUPPLY("HRD_CDC_VDDA_A_1P2V",	"tabla2x-slim"),
+	REGULATOR_SUPPLY("dsi_pll_vdda",	"mdp.0"),
 };
 VREG_CONSUMERS(L3) = {
 	REGULATOR_SUPPLY("8921_l3",		NULL),
@@ -77,7 +77,6 @@
 VREG_CONSUMERS(L8) = {
 	REGULATOR_SUPPLY("8921_l8",		NULL),
 	REGULATOR_SUPPLY("cam_vana",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vana",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vana",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vana",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vana",		"4-0034"),
@@ -108,7 +107,6 @@
 };
 VREG_CONSUMERS(L12) = {
 	REGULATOR_SUPPLY("cam_vdig",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vdig",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-0034"),
@@ -129,7 +127,6 @@
 };
 VREG_CONSUMERS(L14) = {
 	REGULATOR_SUPPLY("8921_l14",		NULL),
-	REGULATOR_SUPPLY("vreg_xoadc",		"pm8921-charger"),
 };
 VREG_CONSUMERS(L15) = {
 	REGULATOR_SUPPLY("8921_l15",		NULL),
@@ -138,7 +135,6 @@
 VREG_CONSUMERS(L16) = {
 	REGULATOR_SUPPLY("8921_l16",		NULL),
 	REGULATOR_SUPPLY("cam_vaf",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vaf",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vaf",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vaf",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vaf",		"4-0034"),
@@ -240,7 +236,6 @@
 	REGULATOR_SUPPLY("vcc_i2c",		"3-0024"),
 	REGULATOR_SUPPLY("vddp",		"0-0048"),
 	REGULATOR_SUPPLY("hdmi_lvl_tsl",	"hdmi_msm.0"),
-	REGULATOR_SUPPLY("vdd-io",		"spi0.2"),
 	REGULATOR_SUPPLY("pa_therm",		"pm8xxx-adc"),
 };
 VREG_CONSUMERS(S5) = {
@@ -272,7 +267,6 @@
 VREG_CONSUMERS(LVS5) = {
 	REGULATOR_SUPPLY("8921_lvs5",		NULL),
 	REGULATOR_SUPPLY("cam_vio",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vio",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vio",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vio",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vio",		"4-0034"),
@@ -319,7 +313,7 @@
 };
 VREG_CONSUMERS(EXT_3P3V) = {
 	REGULATOR_SUPPLY("ext_3p3v",		NULL),
-	REGULATOR_SUPPLY("vdd-phy",		"spi0.2"),
+	REGULATOR_SUPPLY("vdd_io",		"spi0.2"),
 	REGULATOR_SUPPLY("mhl_usb_hs_switch",	"msm_otg"),
 	REGULATOR_SUPPLY("lvds_vccs_3p3v",      "lvds.0"),
 	REGULATOR_SUPPLY("dsi1_vccs_3p3v",      "mipi_dsi.1"),
@@ -427,6 +421,7 @@
 };
 VREG_CONSUMERS(EXT_5V) = {
 	REGULATOR_SUPPLY("ext_5v",		NULL),
+	REGULATOR_SUPPLY("ext_ddr3",		NULL),
 	REGULATOR_SUPPLY("vbus",		"msm_ehci_host.0"),
 };
 
@@ -462,6 +457,7 @@
 };
 VREG_CONSUMERS(BOOST) = {
 	REGULATOR_SUPPLY("8917_boost",		NULL),
+	REGULATOR_SUPPLY("ext_ddr3",		NULL),
 	REGULATOR_SUPPLY("vbus",		"msm_ehci_host.0"),
 	REGULATOR_SUPPLY("hdmi_mvs",		"hdmi_msm.0"),
 };
@@ -869,14 +865,18 @@
 	RPM_LDO(L15, 0, 1, 0, 1800000, 2950000, NULL,          0,     0),
 	RPM_LDO(L16, 0, 1, 0, 2800000, 3000000, NULL,          0,     0),
 	RPM_LDO(L17, 0, 1, 0, 1800000, 3300000, NULL,          0,     0),
+#if defined(CONFIG_MACH_JACTIVE_ATT)
+	RPM_LDO(L18, 0, 0, 0, 1100000, 1100000, "8921_s4",     0,     0),
+#else
 	RPM_LDO(L18, 1, 1, 0, 1100000, 1100000, "8921_s4",     0,     0),
+#endif
 	RPM_LDO(L21, 0, 1, 0, 1800000, 1800000, NULL,          0,     0),
 	RPM_LDO(L22, 0, 1, 0, 1800000, 1800000, NULL,          0,     0),
 	RPM_LDO(L23, 0, 1, 0, 1800000, 1800000, NULL,          0,     0),
 	RPM_LDO(L24, 0, 1, 1,  750000, 1150000, "8921_s1", 10000, 10000),
 	RPM_LDO(L25, 1, 1, 0, 1250000, 1250000, "8921_s1", 10000, 10000),
 	RPM_LDO(L27, 0, 0, 0, 1100000, 1100000, "8921_s7",     0,     0),
-	RPM_LDO(L28, 0, 1, 0, 1100000, 1100000, "8921_s7",     0,     0),
+	RPM_LDO(L28, 0, 1, 0, 1100000, 1200000, "8921_s7",     0,     0),
 	RPM_LDO(L29, 0, 1, 0, 1800000, 1800000, NULL,          0,     0),
 
 	/*     ID  a_on pd ss                   supply */
diff --unified -r mach-msm/board-8064-storage.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-storage.c
--- mach-msm/board-8064-storage.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8064-storage.c	2013-12-17 17:08:05.606151173 -0800
@@ -440,7 +440,7 @@
 	.pin_data	= &mmc_slot_pin_data[SDCC1],
 	.vreg_data	= &mmc_slot_vreg_data[SDCC1],
 	.uhs_caps	= MMC_CAP_1_8V_DDR | MMC_CAP_UHS_DDR50,
-	.uhs_caps2	= MMC_CAP2_ADAPT_PACKED | MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_CACHE_CTRL,
+	.uhs_caps2	= MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_CACHE_CTRL,
 	.packed_write	= MMC_CAP2_PACKED_WR | MMC_CAP2_PACKED_WR_CONTROL,
 	.mpm_sdiowakeup_int = MSM_MPM_PIN_SDC1_DAT1,
 	.msm_bus_voting_data = &sps_to_ddr_bus_voting_data,
diff --unified -r mach-msm/board-8930.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930.c
--- mach-msm/board-8930.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -43,7 +43,6 @@
 #include <linux/memory.h>
 #include <linux/memblock.h>
 #include <linux/msm_thermal.h>
-#include <linux/input/synaptics_dsx.h>
 
 #include <linux/slimbus/slimbus.h>
 #include <linux/mfd/wcd9xxx/core.h>
@@ -75,7 +74,6 @@
 #include <mach/msm_bus_board.h>
 #include <mach/msm_memtypes.h>
 #include <mach/dma.h>
-#include <mach/msm_serial_hs.h>
 #include <mach/msm_xo.h>
 #include <mach/restart.h>
 
@@ -297,8 +295,6 @@
 {
 #if defined(CONFIG_MSM_RTB)
 	msm8930_reserve_table[MEMTYPE_EBI1].size += msm8930_rtb_pdata.size;
-	pr_info("mem_map: rtb reserved with size 0x%x in pool\n",
-			msm8930_rtb_pdata.size);
 #endif
 }
 
@@ -331,8 +327,6 @@
 	reserve_memory_for(&android_pmem_audio_pdata);
 #endif /*CONFIG_MSM_MULTIMEDIA_USE_ION*/
 	msm8930_reserve_table[MEMTYPE_EBI1].size += msm_contig_mem_size;
-	pr_info("mem_map: contig_mem reserved with size 0x%x in pool\n",
-			msm_contig_mem_size);
 #endif /*CONFIG_ANDROID_PMEM*/
 }
 
@@ -522,9 +516,6 @@
 
 	ret = memblock_remove(reserve_info->fixed_area_start,
 		reserve_info->fixed_area_size);
-	pr_info("mem_map: fixed_area reserved at 0x%lx with size 0x%lx\n",
-			reserve_info->fixed_area_start,
-			reserve_info->fixed_area_size);
 	BUG_ON(ret);
 #endif
 }
@@ -593,7 +584,7 @@
 
 			if (fixed_position != NOT_FIXED)
 				fixed_size += heap->size;
-			else if (!use_cma)
+			else
 				reserve_mem_for_ion(MEMTYPE_EBI1, heap->size);
 
 			if (fixed_position == FIXED_LOW) {
@@ -635,9 +626,6 @@
 		BUG_ON(!IS_ALIGNED(fixed_low_size + HOLE_SIZE, SECTION_SIZE));
 		ret = memblock_remove(fixed_low_start,
 				      fixed_low_size + HOLE_SIZE);
-		pr_info("mem_map: fixed_low_area reserved at 0x%lx with size \
-				0x%x\n", fixed_low_start,
-				fixed_low_size + HOLE_SIZE);
 		BUG_ON(ret);
 	}
 
@@ -648,9 +636,6 @@
 	} else {
 		BUG_ON(!IS_ALIGNED(fixed_middle_size, SECTION_SIZE));
 		ret = memblock_remove(fixed_middle_start, fixed_middle_size);
-		pr_info("mem_map: fixed_middle_area reserved at 0x%lx with \
-				size 0x%x\n", fixed_middle_start,
-				fixed_middle_size);
 		BUG_ON(ret);
 	}
 
@@ -662,9 +647,6 @@
 		/* This is the end of the fixed area so it's okay to round up */
 		fixed_high_size = ALIGN(fixed_high_size, SECTION_SIZE);
 		ret = memblock_remove(fixed_high_start, fixed_high_size);
-		pr_info("mem_map: fixed_high_area reserved at 0x%lx with size \
-				0x%x\n", fixed_high_start,
-				fixed_high_size);
 		BUG_ON(ret);
 	}
 
@@ -730,8 +712,6 @@
 	total = msm8930_cache_dump_pdata.l1_size +
 		msm8930_cache_dump_pdata.l2_size;
 	msm8930_reserve_table[MEMTYPE_EBI1].size += total;
-	pr_info("mem_map: cache_dump reserved with size 0x%x in pool\n",
-			total);
 }
 #else
 static void __init reserve_cache_dump_memory(void) { }
@@ -803,7 +783,7 @@
 	.regulator = {
 	{
 		.name = "CDC_VDD_CP",
-		.min_uV = 2200000,
+		.min_uV = 1800000,
 		.max_uV = 2200000,
 		.optimum_uA = WCD9XXX_CDC_VDDA_CP_CUR_MAX,
 	},
@@ -869,7 +849,7 @@
 	.regulator = {
 	{
 		.name = "CDC_VDD_CP",
-		.min_uV = 2200000,
+		.min_uV = 1800000,
 		.max_uV = 2200000,
 		.optimum_uA = WCD9XXX_CDC_VDDA_CP_CUR_MAX,
 	},
@@ -1314,16 +1294,6 @@
 	},
 };
 
-static struct mdm_platform_data sglte_platform_data = {
-	.mdm_version = "4.0",
-	.ramdump_delay_ms = 1000,
-	.soft_reset_inverted = 1,
-	.peripheral_platform_device = NULL,
-	.ramdump_timeout_ms = 600000,
-	.no_powerdown_after_ramdumps = 1,
-	.image_upgrade_supported = 1,
-};
-
 static struct platform_device *mdm_devices[] __initdata = {
 	&mdm_device,
 };
@@ -1473,16 +1443,6 @@
 #ifdef CONFIG_USB_MSM_OTG_72K
 static struct msm_otg_platform_data msm_otg_pdata;
 #else
-static int enable_usb_host_mode;
-static int __init usb_host_mode_with_pm8917(char *param)
-{
-	int ret;
-
-	ret = kstrtoint(param, 10, &enable_usb_host_mode);
-	return ret;
-}
-early_param("usb_host_mode_pm8917", usb_host_mode_with_pm8917);
-
 #ifdef CONFIG_MSM_BUS_SCALING
 /* Bandwidth requests (zero) if no vote placed */
 static struct msm_bus_vectors usb_init_vectors[] = {
@@ -1536,6 +1496,7 @@
 	.mode			= USB_OTG,
 	.otg_control		= OTG_PMIC_CONTROL,
 	.phy_type		= SNPS_28NM_INTEGRATED_PHY,
+	.pmic_id_irq		= PM8038_USB_ID_IN_IRQ(PM8038_IRQ_BASE),
 	.power_budget		= 750,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.bus_scale_table	= &usb_bus_scale_pdata,
@@ -1641,21 +1602,6 @@
 	0x24, 0x30, 0x0f,
 };
 
-static uint8_t spm_power_collapse_without_rpm_krait_v3[] __initdata = {
-	0x00, 0x30, 0x24, 0x30,
-	0x54, 0x10, 0x09, 0x03,
-	0x01, 0x10, 0x54, 0x30,
-	0x0C, 0x24, 0x30, 0x0f,
-};
-
-static uint8_t spm_power_collapse_with_rpm_krait_v3[] __initdata = {
-	0x00, 0x30, 0x24, 0x30,
-	0x54, 0x10, 0x09, 0x07,
-	0x01, 0x0B, 0x10, 0x54,
-	0x30, 0x0C, 0x24, 0x30,
-	0x0f,
-};
-
 static struct msm_spm_seq_entry msm_spm_boot_cpu_seq_list[] __initdata = {
 	[0] = {
 		.mode = MSM_SPM_MODE_CLOCK_GATING,
@@ -1850,6 +1796,12 @@
 
 static struct isa1200_regulator isa1200_reg_data[] = {
 	{
+		.name = "vddp",
+		.min_uV = ISA_I2C_VTG_MIN_UV,
+		.max_uV = ISA_I2C_VTG_MAX_UV,
+		.load_uA = ISA_I2C_CURR_UA,
+	},
+	{
 		.name = "vcc_i2c",
 		.min_uV = ISA_I2C_VTG_MIN_UV,
 		.max_uV = ISA_I2C_VTG_MAX_UV,
@@ -2073,38 +2025,6 @@
 	},
 };
 
-/*     Synaptics Thin Driver  */
-
-#define CLEARPAD3202_ADDR 0x20
-#define CLEARPAD3202_ATTEN_GPIO (11)
-#define CLEARPAD3202_RESET_GPIO (52)
-
-static unsigned char synaptic_rmi4_button_codes[] = {KEY_MENU, KEY_HOME,
-							KEY_BACK};
-
-static struct synaptics_rmi4_capacitance_button_map synaptic_rmi4_button_map = {
-	.nbuttons = ARRAY_SIZE(synaptic_rmi4_button_codes),
-	.map = synaptic_rmi4_button_codes,
-};
-
-static struct synaptics_rmi4_platform_data rmi4_platformdata = {
-	.irq_flags = IRQF_TRIGGER_FALLING,
-	.irq_gpio = CLEARPAD3202_ATTEN_GPIO,
-	.reset_gpio = CLEARPAD3202_RESET_GPIO,
-	.regulator_en = true,
-	.i2c_pull_up = true,
-	.capacitance_button_map = &synaptic_rmi4_button_map,
-	.fw_image_name = "PR1237913.img",
-};
-
-static struct i2c_board_info rmi4_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("synaptics_rmi4_i2c",
-		CLEARPAD3202_ADDR),
-		.platform_data = &rmi4_platformdata,
-	},
-};
-
 #define MHL_POWER_GPIO_PM8038	PM8038_GPIO_PM_TO_SYS(MHL_GPIO_PWR_EN)
 #define MHL_POWER_GPIO_PM8917	PM8917_GPIO_PM_TO_SYS(25)
 static struct msm_mhl_platform_data mhl_platform_data = {
@@ -2243,11 +2163,6 @@
 	.src_clk_rate = 24000000,
 };
 
-
-static struct msm_i2c_platform_data msm8960_i2c_qup_gsbi8_pdata = {
-	.clk_freq = 100000,
-	.src_clk_rate = 24000000,
-};
 static struct msm_i2c_platform_data msm8960_i2c_qup_gsbi9_pdata = {
 	.clk_freq = 100000,
 	.src_clk_rate = 24000000,
@@ -2388,6 +2303,7 @@
 static struct platform_device *early_common_devices[] __initdata = {
 	&msm8960_device_dmov,
 	&msm_device_smd,
+	&msm8960_device_uart_gsbi5,
 	&msm_device_uart_dm6,
 	&msm_device_saw_core0,
 	&msm_device_saw_core1,
@@ -2410,15 +2326,6 @@
 	&msm8960_device_ssbi_pmic,
 };
 
-static struct platform_device *i2c_qup_devices[] __initdata = {
-	&msm8960_device_qup_i2c_gsbi4,
-	&msm8960_device_qup_i2c_gsbi9,
-};
-
-static struct platform_device *i2c_qup_sglte_devices[] __initdata = {
-	&msm8960_device_qup_i2c_gsbi8,
-};
-
 static struct platform_device *common_devices[] __initdata = {
 	&msm_8960_q6_lpass,
 	&msm_8960_q6_mss_fw,
@@ -2428,6 +2335,8 @@
 	&msm_pil_vidc,
 	&msm8960_device_qup_spi_gsbi1,
 	&msm8960_device_qup_i2c_gsbi3,
+	&msm8960_device_qup_i2c_gsbi4,
+	&msm8960_device_qup_i2c_gsbi9,
 	&msm8960_device_qup_i2c_gsbi10,
 	&msm8960_device_qup_i2c_gsbi12,
 	&msm_slim_ctrl,
@@ -2535,40 +2444,17 @@
 	&msm_pcm_hostless,
 	&msm_multi_ch_pcm,
 	&msm_lowlatency_pcm,
-	&msm_fm_loopback,
 };
 
-#define GSBI_DUAL_MODE_CODE	0x60
-#define MSM_GSBI10_PHYS		0x1A200000
-
 static void __init msm8930_i2c_init(void)
 {
-	int minor_ver = SOCINFO_VERSION_MINOR(socinfo_get_platform_version());
-	int major_ver = SOCINFO_VERSION_MAJOR(socinfo_get_platform_version());
-	void __iomem *gsbi_mem;
-
-	if (machine_is_msm8930_evt() &&
-		(socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE)) {
-		if (major_ver == 1 && minor_ver == 0) {
-			gsbi_mem = ioremap_nocache(MSM_GSBI10_PHYS, 4);
-			writel_relaxed(GSBI_DUAL_MODE_CODE, gsbi_mem);
-			/* Ensure protocol code is written before proceeding */
-			wmb();
-			iounmap(gsbi_mem);
-			msm8960_i2c_qup_gsbi10_pdata.use_gsbi_shared_mode = 1;
-		}
-	}
-
 	msm8960_device_qup_i2c_gsbi4.dev.platform_data =
 					&msm8960_i2c_qup_gsbi4_pdata;
 
 	msm8960_device_qup_i2c_gsbi3.dev.platform_data =
 					&msm8960_i2c_qup_gsbi3_pdata;
-	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE)
-		msm8960_device_qup_i2c_gsbi8.dev.platform_data =
-					&msm8960_i2c_qup_gsbi8_pdata;
-	else
-		msm8960_device_qup_i2c_gsbi9.dev.platform_data =
+
+	msm8960_device_qup_i2c_gsbi9.dev.platform_data =
 					&msm8960_i2c_qup_gsbi9_pdata;
 
 	msm8960_device_qup_i2c_gsbi10.dev.platform_data =
@@ -2708,7 +2594,6 @@
 #define I2C_SIM  (1 << 3)
 #define I2C_FLUID (1 << 4)
 #define I2C_LIQUID (1 << 5)
-#define I2C_EVT (1 << 6)
 
 struct i2c_registry {
 	u8                     machs;
@@ -2778,18 +2663,10 @@
 };
 #endif /* CONFIG_STM_LIS3DH */
 
-#ifdef CONFIG_BMP18X_I2C
-static struct i2c_board_info __initdata bmp18x_i2c_boardinfo[] = {
-	{
-		I2C_BOARD_INFO("bmp18x", 0x77),
-	},
-};
-#endif
-
 static struct i2c_registry msm8960_i2c_devices[] __initdata = {
 #ifdef CONFIG_ISL9519_CHARGER
 	{
-		I2C_LIQUID | I2C_EVT,
+		I2C_LIQUID,
 		MSM_8930_GSBI10_QUP_I2C_BUS_ID,
 		isl_charger_i2c_info,
 		ARRAY_SIZE(isl_charger_i2c_info),
@@ -2797,7 +2674,7 @@
 #endif /* CONFIG_ISL9519_CHARGER */
 #ifdef CONFIG_INPUT_MPU3050
 	{
-		I2C_FFA | I2C_FLUID | I2C_EVT,
+		I2C_FFA | I2C_FLUID,
 		MSM_8930_GSBI12_QUP_I2C_BUS_ID,
 		mpu3050_i2c_boardinfo,
 		ARRAY_SIZE(mpu3050_i2c_boardinfo),
@@ -2810,18 +2687,12 @@
 		ARRAY_SIZE(msm_isa1200_board_info),
 	},
 	{
-		I2C_SURF | I2C_FFA | I2C_FLUID | I2C_EVT,
+		I2C_SURF | I2C_FFA | I2C_FLUID,
 		MSM_8930_GSBI3_QUP_I2C_BUS_ID,
 		mxt_device_info_8930,
 		ARRAY_SIZE(mxt_device_info_8930),
 	},
 	{
-		I2C_EVT,
-		MSM_8930_GSBI3_QUP_I2C_BUS_ID,
-		rmi4_i2c_devices,
-		ARRAY_SIZE(rmi4_i2c_devices),
-	},
-	{
 		I2C_SURF | I2C_FFA | I2C_LIQUID | I2C_FLUID,
 		MSM_8930_GSBI9_QUP_I2C_BUS_ID,
 		sii_device_info,
@@ -2829,22 +2700,12 @@
 	},
 #ifdef CONFIG_STM_LIS3DH
 	{
-		I2C_FFA | I2C_FLUID | I2C_EVT,
+		I2C_FFA | I2C_FLUID,
 		MSM_8930_GSBI12_QUP_I2C_BUS_ID,
 		lis3dh_i2c_boardinfo,
 		ARRAY_SIZE(lis3dh_i2c_boardinfo),
 	},
 #endif
-#ifdef CONFIG_BMP18X_I2C
-	{
-		I2C_FFA | I2C_FLUID | I2C_EVT,
-		MSM_8930_GSBI12_QUP_I2C_BUS_ID,
-		bmp18x_i2c_boardinfo,
-		ARRAY_SIZE(bmp18x_i2c_boardinfo),
-	},
-#endif
-
-
 };
 #endif /* CONFIG_I2C */
 
@@ -2855,17 +2716,11 @@
 	int i;
 #ifdef CONFIG_MSM_CAMERA
 	struct i2c_registry msm8930_camera_i2c_devices = {
-		I2C_SURF | I2C_FFA | I2C_FLUID | I2C_LIQUID | I2C_RUMI
-			| I2C_EVT,
+		I2C_SURF | I2C_FFA | I2C_FLUID | I2C_LIQUID | I2C_RUMI,
 		MSM_8930_GSBI4_QUP_I2C_BUS_ID,
 		msm8930_camera_board_info.board_info,
 		msm8930_camera_board_info.num_i2c_board_info,
 	};
-	if (machine_is_msm8930_evt() &&
-		(socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE)) {
-		msm8930_camera_i2c_devices.machs |= I2C_EVT;
-		msm8930_camera_i2c_devices.bus = MSM_8930_GSBI8_QUP_I2C_BUS_ID;
-	}
 #endif
 
 	/* Build the matching 'supported_machs' bitmask */
@@ -2875,8 +2730,6 @@
 		mach_mask = I2C_FLUID;
 	else if (machine_is_msm8930_mtp() || machine_is_msm8627_mtp())
 		mach_mask = I2C_FFA;
-	else if (machine_is_msm8930_evt())
-		mach_mask = I2C_EVT;
 	else
 		pr_err("unmatched machine ID in register_i2c_devices\n");
 
@@ -2896,34 +2749,11 @@
 #endif
 }
 
-/*Modify the WCD9xxx platform data to support supplies from PM8917 */
-static void __init msm8930_pm8917_wcd9xxx_pdata_fixup(
-		struct wcd9xxx_pdata *cdc_pdata)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(cdc_pdata->regulator); i++) {
-
-		if (cdc_pdata->regulator[i].name != NULL
-			&& strncmp(cdc_pdata->regulator[i].name,
-				"CDC_VDD_CP", 10) == 0) {
-			cdc_pdata->regulator[i].min_uV =
-				cdc_pdata->regulator[i].max_uV = 1800000;
-			pr_info("%s: CDC_VDD_CP forced to 1.8 volts for PM8917\n",
-				__func__);
-			return;
-		}
-	}
-}
-
 /* Modify platform data values to match requirements for PM8917. */
 static void __init msm8930_pm8917_pdata_fixup(void)
 {
 	struct acpuclk_platform_data *pdata;
 
-	msm8930_pm8917_wcd9xxx_pdata_fixup(&sitar_platform_data);
-	msm8930_pm8917_wcd9xxx_pdata_fixup(&sitar1p1_platform_data);
-
 	mhl_platform_data.gpio_mhl_power = MHL_POWER_GPIO_PM8917;
 
 	gpio_keys_8930_pdata.buttons = keys_8930_pm8917;
@@ -2943,28 +2773,6 @@
 	pdata = msm8930ab_device_acpuclk.dev.platform_data;
 	pdata->uses_pm8917 = true;
 }
-static void __init msm8930ab_update_krait_spm(void)
- {
-	int i;
-
-
-	/* Update the SPM sequences for SPC and PC */
-	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
-		int j;
-		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
-		for (j = 0; j < pdata->num_modes; j++) {
-			if (pdata->modes[j].cmd ==
-					spm_power_collapse_without_rpm)
-				pdata->modes[j].cmd =
-				spm_power_collapse_without_rpm_krait_v3;
-			else if (pdata->modes[j].cmd ==
-					spm_power_collapse_with_rpm)
-				pdata->modes[j].cmd =
-				spm_power_collapse_with_rpm_krait_v3;
-		}
-	}
-}
-
 
 static void __init msm8930ab_update_retention_spm(void)
 {
@@ -2983,24 +2791,8 @@
 	}
 }
 
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data msm_uart_dm9_pdata = {
-	.config_gpio	= 4,
-	.uart_tx_gpio	= 93,
-	.uart_rx_gpio	= 94,
-	.uart_cts_gpio	= 95,
-	.uart_rfr_gpio	= 96,
-};
-#else
-static struct msm_serial_hs_platform_data msm_uart_dm9_pdata;
-#endif
-
-
 static void __init msm8930_cdp_init(void)
 {
-	int i, reg_size = 0;
-	int minor_ver = SOCINFO_VERSION_MINOR(socinfo_get_platform_version());
-	int major_ver = SOCINFO_VERSION_MAJOR(socinfo_get_platform_version());
 	if (socinfo_get_pmic_model() == PMIC_MODEL_PM8917)
 		msm8930_pm8917_pdata_fixup();
 	if (meminfo_init(SYS_MEMORY, SZ_256M) < 0)
@@ -3017,14 +2809,6 @@
 		BUG_ON(msm_rpmrs_levels_init(&msm_rpmrs_data_pm8917));
 	}
 
-	/*
-	 * Configure LDO L17 as away on only for EVT1,
-	 * because it is the power source for a set of
-	 * MSM gpios on 8930 SGLTE EVT1.
-	 */
-	if (machine_is_msm8930_evt() && major_ver == 1 && minor_ver == 0)
-		configure_8930_sglte_regulator();
-
 	regulator_suppress_info_printing();
 	if (msm_xo_init())
 		pr_err("Failed to initialize XO votes\n");
@@ -3033,51 +2817,6 @@
 		msm_clock_init(&msm8930_pm8917_clock_init_data);
 	else
 		msm_clock_init(&msm8930_clock_init_data);
-
-	if (socinfo_get_pmic_model() == PMIC_MODEL_PM8917) {
-		/*
-		 * By default, set USB mode as USB Peripheral only due to
-		 * hardware rework requirement for USB Host Mode.
-		 * Provide pmic_id_irq number only if host mode is enable
-		 * by user assuming that hardware rework is available.
-		 */
-		if (enable_usb_host_mode) {
-			/* MPP01 IRQ number */
-			msm_otg_pdata.pmic_id_irq =
-				PM8921_MPP_IRQ(PM8917_IRQ_BASE, 1);
-		} else {
-			pr_err("Enabling USB Peripheral Only mode.\n");
-			msm_otg_pdata.mode = USB_PERIPHERAL;
-		}
-	} else {
-		msm_otg_pdata.pmic_id_irq =
-				PM8038_USB_ID_IN_IRQ(PM8038_IRQ_BASE);
-	}
-
-	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE &&
-						machine_is_msm8930_evt()) {
-#ifdef CONFIG_SERIAL_MSM_HS
-		msm_uart_dm9_pdata.wakeup_irq = gpio_to_irq(94); /* GSBI9(2) */
-		msm_device_uart_dm9.dev.platform_data = &msm_uart_dm9_pdata;
-#endif
-		platform_device_register(&msm_device_uart_dm9);
-
-		/* For 8930 SGLTE serial console */
-		if (major_ver == 1) {
-			if (minor_ver == 0)
-				/* Add UART Serial for EVT1 device */
-				platform_device_register(
-					&msm8930_device_uart_gsbi10);
-			else if (minor_ver == 1)
-				/* Add UART Serial for EVT2 device */
-				platform_device_register(
-					&msm8930_device_uart_gsbi11);
-		}
-	} else {
-		/* For 8930 Standalone serial console */
-		platform_device_register(&msm8960_device_uart_gsbi5);
-	}
-
 	msm_otg_pdata.phy_init_seq = hsusb_phy_init_seq;
 	msm8960_device_otg.dev.platform_data = &msm_otg_pdata;
 	android_usb_pdata.swfi_latency =
@@ -3099,8 +2838,6 @@
 #endif
 	msm8930_i2c_init();
 	msm8930_init_gpu();
-	if (cpu_is_msm8930ab())
-		msm8930ab_update_krait_spm();
 	if (cpu_is_krait_v3()) {
 		msm_pm_set_tz_retention_flag(0);
 		msm8930ab_update_retention_spm();
@@ -3137,28 +2874,7 @@
 	else
 		platform_add_devices(pmic_pm8917_devices,
 					ARRAY_SIZE(pmic_pm8917_devices));
-
-	if (machine_is_msm8930_evt()) {
-	        /* It is QRD Device, clock should be set appropraitely */
-		if ((SOCINFO_VERSION_MAJOR(socinfo_get_platform_version()) == 1)
-		&& (SOCINFO_VERSION_MINOR(socinfo_get_platform_version()) == 1))
-			/* For evt2a, which supports 48 MHz */
-			qcom_wcnss_pdata.has_48mhz_xo = 1;
-		else
-			/* Assuming all other versions do not support 48MHz */
-			qcom_wcnss_pdata.has_48mhz_xo = 0;
-	}
 	platform_add_devices(common_devices, ARRAY_SIZE(common_devices));
-	if (machine_is_msm8930_evt() &&
-		(socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE)) {
-		/* Removing GSBI4 and GSBI9 and initializing GSBI8
-		 * as per SGLTE platform requirement */
-		platform_add_devices(i2c_qup_sglte_devices,
-					ARRAY_SIZE(i2c_qup_sglte_devices));
-	} else {
-		platform_add_devices(i2c_qup_devices,
-					ARRAY_SIZE(i2c_qup_devices));
-	}
 	msm8930_add_vidc_device();
 	/*
 	 * TODO: When physical 8930/PM8038 hardware becomes
@@ -3178,42 +2894,13 @@
 	msm8930_init_cam();
 #endif
 	msm8930_init_mmc();
-	if (!machine_is_msm8930_evt())
-		mxt_init_vkeys_8930();
+	mxt_init_vkeys_8930();
 	register_i2c_devices();
 	msm8930_init_fb();
-
-	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE) {
-		reg_size = ARRAY_SIZE((
-			(struct wcd9xxx_pdata *)msm_slim_devices[1].
-			slim_slave->dev.platform_data)->regulator);
-
-		for (i = 0; i < reg_size; i++) {
-			if (!(((struct wcd9xxx_pdata *)msm_slim_devices[1].
-				slim_slave->dev.platform_data)->
-				regulator[i].name))
-				break;
-		}
-
-		((struct wcd9xxx_pdata *)msm_slim_devices[1].slim_slave->dev.
-			platform_data)->regulator[i].name =
-							"CDC_VDDA_A_L9_2P85V";
-		((struct wcd9xxx_pdata *)msm_slim_devices[1].slim_slave->dev.
-				platform_data)->regulator[i].min_uV = 2850000;
-		((struct wcd9xxx_pdata *)msm_slim_devices[1].slim_slave->dev.
-				platform_data)->regulator[i].max_uV = 2850000;
-		((struct wcd9xxx_pdata *)msm_slim_devices[1].slim_slave->dev.
-			platform_data)->regulator[i].optimum_uA = 300000;
-	}
 	slim_register_board_info(msm_slim_devices,
 		ARRAY_SIZE(msm_slim_devices));
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 
-	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE) {
-		mdm_sglte_device.dev.platform_data = &sglte_platform_data;
-		platform_device_register(&mdm_sglte_device);
-	}
-
 	if (PLATFORM_IS_CHARM25())
 		platform_add_devices(mdm_devices, ARRAY_SIZE(mdm_devices));
 }
@@ -3270,18 +2957,6 @@
 	.map_io = msm8930_map_io,
 	.reserve = msm8930_reserve,
 	.init_irq = msm8930_init_irq,
-	.handle_irq = gic_handle_irq,
-	.timer = &msm_timer,
-	.init_machine = msm8930_cdp_init,
-	.init_early = msm8930_allocate_memory_regions,
-	.init_very_early = msm8930_early_memory,
-	.restart = msm_restart,
-MACHINE_END
-
-MACHINE_START(MSM8930_EVT, "QRD8930 SGLTE EVT")
-	.map_io = msm8930_map_io,
-	.reserve = msm8930_reserve,
-	.init_irq = msm8930_init_irq,
 	.handle_irq = gic_handle_irq,
 	.timer = &msm_timer,
 	.init_machine = msm8930_cdp_init,
diff --unified -r mach-msm/board-8930-camera.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-camera.c
--- mach-msm/board-8930-camera.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-camera.c	2013-12-17 17:08:05.610151166 -0800
@@ -13,7 +13,6 @@
 
 #include <asm/mach-types.h>
 #include <linux/gpio.h>
-#include <mach/socinfo.h>
 #include <mach/camera.h>
 #include <mach/msm_bus_board.h>
 #include <mach/gpiomux.h>
@@ -155,16 +154,6 @@
 	},
 };
 
-static struct msm_gpiomux_config msm8930_evt_cam_configs[] = {
-	{
-		.gpio = 75,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cam_settings[2],
-			[GPIOMUX_SUSPENDED] = &cam_settings[0],
-		},
-	},
-};
-
 static struct msm_gpiomux_config msm8930_cam_2d_configs[] = {
 	{
 		.gpio = 18,
@@ -196,23 +185,6 @@
 	},
 };
 
-static struct msm_gpiomux_config msm8930_evt_cam_2d_configs[] = {
-	{
-		.gpio = 36,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cam_settings[3],
-			[GPIOMUX_SUSPENDED] = &cam_settings[8],
-		},
-	},
-	{
-		.gpio = 37,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cam_settings[3],
-			[GPIOMUX_SUSPENDED] = &cam_settings[8],
-		},
-	},
-};
-
 #define VFE_CAMIF_TIMER1_GPIO 2
 #define VFE_CAMIF_TIMER2_GPIO 3
 #define VFE_CAMIF_TIMER3_GPIO_INT 4
@@ -231,12 +203,6 @@
 	._fsrc.ext_driver_src.led_flash_en = VFE_CAMIF_TIMER2_GPIO,
 	._fsrc.ext_driver_src.flash_id = MAM_CAMERA_EXT_LED_FLASH_TPS61310,
 };
-
-static struct msm_camera_sensor_flash_src msm_flash_src_led = {
-	.flash_sr_type = MSM_CAMERA_FLASH_SRC_LED1,
-	._fsrc.ext_driver_src.led_en = VFE_CAMIF_TIMER1_GPIO,
-	._fsrc.ext_driver_src.led_flash_en = VFE_CAMIF_TIMER2_GPIO,
-};
 #endif
 
 static struct msm_bus_vectors cam_init_vectors[] = {
@@ -285,7 +251,7 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 800000000,
+		.ab  = 600000000,
 		.ib  = 2656000000UL,
 	},
 	{
@@ -327,7 +293,7 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 800000000,
+		.ab  = 600000000,
 		.ib  = 2656000000UL,
 	},
 	{
@@ -339,7 +305,7 @@
 	{
 		.src = MSM_BUS_MASTER_JPEG_ENC,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 0,
+		.ab  = 540000000,
 		.ib  = 1350000000,
 	},
 };
@@ -348,8 +314,8 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 800000000,
-		.ib  = 3522000000UL,
+		.ab  = 348192000,
+		.ib  = 617103360,
 	},
 	{
 		.src = MSM_BUS_MASTER_VPE,
@@ -360,7 +326,7 @@
 	{
 		.src = MSM_BUS_MASTER_JPEG_ENC,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 0,
+		.ab  = 540000000,
 		.ib  = 1350000000,
 	},
 };
@@ -444,34 +410,16 @@
 	{"cam_vaf", REG_LDO, 2800000, 2850000, 300000},
 };
 
-static struct camera_vreg_t msm_8930_evt_cam_vreg[] = {
-	{"cam_vdig", REG_LDO, 1500000, 1500000, 105000},
-	{"cam_vio", REG_VS, 0, 0, 0},
-	{"cam_vana", REG_LDO, 2800000, 2850000, 85600},
-	{"cam_vaf", REG_LDO, 2800000, 2850000, 300000},
-};
-
 static struct gpio msm8930_common_cam_gpio[] = {
 	{20, GPIOF_DIR_IN, "CAMIF_I2C_DATA"},
 	{21, GPIOF_DIR_IN, "CAMIF_I2C_CLK"},
 };
 
-static struct gpio msm8930_evt_common_cam_gpio[] = {
-	{36, GPIOF_DIR_IN, "CAMIF_I2C_DATA"},
-	{37, GPIOF_DIR_IN, "CAMIF_I2C_CLK"},
-};
-
 static struct gpio msm8930_front_cam_gpio[] = {
 	{4, GPIOF_DIR_IN, "CAMIF_MCLK"},
 	{76, GPIOF_DIR_OUT, "CAM_RESET"},
 };
 
-static struct gpio msm8930_evt_front_cam_gpio[] = {
-	{4, GPIOF_DIR_IN, "CAMIF_MCLK"},
-	{76, GPIOF_DIR_OUT, "CAM_RESET"},
-	{75, GPIOF_DIR_OUT, "CAM_STBY_N"},
-};
-
 static struct gpio msm8930_back_cam_gpio[] = {
 	{5, GPIOF_DIR_IN, "CAMIF_MCLK"},
 	{107, GPIOF_DIR_OUT, "CAM_RESET"},
@@ -483,13 +431,6 @@
 	{76, GPIOF_OUT_INIT_HIGH, 4000},
 };
 
-static struct msm_gpio_set_tbl msm8930_evt_front_cam_gpio_set_tbl[] = {
-	{75, GPIOF_OUT_INIT_LOW, 1000},
-	{75, GPIOF_OUT_INIT_HIGH, 4000},
-	{76, GPIOF_OUT_INIT_LOW, 1000},
-	{76, GPIOF_OUT_INIT_HIGH, 4000},
-};
-
 static struct msm_gpio_set_tbl msm8930_back_cam_gpio_set_tbl[] = {
 	{54, GPIOF_OUT_INIT_LOW, 1000},
 	{54, GPIOF_OUT_INIT_HIGH, 4000},
@@ -508,17 +449,6 @@
 	.cam_gpio_set_tbl_size = ARRAY_SIZE(msm8930_front_cam_gpio_set_tbl),
 };
 
-static struct msm_camera_gpio_conf msm_8930_evt__front_cam_gpio_conf = {
-	.cam_gpiomux_conf_tbl = msm8930_evt_cam_2d_configs,
-	.cam_gpiomux_conf_tbl_size = ARRAY_SIZE(msm8930_evt_cam_2d_configs),
-	.cam_gpio_common_tbl = msm8930_evt_common_cam_gpio,
-	.cam_gpio_common_tbl_size = ARRAY_SIZE(msm8930_evt_common_cam_gpio),
-	.cam_gpio_req_tbl = msm8930_evt_front_cam_gpio,
-	.cam_gpio_req_tbl_size = ARRAY_SIZE(msm8930_evt_front_cam_gpio),
-	.cam_gpio_set_tbl = msm8930_evt_front_cam_gpio_set_tbl,
-	.cam_gpio_set_tbl_size = ARRAY_SIZE(msm8930_evt_front_cam_gpio_set_tbl),
-};
-
 static struct msm_camera_gpio_conf msm_8930_back_cam_gpio_conf = {
 	.cam_gpiomux_conf_tbl = msm8930_cam_2d_configs,
 	.cam_gpiomux_conf_tbl_size = ARRAY_SIZE(msm8930_cam_2d_configs),
@@ -530,89 +460,10 @@
 	.cam_gpio_set_tbl_size = ARRAY_SIZE(msm8930_back_cam_gpio_set_tbl),
 };
 
-static struct msm_camera_gpio_conf msm_8930_evt_back_cam_gpio_conf = {
-	.cam_gpiomux_conf_tbl = msm8930_evt_cam_2d_configs,
-	.cam_gpiomux_conf_tbl_size = ARRAY_SIZE(msm8930_evt_cam_2d_configs),
-	.cam_gpio_common_tbl = msm8930_evt_common_cam_gpio,
-	.cam_gpio_common_tbl_size = ARRAY_SIZE(msm8930_evt_common_cam_gpio),
-	.cam_gpio_req_tbl = msm8930_back_cam_gpio,
-	.cam_gpio_req_tbl_size = ARRAY_SIZE(msm8930_back_cam_gpio),
-	.cam_gpio_set_tbl = msm8930_back_cam_gpio_set_tbl,
-	.cam_gpio_set_tbl_size = ARRAY_SIZE(msm8930_back_cam_gpio_set_tbl),
-};
-
 static struct i2c_board_info msm_act_main_cam_i2c_info = {
 	I2C_BOARD_INFO("msm_actuator", 0x11),
 };
 
-static struct msm_actuator_info msm_act_main_cam_3_info = {
-	.board_info     = &msm_act_main_cam_i2c_info,
-	.cam_name       = MSM_ACTUATOR_MAIN_CAM_3,
-	/* bus_id GSBI8 is specific to 8930 sglte evt */
-	.bus_id         = MSM_8930_GSBI8_QUP_I2C_BUS_ID,
-	.vcm_pwd        = 0,
-	.vcm_enable     = 0,
-};
-
-
-static struct msm_camera_sensor_flash_data flash_ov8825 = {
-	.flash_type = MSM_CAMERA_FLASH_LED,
-#ifdef CONFIG_MSM_CAMERA_FLASH
-	.flash_src	= &msm_flash_src_led
-#endif
-};
-
-static struct msm_camera_csi_lane_params ov8825_csi_lane_params = {
-	.csi_lane_assign = 0xE4,
-	.csi_lane_mask = 0x3,
-};
-
-static struct msm_camera_sensor_platform_info sensor_board_info_ov8825 = {
-	.mount_angle = 90,
-	.cam_vreg = msm_8930_evt_cam_vreg,
-	.num_vreg = ARRAY_SIZE(msm_8930_evt_cam_vreg),
-	.gpio_conf = &msm_8930_evt_back_cam_gpio_conf,
-	.csi_lane_params = &ov8825_csi_lane_params,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_ov8825_data = {
-	.sensor_name = "ov8825",
-	.pdata = &msm_camera_csi_device_data[0],
-	.flash_data = &flash_ov8825,
-	.sensor_platform_info = &sensor_board_info_ov8825,
-	.csi_if = 1,
-	.camera_type = BACK_CAMERA_2D,
-	.sensor_type = BAYER_SENSOR,
-	.actuator_info = &msm_act_main_cam_3_info,
-};
-
-static struct msm_camera_sensor_flash_data flash_ov9724 = {
-	.flash_type = MSM_CAMERA_FLASH_NONE
-};
-
-static struct msm_camera_csi_lane_params ov9724_csi_lane_params = {
-	.csi_lane_assign = 0xE4,
-	.csi_lane_mask = 0x1,
-};
-
-static struct msm_camera_sensor_platform_info sensor_board_info_ov9724 = {
-	.mount_angle = 90,
-	.cam_vreg = msm_8930_evt_cam_vreg,
-	.num_vreg = ARRAY_SIZE(msm_8930_evt_cam_vreg),
-	.gpio_conf = &msm_8930_evt__front_cam_gpio_conf,
-	.csi_lane_params = &ov9724_csi_lane_params,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_ov9724_data = {
-	.sensor_name = "ov9724",
-	.pdata = &msm_camera_csi_device_data[1],
-	.flash_data = &flash_ov9724,
-	.sensor_platform_info = &sensor_board_info_ov9724,
-	.csi_if = 1,
-	.camera_type = FRONT_CAMERA_2D,
-	.sensor_type = BAYER_SENSOR,
-};
-
 static struct msm_actuator_info msm_act_main_cam_0_info = {
 	.board_info     = &msm_act_main_cam_i2c_info,
 	.cam_name   = MSM_ACTUATOR_MAIN_CAM_0,
@@ -663,7 +514,7 @@
 };
 
 static struct msm_camera_sensor_platform_info sensor_board_info_mt9m114 = {
-	.mount_angle = 270,
+	.mount_angle = 90,
 	.cam_vreg = msm_8930_cam_vreg,
 	.num_vreg = ARRAY_SIZE(msm_8930_cam_vreg),
 	.gpio_conf = &msm_8930_front_cam_gpio_conf,
@@ -749,65 +600,11 @@
 	.id = 0,
 };
 
-#ifdef CONFIG_I2C
-struct i2c_board_info msm8930_camera_i2c_boardinfo[] = {
-	{
-	I2C_BOARD_INFO("imx074", 0x1A),
-	.platform_data = &msm_camera_sensor_imx074_data,
-	},
-	{
-	I2C_BOARD_INFO("ov2720", 0x6C),
-	.platform_data = &msm_camera_sensor_ov2720_data,
-	},
-	{
-	I2C_BOARD_INFO("mt9m114", 0x48),
-	.platform_data = &msm_camera_sensor_mt9m114_data,
-	},
-	{
-	I2C_BOARD_INFO("s5k3l1yx", 0x20),
-	.platform_data = &msm_camera_sensor_s5k3l1yx_data,
-	},
-	{
-	I2C_BOARD_INFO("tps61310", 0x66),
-	},
-};
-
-/* 8930 SGLTE device */
-struct i2c_board_info msm8930_evt_camera_i2c_boardinfo[] = {
-	{
-	I2C_BOARD_INFO("ov8825", 0x6c>>1),
-	.platform_data = &msm_camera_sensor_ov8825_data,
-	},
-	{
-	I2C_BOARD_INFO("ov9724", 0x20>>1),
-	.platform_data = &msm_camera_sensor_ov9724_data,
-	},
-};
-
-struct msm_camera_board_info msm8930_camera_board_info = {
-	.board_info = msm8930_camera_i2c_boardinfo,
-	.num_i2c_board_info = ARRAY_SIZE(msm8930_camera_i2c_boardinfo),
-};
-#endif
-
 void __init msm8930_init_cam(void)
 {
 	msm_gpiomux_install(msm8930_cam_common_configs,
 			ARRAY_SIZE(msm8930_cam_common_configs));
 
-	if (machine_is_msm8930_evt() &&
-			(socinfo_get_platform_subtype() ==
-			 PLATFORM_SUBTYPE_SGLTE)) {
-		msm_gpiomux_install(msm8930_evt_cam_configs,
-				ARRAY_SIZE(msm8930_evt_cam_configs));
-
-		/* Load ov8825 & ov9724 only for SGLTE device */
-		msm8930_camera_board_info.board_info =
-			msm8930_evt_camera_i2c_boardinfo;
-		msm8930_camera_board_info.num_i2c_board_info =
-			ARRAY_SIZE(msm8930_evt_camera_i2c_boardinfo);
-	}
-
 	if (machine_is_msm8930_cdp()) {
 		struct msm_camera_sensor_info *s_info;
 		s_info = &msm_camera_sensor_s5k3l1yx_data;
@@ -833,4 +630,33 @@
 	platform_device_register(&msm8960_device_vfe);
 	platform_device_register(&msm8960_device_vpe);
 }
+
+#ifdef CONFIG_I2C
+struct i2c_board_info msm8930_camera_i2c_boardinfo[] = {
+	{
+	I2C_BOARD_INFO("imx074", 0x1A),
+	.platform_data = &msm_camera_sensor_imx074_data,
+	},
+	{
+	I2C_BOARD_INFO("ov2720", 0x6C),
+	.platform_data = &msm_camera_sensor_ov2720_data,
+	},
+	{
+	I2C_BOARD_INFO("mt9m114", 0x48),
+	.platform_data = &msm_camera_sensor_mt9m114_data,
+	},
+	{
+	I2C_BOARD_INFO("s5k3l1yx", 0x20),
+	.platform_data = &msm_camera_sensor_s5k3l1yx_data,
+	},
+	{
+	I2C_BOARD_INFO("tps61310", 0x66),
+	},
+};
+
+struct msm_camera_board_info msm8930_camera_board_info = {
+	.board_info = msm8930_camera_i2c_boardinfo,
+	.num_i2c_board_info = ARRAY_SIZE(msm8930_camera_i2c_boardinfo),
+};
+#endif
 #endif
diff --unified -r mach-msm/board-8930-display.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-display.c
--- mach-msm/board-8930-display.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-display.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -58,7 +58,6 @@
 #define MIPI_VIDEO_CHIMEI_WXGA_PANEL_NAME	"mipi_video_chimei_wxga"
 #define MIPI_VIDEO_SIMULATOR_VGA_PANEL_NAME	"mipi_video_simulator_vga"
 #define MIPI_CMD_RENESAS_FWVGA_PANEL_NAME	"mipi_cmd_renesas_fwvga"
-#define MIPI_VIDEO_NT_HD_PANEL_NAME		"mipi_video_nt35590_720p"
 #define HDMI_PANEL_NAME	"hdmi_msm"
 #define TVOUT_PANEL_NAME	"tvout_msm"
 
@@ -70,17 +69,10 @@
 
 static int msm_fb_detect_panel(const char *name)
 {
-	if (machine_is_msm8930_evt()) {
-		if (!strncmp(name, MIPI_VIDEO_NT_HD_PANEL_NAME,
-			strnlen(MIPI_VIDEO_NT_HD_PANEL_NAME,
-				PANEL_NAME_MAX_LEN)))
-			return 0;
-	} else {
-		if (!strncmp(name, MIPI_CMD_NOVATEK_QHD_PANEL_NAME,
+	if (!strncmp(name, MIPI_CMD_NOVATEK_QHD_PANEL_NAME,
 			strnlen(MIPI_CMD_NOVATEK_QHD_PANEL_NAME,
 				PANEL_NAME_MAX_LEN)))
-			return 0;
-	}
+		return 0;
 
 #if !defined(CONFIG_FB_MSM_LVDS_MIPI_PANEL_DETECT) && \
 	!defined(CONFIG_FB_MSM_MIPI_PANEL_DETECT)
@@ -132,15 +124,6 @@
 };
 
 static bool dsi_power_on;
-static struct mipi_dsi_panel_platform_data novatek_pdata;
-static void pm8917_gpio_set_backlight(int bl_level)
-{
-	int gpio24 = PM8917_GPIO_PM_TO_SYS(24);
-	if (bl_level > 0)
-		gpio_set_value_cansleep(gpio24, 1);
-	else
-		gpio_set_value_cansleep(gpio24, 0);
-}
 
 /*
  * TODO: When physical 8930/PM8038 hardware becomes
@@ -203,29 +186,18 @@
 			gpio_free(DISP_RST_GPIO);
 			return -ENODEV;
 		}
-		if (machine_is_msm8930_evt()) {
-			rc = gpio_direction_output(DISP_RST_GPIO, 1);
-			if (rc) {
-				pr_err("gpio_direction_output failed for %d gpio rc=%d\n",
-						DISP_RST_GPIO, rc);
-				return -ENODEV;
-			}
-		}
-
-		if (!machine_is_msm8930_evt()) {
-			rc = gpio_request(DISP_3D_2D_MODE, "disp_3d_2d");
-			if (rc) {
-				pr_err("request gpio DISP_3D_2D_MODE failed, rc=%d\n",
+		rc = gpio_request(DISP_3D_2D_MODE, "disp_3d_2d");
+		if (rc) {
+			pr_err("request gpio DISP_3D_2D_MODE failed, rc=%d\n",
 				 rc);
-				gpio_free(DISP_3D_2D_MODE);
-				return -ENODEV;
-			}
-			rc = gpio_direction_output(DISP_3D_2D_MODE, 0);
-			if (rc) {
-				pr_err("gpio_direction_output failed for %d gpio rc=%d\n",
-						DISP_3D_2D_MODE, rc);
-				return -ENODEV;
-			}
+			gpio_free(DISP_3D_2D_MODE);
+			return -ENODEV;
+		}
+		rc = gpio_direction_output(DISP_3D_2D_MODE, 0);
+		if (rc) {
+			pr_err("gpio_direction_output failed for %d gpio rc=%d\n",
+			DISP_3D_2D_MODE, rc);
+			return -ENODEV;
 		}
 		if (socinfo_get_pmic_model() == PMIC_MODEL_PM8917) {
 			rc = gpio_request(gpio24, "disp_bl");
@@ -234,13 +206,9 @@
 					rc);
 				return -ENODEV;
 			}
-			gpio_set_value_cansleep(gpio24, 0);
-			novatek_pdata.gpio_set_backlight =
-				pm8917_gpio_set_backlight;
 		}
 		dsi_power_on = true;
 	}
-
 	if (on) {
 		rc = regulator_set_optimum_mode(reg_l8, 100000);
 		if (rc < 0) {
@@ -278,9 +246,10 @@
 		gpio_set_value(DISP_RST_GPIO, 0);
 		usleep(20);
 		gpio_set_value(DISP_RST_GPIO, 1);
-		if (!machine_is_msm8930_evt())
-			gpio_set_value(DISP_3D_2D_MODE, 1);
+		gpio_set_value(DISP_3D_2D_MODE, 1);
 		usleep(20);
+		if (socinfo_get_pmic_model() == PMIC_MODEL_PM8917)
+			gpio_set_value_cansleep(gpio24, 1);
 	} else {
 
 		gpio_set_value(DISP_RST_GPIO, 0);
@@ -315,9 +284,10 @@
 			pr_err("set_optimum_mode l2 failed, rc=%d\n", rc);
 			return -EINVAL;
 		}
-		if (!machine_is_msm8930_evt())
-			gpio_set_value(DISP_3D_2D_MODE, 0);
+		gpio_set_value(DISP_3D_2D_MODE, 0);
 		usleep(20);
+		if (socinfo_get_pmic_model() == PMIC_MODEL_PM8917)
+			gpio_set_value_cansleep(gpio24, 0);
 	}
 	return 0;
 }
@@ -462,7 +432,7 @@
 	.mdp_max_clk = 200000000,
 	.mdp_max_bw = 2000000000,
 	.mdp_bw_ab_factor = 115,
-	.mdp_bw_ib_factor = 150,
+	.mdp_bw_ib_factor = 125,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.mdp_bus_scale_table = &mdp_bus_scale_pdata,
 #endif
@@ -484,9 +454,6 @@
 		mdp_pdata.ov0_wb_size;
 	reserve_table[mdp_pdata.mem_hid].size +=
 		mdp_pdata.ov1_wb_size;
-
-	pr_info("mem_map: mdp reserved with size 0x%lx in pool\n",
-			mdp_pdata.ov0_wb_size + mdp_pdata.ov1_wb_size);
 #endif
 }
 
@@ -505,12 +472,6 @@
 	}
 };
 
-static struct platform_device mipi_dsi_NT35590_panel_device = {
-	.name = "mipi_NT35590",
-	.id = 0,
-	/* todo: add any platform data */
-};
-
 #define FPGA_3D_GPIO_CONFIG_ADDR	0xB5
 
 static struct mipi_dsi_phy_ctrl dsi_novatek_cmd_mode_phy_db = {
@@ -525,7 +486,7 @@
 	/* pll control */
 	{0x0, 0xe, 0x30, 0xda, 0x00, 0x10, 0x0f, 0x61,
 	0x40, 0x07, 0x03,
-	0x00, 0x1a, 0x00, 0x00, 0x02, 0x0e, 0x01, 0x00, 0x02},
+	0x00, 0x1a, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x02},
 };
 
 static struct mipi_dsi_panel_platform_data novatek_pdata = {
@@ -590,8 +551,6 @@
 	.resource = hdmi_msm_resources,
 	.dev.platform_data = &hdmi_msm_data,
 };
-#else
-static int hdmi_panel_power(int on) { return 0; }
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
 
 #ifdef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
@@ -657,6 +616,19 @@
 	.bus_scale_table = &dtv_bus_scale_pdata,
 	.lcdc_power_save = hdmi_panel_power,
 };
+
+static int hdmi_panel_power(int on)
+{
+	int rc;
+
+	pr_debug("%s: HDMI Core: %s\n", __func__, (on ? "ON" : "OFF"));
+	rc = hdmi_core_power(on, 1);
+	if (rc)
+		rc = hdmi_cec_power(on);
+
+	pr_debug("%s: HDMI Core: %s Success\n", __func__, (on ? "ON" : "OFF"));
+	return rc;
+}
 #endif
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
@@ -847,13 +819,13 @@
 	return cpu_is_msm8930ab() ? true : false ;
 }
 
+
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
 
 void __init msm8930_init_fb(void)
 {
 	platform_device_register(&msm_fb_device);
 
-	platform_device_register(&mipi_dsi_NT35590_panel_device);
 #ifdef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
 	platform_device_register(&wfd_panel_device);
 	platform_device_register(&wfd_device);
diff --unified -r mach-msm/board-8930-gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-gpiomux.c
--- mach-msm/board-8930-gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-gpiomux.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,51 +18,6 @@
 #include "devices.h"
 #include "board-8930.h"
 
-/* GSBI10 UART configurations */
-static struct gpiomux_setting gsbi10_uart_cfg = {
-	.func = GPIOMUX_FUNC_2,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct msm_gpiomux_config msm8930_gsbi10_uart_configs[] __initdata = {
-	{
-		.gpio	= 71,	/* GSBI10 UART TX */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi10_uart_cfg,
-		},
-	},
-	{
-		.gpio	= 72, /* GSBI10 UART RX */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi10_uart_cfg,
-		},
-	},
-};
-
-/* GSBI11 UART configurations */
-static struct gpiomux_setting gsbi11_uart_cfg = {
-	.func = GPIOMUX_FUNC_1,
-	.drv = GPIOMUX_DRV_10MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct msm_gpiomux_config msm8930_gsbi11_uart_configs[] __initdata = {
-	{
-		.gpio	= 38,   /* GSBI11 UART TX */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi11_uart_cfg,
-		},
-	},
-	{
-		.gpio	= 39, /* GSBI11 UART RX */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi11_uart_cfg,
-		},
-	},
-};
-
-
 /* The SPI configurations apply to GSBI 1*/
 static struct gpiomux_setting spi_active = {
 	.func = GPIOMUX_FUNC_1,
@@ -88,18 +43,6 @@
 	.pull = GPIOMUX_PULL_NONE,
 };
 
-static struct gpiomux_setting gsbi9_active_cfg = {
-	.func = GPIOMUX_FUNC_2,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct gpiomux_setting gsbi9_suspended_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
 static struct gpiomux_setting gsbi5 = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_8MA,
@@ -124,21 +67,6 @@
 	.pull = GPIOMUX_PULL_NONE,
 };
 
-static struct gpiomux_setting external_vfr[] = {
-	/* Suspended state */
-	{
-		.func = GPIOMUX_FUNC_3,
-		.drv = GPIOMUX_DRV_2MA,
-		.pull = GPIOMUX_PULL_KEEPER,
-	},
-	/* Active state */
-	{
-		.func = GPIOMUX_FUNC_3,
-		.drv = GPIOMUX_DRV_2MA,
-		.pull = GPIOMUX_PULL_KEEPER,
-	},
-};
-
 static struct gpiomux_setting cdc_mclk = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_2MA,
@@ -172,12 +100,6 @@
 	.pull = GPIOMUX_PULL_NONE,
 };
 
-static struct gpiomux_setting audio_useuro_switch = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
 #if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
 static struct gpiomux_setting gpio_eth_config = {
 	.pull = GPIOMUX_PULL_NONE,
@@ -239,31 +161,6 @@
 	.drv = GPIOMUX_DRV_2MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
-
-static struct gpiomux_setting synaptic_rmi4_resout_sus_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_6MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct gpiomux_setting synaptic_rmi4_resout_act_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_6MA,
-	.pull = GPIOMUX_PULL_UP,
-};
-
-static struct gpiomux_setting synaptic_rmi4_attn_act_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_UP,
-};
-
-static struct gpiomux_setting synaptic_rmi4_attn_sus_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
 #ifdef MSM8930_PHASE_2
 static struct gpiomux_setting hsusb_sus_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
@@ -384,12 +281,6 @@
 	.dir = GPIOMUX_OUT_LOW,
 };
 
-static struct gpiomux_setting usbsw_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
 #if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
 static struct msm_gpiomux_config msm8960_ethernet_configs[] = {
 	{
@@ -500,78 +391,6 @@
 	},
 };
 
-static struct msm_gpiomux_config msm8930_sglte_gsbi_configs[] __initdata = {
-	/* Add the I2C/SPI GPIOs Here */
-	{
-		.gpio      = 6,		/* GSBI1 TX */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &spi_suspended_config,
-			[GPIOMUX_ACTIVE] = &spi_active,
-		},
-	},
-	{
-		.gpio      = 7,		/* GSBI1 RX */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &spi_suspended_config,
-			[GPIOMUX_ACTIVE] = &spi_active,
-		},
-	},
-	{
-		.gpio      = 8,		/* GSBI1 CTS_N */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &spi_suspended_config,
-			[GPIOMUX_ACTIVE] = &spi_active,
-		},
-	},
-	{
-		.gpio      = 9,		/* GSBI1 RFR_N */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &spi_suspended_config,
-			[GPIOMUX_ACTIVE] = &spi_active,
-		},
-	},
-	{
-		.gpio      = 16,	/* GSBI3 I2C QUP SDA */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi3_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi3_active_cfg,
-		},
-	},
-	{
-		.gpio      = 17,	/* GSBI3 I2C QUP SCL */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi3_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi3_active_cfg,
-		},
-	},
-	{
-		.gpio      = 44,	/* GSBI12 I2C QUP SDA */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi12,
-		},
-	},
-	{
-		.gpio      = 45,	/* GSBI12 I2C QUP SCL */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi12,
-		},
-	},
-	{
-		.gpio      = 73,	/* GSBI10 I2C QUP SDA */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi10,
-		},
-	},
-	{
-		.gpio      = 74,	/* GSBI10 I2C QUP SCL */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi10,
-		},
-	},
-
-};
-
-
 static struct msm_gpiomux_config msm8960_slimbus_config[] __initdata = {
 	{
 		.gpio	= 60,		/* slimbus data */
@@ -603,27 +422,6 @@
 			[GPIOMUX_SUSPENDED] = &audio_mbhc,
 		},
 	},
-	{
-		.gpio = 80,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &audio_useuro_switch,
-		},
-	},
-};
-
-static struct msm_gpiomux_config msm8960_audio_mbhc_configs_sglte[] __initdata = {
-	{
-		.gpio = 50,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &audio_mbhc,
-		},
-	},
-	{
-		.gpio = 66,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &audio_useuro_switch,
-		},
-	},
 };
 
 static struct msm_gpiomux_config msm8960_audio_spkr_configs[] __initdata = {
@@ -635,6 +433,7 @@
 	},
 };
 
+
 static struct msm_gpiomux_config msm8960_audio_auxpcm_configs[] __initdata = {
 	{
 		.gpio = 63,
@@ -728,23 +527,6 @@
 	},
 };
 
-static struct msm_gpiomux_config msm8960_synaptic_rmi4_configs[] __initdata = {
-	{       /* TS INTERRUPT */
-		.gpio = 11,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &synaptic_rmi4_attn_act_cfg,
-			[GPIOMUX_SUSPENDED] = &synaptic_rmi4_attn_sus_cfg,
-		},
-	},
-	{       /* TS RESOUT */
-		.gpio = 52,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &synaptic_rmi4_resout_act_cfg,
-			[GPIOMUX_SUSPENDED] = &synaptic_rmi4_resout_sus_cfg,
-		},
-	},
-};
-
 static struct msm_gpiomux_config hap_lvl_shft_config[] __initdata = {
 	{
 		.gpio = 47,
@@ -913,16 +695,6 @@
 	},
 };
 
-static struct msm_gpiomux_config msm8930_sd_det_config_evt[] __initdata = {
-	{
-		.gpio = 90,	/* SD Card Detect Line */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &sd_det_line,
-			[GPIOMUX_ACTIVE] = &sd_det_line,
-		},
-	},
-};
-
 static struct gpiomux_setting gyro_int_line = {
 	.func = GPIOMUX_FUNC_GPIO,
 	.drv = GPIOMUX_DRV_2MA,
@@ -948,159 +720,6 @@
 	}
 };
 
-static struct msm_gpiomux_config sglte_8930_configs[] __initdata = {
-	/* AP2MDM_STATUS */
-	{
-		.gpio = 77,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 24,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 40,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-	/* AP2MDM_ERRFATAL */
-	{
-		.gpio = 80,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* AP2MDM_KPDPWR_N */
-	{
-		.gpio = 79,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_kpdpwr_n_cfg,
-		}
-	},
-	/* AP2MDM_PMIC_PWR_EN */
-	{
-		.gpio = 22,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_kpdpwr_n_cfg,
-		}
-	},
-	/* AP2MDM_SOFT_RESET */
-	{
-		.gpio = 78,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* USB_SW */
-	{
-		.gpio = 25,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &usbsw_cfg,
-		}
-	}
-};
-
-static struct msm_gpiomux_config msm8930_fusion_gsbi_configs[] = {
-	{
-		.gpio = 93,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi9_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi9_active_cfg,
-		}
-	},
-	{
-		.gpio = 94,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi9_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi9_active_cfg,
-		}
-	},
-	{
-		.gpio = 95,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi9_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi9_active_cfg,
-		}
-	},
-	{
-		.gpio = 96,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi9_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi9_active_cfg,
-		}
-	},
-};
-
-static struct msm_gpiomux_config msm8930_external_vfr_configs[] __initdata = {
-	{
-		.gpio      = 23,        /* EXTERNAL VFR */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &external_vfr[0],
-			[GPIOMUX_ACTIVE] = &external_vfr[1],
-		},
-	},
-};
-
-int __init sglte8930_init_gpiomux(void)
-{
-	int minor_ver = SOCINFO_VERSION_MINOR(socinfo_get_platform_version());
-	int major_ver = SOCINFO_VERSION_MAJOR(socinfo_get_platform_version());
-
-	/* For 8960 Fusion 2.2 Primary IPC */
-	msm_gpiomux_install(msm8930_fusion_gsbi_configs,
-			ARRAY_SIZE(msm8930_fusion_gsbi_configs));
-	/* For 8930 SGLTE Serial Console */
-	if (machine_is_msm8930_evt() && major_ver == 1) {
-		if (minor_ver == 0)
-			msm_gpiomux_install(msm8930_gsbi10_uart_configs,
-				ARRAY_SIZE(msm8930_gsbi10_uart_configs));
-		else if (minor_ver == 1)
-			msm_gpiomux_install(msm8930_gsbi11_uart_configs,
-				ARRAY_SIZE(msm8930_gsbi11_uart_configs));
-	}
-
-	/* For SGLTE 8960 Fusion External VFR */
-	msm_gpiomux_install(msm8930_external_vfr_configs,
-			ARRAY_SIZE(msm8930_external_vfr_configs));
-	msm_gpiomux_install(sglte_8930_configs,
-			ARRAY_SIZE(sglte_8930_configs));
-
-	msm_gpiomux_install(msm8930_sglte_gsbi_configs,
-			ARRAY_SIZE(msm8930_sglte_gsbi_configs));
-
-	msm_gpiomux_install(msm8960_slimbus_config,
-			ARRAY_SIZE(msm8960_slimbus_config));
-
-	msm_gpiomux_install(msm8960_audio_codec_configs,
-			ARRAY_SIZE(msm8960_audio_codec_configs));
-
-	msm_gpiomux_install(wcnss_5wire_interface,
-			ARRAY_SIZE(wcnss_5wire_interface));
-
-	msm_gpiomux_install(msm8960_mdp_vsync_configs,
-			ARRAY_SIZE(msm8960_mdp_vsync_configs));
-
-	msm_gpiomux_install(msm_sitar_config, ARRAY_SIZE(msm_sitar_config));
-
-	msm_gpiomux_install(msm8960_synaptic_rmi4_configs,
-			ARRAY_SIZE(msm8960_synaptic_rmi4_configs));
-
-	msm_gpiomux_install(msm8930_sd_det_config_evt,
-			ARRAY_SIZE(msm8930_sd_det_config_evt));
-
-	msm_gpiomux_install(msm8960_audio_mbhc_configs_sglte,
-			ARRAY_SIZE(msm8960_audio_mbhc_configs_sglte));
-
-	return 0;
-}
-
 int __init msm8930_init_gpiomux(void)
 {
 	int rc = msm_gpiomux_init(NR_GPIO_IRQS);
@@ -1109,9 +728,6 @@
 		return rc;
 	}
 
-	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE)
-		return sglte8930_init_gpiomux();
-
 #if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
 	msm_gpiomux_install(msm8960_ethernet_configs,
 			ARRAY_SIZE(msm8960_ethernet_configs));
diff --unified -r mach-msm/board-8930-gpu.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-gpu.c
--- mach-msm/board-8930-gpu.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-gpu.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -88,6 +88,12 @@
 	{
 		.name = KGSL_3D0_REG_MEMORY,
 		.start = 0x04300000, /* GFX3D address */
+		.end = 0x0430ffff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name = KGSL_3D0_SHADER_MEMORY,
+		.start = 0x04310000,
 		.end = 0x0431ffff,
 		.flags = IORESOURCE_MEM,
 	},
@@ -140,7 +146,7 @@
 	.set_grp_async = NULL,
 	.idle_timeout = HZ/12,
 	.nap_allowed = true,
-	.strtstp_sleepwake = false,
+	.strtstp_sleepwake = true,
 	.clk_map = KGSL_CLK_CORE | KGSL_CLK_IFACE | KGSL_CLK_MEM_IFACE,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.bus_scale_table = &grp3d_bus_scale_pdata,
diff --unified -r mach-msm/board-8930.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930.h
--- mach-msm/board-8930.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930.h	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -150,7 +150,6 @@
 void msm8930_pm8917_gpio_mpp_init(void);
 void msm8930_mdp_writeback(struct memtype_reserve *reserve_table);
 void __init msm8930_init_gpu(void);
-void __init configure_8930_sglte_regulator(void);
 
 #define PLATFORM_IS_CHARM25() \
 	(machine_is_msm8930_cdp() && \
@@ -159,7 +158,6 @@
 
 #define MSM_8930_GSBI3_QUP_I2C_BUS_ID 3
 #define MSM_8930_GSBI4_QUP_I2C_BUS_ID 4
-#define MSM_8930_GSBI8_QUP_I2C_BUS_ID 8
 #define MSM_8930_GSBI9_QUP_I2C_BUS_ID 0
 #define MSM_8930_GSBI10_QUP_I2C_BUS_ID 10
 #define MSM_8930_GSBI12_QUP_I2C_BUS_ID 12
diff --unified -r mach-msm/board-8930-pmic.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-pmic.c
--- mach-msm/board-8930-pmic.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-pmic.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -180,10 +180,6 @@
 
 /* Initial PM8917 MPP configurations */
 static struct pm8xxx_mpp_init pm8917_mpps[] __initdata = {
-	PM8917_MPP_INIT(PM8XXX_AMUX_MPP_3, A_INPUT,
-				PM8XXX_MPP_AIN_AMUX_CH8, DIN_TO_INT),
-	/* Configure MPP01 for USB ID detection */
-	PM8917_MPP_INIT(1, D_INPUT, PM8921_MPP_DIG_LEVEL_S4, DIN_TO_INT),
 };
 
 void __init msm8930_pm8038_gpio_mpp_init(void)
@@ -317,17 +313,16 @@
 #define MAX_VOLTAGE_MV		4200
 #define CHG_TERM_MA		100
 static struct pm8921_charger_platform_data pm8921_chg_pdata __devinitdata = {
+	.safety_time		= 180,
 	.update_time		= 60000,
 	.max_voltage		= MAX_VOLTAGE_MV,
 	.min_voltage		= 3200,
 	.uvd_thresh_voltage	= 4050,
-	.alarm_low_mv		= 3400,
-	.alarm_high_mv		= 4000,
-	.resume_voltage_delta	= 60,
-	.resume_charge_percent	= 99,
+	.alarm_voltage          = 3400,
+	.resume_voltage_delta	= 100,
 	.term_current		= CHG_TERM_MA,
 	.cool_temp		= 10,
-	.warm_temp		= 45,
+	.warm_temp		= 40,
 	.temp_check_period	= 1,
 	.max_bat_chg_current	= 1100,
 	.cool_bat_chg_current	= 350,
@@ -340,12 +335,6 @@
 	.rconn_mohm		= 18,
 };
 
-static struct pm8xxx_vibrator_platform_data pm8038_vib_pdata = {
-	.initial_vibrate_ms = 500,
-	.level_mV = 3000,
-	.max_timeout_ms = 15000,
-};
-
 #define PM8038_WLED_MAX_CURRENT		25
 #define PM8XXX_LED_PWM_PERIOD		1000
 #define PM8XXX_LED_PWM_DUTY_MS		20
@@ -378,7 +367,7 @@
 	.cs_out_en = true,
 	.ctrl_delay_us = 0,
 	.op_fdbck = true,
-	.ovp_val = WLED_OVP_35V,
+	.ovp_val = WLED_OVP_32V,
 	.boost_curr_lim = WLED_CURR_LIMIT_525mA,
 	.num_strings = 1,
 };
@@ -445,7 +434,7 @@
 };
 
 static struct pm8xxx_ccadc_platform_data pm8xxx_ccadc_pdata = {
-	.r_sense_uohm		= 10000,
+	.r_sense		= 10,
 	.calib_delay_ms		= 600000,
 };
 
@@ -461,7 +450,7 @@
 
 static struct pm8xxx_spk_platform_data pm8xxx_spk_pdata = {
 	.spk_add_enable		= false,
-	.cd_ng_threshold	= 0x0,
+	.cd_ng_threshold	= 0x6,
 	.cd_nf_preamp_bias	= 0x1,
 	.cd_ng_hold		= 0x6,
 	.cd_ng_max_atten	= 0x0,
@@ -473,24 +462,13 @@
 
 static struct pm8921_bms_platform_data pm8921_bms_pdata __devinitdata = {
 	.battery_type			= BATT_UNKNOWN,
-	.r_sense_uohm			= 10000,
+	.r_sense			= 10,
 	.v_cutoff			= 3400,
 	.max_voltage_uv			= MAX_VOLTAGE_MV * 1000,
 	.shutdown_soc_valid_limit	= 20,
 	.adjust_soc_low_threshold	= 25,
 	.chg_term_ua			= CHG_TERM_MA * 1000,
 	.rconn_mohm			= 18,
-	.normal_voltage_calc_ms		= 20000,
-	.low_voltage_calc_ms		= 1000,
-	.alarm_low_mv			= 3400,
-	.alarm_high_mv			= 4000,
-	.high_ocv_correction_limit_uv	= 50,
-	.low_ocv_correction_limit_uv	= 100,
-	.hold_soc_est			= 3,
-	.enable_fcc_learning		= 1,
-	.min_fcc_learning_soc		= 20,
-	.min_fcc_ocv_pc			= 30,
-	.min_fcc_learning_samples	= 5,
 };
 
 static struct pm8038_platform_data pm8038_platform_data __devinitdata = {
@@ -596,16 +574,10 @@
 					&msm8930_ssbi_pm8038_pdata;
 		pm8038_platform_data.num_regulators
 			= msm8930_pm8038_regulator_pdata_len;
-		if (machine_is_msm8930_mtp() || machine_is_msm8930_evt())
+		if (machine_is_msm8930_mtp())
 			pm8921_bms_pdata.battery_type = BATT_PALLADIUM;
 		else if (machine_is_msm8930_cdp())
 			pm8921_chg_pdata.has_dc_supply = true;
-		if (machine_is_msm8930_evt()) {
-			pm8038_platform_data.vibrator_pdata =
-				&pm8038_vib_pdata;
-			pm8038_platform_data.leds_pdata->configs[0]
-					.wled_cfg->comp_res_val = 80;
-		}
 	} else {
 		/* PM8917 configuration */
 		pmic_reset_irq = PM8917_IRQ_BASE + PM8921_RESOUT_IRQ;
@@ -618,7 +590,4 @@
 		else if (machine_is_msm8930_cdp())
 			pm8921_chg_pdata.has_dc_supply = true;
 	}
-
-	if (!machine_is_msm8930_mtp() && !machine_is_msm8930_evt())
-		pm8921_chg_pdata.battery_less_hardware = 1;
 }
diff --unified -r mach-msm/board-8930-regulator-pm8038.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-regulator-pm8038.c
--- mach-msm/board-8930-regulator-pm8038.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-regulator-pm8038.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -68,7 +68,6 @@
 	REGULATOR_SUPPLY("8038_l9",		NULL),
 	REGULATOR_SUPPLY("vdd_ana",		"3-004a"),
 	REGULATOR_SUPPLY("vdd",			"3-0024"),
-	REGULATOR_SUPPLY("vdd",			"3-0020"),
 	REGULATOR_SUPPLY("cam_vana",		"4-001a"),
 	REGULATOR_SUPPLY("cam_vana",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vana",		"4-0048"),
@@ -77,22 +76,8 @@
 	REGULATOR_SUPPLY("cam_vaf",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vana",            "4-0020"),
 	REGULATOR_SUPPLY("cam_vaf",             "4-0020"),
-/* Regulators for 8930 QRD SGLTE EVT */
-	REGULATOR_SUPPLY("cam_vana",		"8-001a"),
-	REGULATOR_SUPPLY("cam_vana",		"8-006c"),
-	REGULATOR_SUPPLY("cam_vana",		"8-0048"),
-	REGULATOR_SUPPLY("cam_vana",		"8-0020"),
-	REGULATOR_SUPPLY("cam_vana",		"8-0036"),
-	REGULATOR_SUPPLY("cam_vana",		"8-0010"),
-	REGULATOR_SUPPLY("cam_vaf",		"8-001a"),
-	REGULATOR_SUPPLY("cam_vaf",		"8-006c"),
-	REGULATOR_SUPPLY("cam_vaf",		"8-0048"),
-	REGULATOR_SUPPLY("cam_vaf",		"8-0020"),
-	REGULATOR_SUPPLY("cam_vaf",		"8-0036"),
-	REGULATOR_SUPPLY("cam_vaf",		"8-0010"),
 	REGULATOR_SUPPLY("vdd",			"12-0018"),
 	REGULATOR_SUPPLY("vdd",			"12-0068"),
-	REGULATOR_SUPPLY("CDC_VDDA_A_L9_2P85V",	"sitar1p1-slim"),
 };
 VREG_CONSUMERS(L10) = {
 	REGULATOR_SUPPLY("8038_l10",		NULL),
@@ -110,7 +95,7 @@
 	REGULATOR_SUPPLY("VDDIO_CDC",		"sitar1p1-slim"),
 	REGULATOR_SUPPLY("CDC_VDDA_TX",		"sitar1p1-slim"),
 	REGULATOR_SUPPLY("CDC_VDDA_RX",		"sitar1p1-slim"),
-	REGULATOR_SUPPLY("vcc_i2c",		"0-0048"),
+	REGULATOR_SUPPLY("vddp",		"0-0048"),
 	REGULATOR_SUPPLY("mhl_iovcc18",		"0-0039"),
 };
 VREG_CONSUMERS(L12) = {
@@ -118,14 +103,7 @@
 	REGULATOR_SUPPLY("cam_vdig",		"4-001a"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-0048"),
-	REGULATOR_SUPPLY("cam_vdig",		"4-0020"),
-/* Regulators for 8930 QRD SGLTE EVT */
-	REGULATOR_SUPPLY("cam_vdig",		"8-001a"),
-	REGULATOR_SUPPLY("cam_vdig",		"8-006c"),
-	REGULATOR_SUPPLY("cam_vdig",		"8-0048"),
-	REGULATOR_SUPPLY("cam_vdig",		"8-0020"),
-	REGULATOR_SUPPLY("cam_vdig",		"8-0036"),
-	REGULATOR_SUPPLY("cam_vdig",		"8-0010"),
+	REGULATOR_SUPPLY("cam_vdig",            "4-0020"),
 };
 VREG_CONSUMERS(L13) = {
 	REGULATOR_SUPPLY("8038_l13",		NULL),
@@ -224,20 +202,13 @@
 	REGULATOR_SUPPLY("cam_vio",		"4-001a"),
 	REGULATOR_SUPPLY("cam_vio",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vio",		"4-0048"),
-	REGULATOR_SUPPLY("cam_vio",		"4-0020"),
-/* Regulators for 8930 QRD SGLTE EVT */
-	REGULATOR_SUPPLY("cam_vio",		"8-001a"),
-	REGULATOR_SUPPLY("cam_vio",		"8-006c"),
-	REGULATOR_SUPPLY("cam_vio",		"8-0048"),
-	REGULATOR_SUPPLY("cam_vio",		"8-0020"),
-	REGULATOR_SUPPLY("cam_vio",		"8-0036"),
-	REGULATOR_SUPPLY("cam_vio",		"8-0010"),
+	REGULATOR_SUPPLY("cam_vio",             "4-0020"),
 };
 VREG_CONSUMERS(LVS2) = {
 	REGULATOR_SUPPLY("8038_lvs2",		NULL),
 	REGULATOR_SUPPLY("vcc_i2c",		"3-004a"),
 	REGULATOR_SUPPLY("vcc_i2c",		"3-0024"),
-	REGULATOR_SUPPLY("vcc_i2c",		"3-0020"),
+	REGULATOR_SUPPLY("vcc_i2c",		"0-0048"),
 	REGULATOR_SUPPLY("vddio",		"12-0018"),
 	REGULATOR_SUPPLY("vlogic",		"12-0068"),
 };
@@ -535,7 +506,7 @@
 	RPM_LDO(L9,	 0, 1, 0, 2850000, 2850000, NULL,      0, 0),
 	RPM_LDO(L10,	 0, 1, 0, 2900000, 2900000, NULL,      0, 0),
 	RPM_LDO(L11,	 1, 1, 0, 1800000, 1800000, "8038_s4", 10000, 10000),
-	RPM_LDO(L12,	 0, 1, 0, 1200000, 1500000, "8038_s2", 0, 0),
+	RPM_LDO(L12,	 0, 1, 0, 1200000, 1200000, "8038_s2", 0, 0),
 	RPM_LDO(L13,	 0, 0, 0, 2220000, 2220000, NULL,      0, 0),
 	RPM_LDO(L14,	 0, 1, 0, 1800000, 1800000, NULL,      0, 0),
 	RPM_LDO(L15,	 0, 1, 0, 1800000, 2950000, NULL,      0, 0),
@@ -614,19 +585,3 @@
 	.consumer_map		= msm_rpm_regulator_consumer_mapping,
 	.consumer_map_len = ARRAY_SIZE(msm_rpm_regulator_consumer_mapping),
 };
-
-void __init configure_8930_sglte_regulator(void)
-{
-	int i;
-	struct rpm_regulator_init_data *rpm_data;
-
-	for (i = 0; i < ARRAY_SIZE(msm8930_rpm_regulator_init_data); i++) {
-		rpm_data = &msm8930_rpm_regulator_init_data[i];
-		if (rpm_data->id == RPM_VREG_ID_PM8038_L17) {
-			rpm_data->init_data.constraints.always_on = 1;
-			rpm_data->system_uA = 10000;
-			rpm_data->peak_uA = 10000;
-			break;
-		}
-	}
-}
diff --unified -r mach-msm/board-8930-regulator-pm8917.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-regulator-pm8917.c
--- mach-msm/board-8930-regulator-pm8917.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-regulator-pm8917.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -194,7 +194,7 @@
 	REGULATOR_SUPPLY("VDDIO_CDC",		"sitar1p1-slim"),
 	REGULATOR_SUPPLY("CDC_VDDA_TX",		"sitar1p1-slim"),
 	REGULATOR_SUPPLY("CDC_VDDA_RX",		"sitar1p1-slim"),
-	REGULATOR_SUPPLY("vcc_i2c",		"0-0048"),
+	REGULATOR_SUPPLY("vddp",		"0-0048"),
 	REGULATOR_SUPPLY("mhl_iovcc18",		"0-0039"),
 	REGULATOR_SUPPLY("CDC_VDD_CP",		"sitar-slim"),
 	REGULATOR_SUPPLY("CDC_VDD_CP",		"sitar1p1-slim"),
@@ -231,6 +231,7 @@
 	REGULATOR_SUPPLY("8917_lvs4",		NULL),
 	REGULATOR_SUPPLY("vcc_i2c",		"3-004a"),
 	REGULATOR_SUPPLY("vcc_i2c",		"3-0024"),
+	REGULATOR_SUPPLY("vcc_i2c",		"0-0048"),
 	REGULATOR_SUPPLY("vddio",		"12-0018"),
 	REGULATOR_SUPPLY("vlogic",		"12-0068"),
 };
diff --unified -r mach-msm/board-8930-storage.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-storage.c
--- mach-msm/board-8930-storage.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8930-storage.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -63,9 +63,11 @@
 		 * hardware revisions - maybe once that is done, this can be
 		 * reverted.
 		 */
+		.always_on = 1,
 		.lpm_sup = 1,
 		.hpm_uA = 800000, /* 800mA */
 		.lpm_uA = 9000,
+		.reset_at_init = true,
 	},
 };
 
@@ -310,22 +312,19 @@
 	 * This change to the boards will be true for newer versions of the SoC
 	 * as well.
 	 */
-	if (SOCINFO_VERSION_MAJOR(socinfo_get_version()) == 1 &&
-			SOCINFO_VERSION_MINOR(socinfo_get_version()) < 2) {
-		msm8960_sdc3_data.vreg_data->vdd_data->always_on = true;
-		msm8960_sdc3_data.vreg_data->vdd_data->reset_at_init = true;
+	if ((SOCINFO_VERSION_MAJOR(socinfo_get_version()) >= 1 &&
+			SOCINFO_VERSION_MINOR(socinfo_get_version()) >= 2) ||
+			machine_is_msm8930_cdp()) {
+		msm8960_sdc3_data.vreg_data->vdd_data->always_on = false;
+		msm8960_sdc3_data.vreg_data->vdd_data->reset_at_init = false;
 	}
+
 	/* SDC3: External card slot */
 	if (!machine_is_msm8930_cdp()) {
 		msm8960_sdc3_data.wpswitch_gpio = 0;
 		msm8960_sdc3_data.is_wpswitch_active_low = false;
 	}
 
-	if (machine_is_msm8930_evt()) {
-		msm8960_sdc3_data.status_gpio = 90;
-		msm8960_sdc3_data.status_irq = MSM_GPIO_TO_INT(90);
-	}
-
 	msm_add_sdcc(3, &msm8960_sdc3_data);
 #endif
 }
diff --unified -r mach-msm/board-8960.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960.c
--- mach-msm/board-8960.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960.c	2013-12-17 17:08:05.610151166 -0800
@@ -305,8 +305,6 @@
 {
 #if defined(CONFIG_MSM_RTB)
 	msm8960_reserve_table[MEMTYPE_EBI1].size += msm8960_rtb_pdata.size;
-	pr_info("mem_map: rtb reserved with size 0x%x in pool\n",
-			msm8960_rtb_pdata.size);
 #endif
 }
 
@@ -347,8 +345,6 @@
 	reserve_memory_for(&android_pmem_audio_pdata);
 #endif
 	msm8960_reserve_table[MEMTYPE_EBI1].size += msm_contig_mem_size;
-	pr_info("mem_map: contig_mem reserved with size 0x%x in pool\n",
-			msm_contig_mem_size);
 #endif
 }
 
@@ -567,9 +563,6 @@
 
 	ret = memblock_remove(reserve_info->fixed_area_start,
 		reserve_info->fixed_area_size);
-	pr_info("mem_map: fixed_area reserved at 0x%lx with size 0x%lx\n",
-			reserve_info->fixed_area_start,
-			reserve_info->fixed_area_size);
 	BUG_ON(ret);
 #endif
 }
@@ -656,7 +649,7 @@
 
 			if (fixed_position != NOT_FIXED)
 				fixed_size += heap->size;
-			else if (!use_cma)
+			else
 				reserve_mem_for_ion(MEMTYPE_EBI1, heap->size);
 
 			if (fixed_position == FIXED_LOW) {
@@ -699,9 +692,6 @@
 		BUG_ON(!IS_ALIGNED(fixed_low_size + HOLE_SIZE, SECTION_SIZE));
 		ret = memblock_remove(fixed_low_start,
 				      fixed_low_size + HOLE_SIZE);
-		pr_info("mem_map: fixed_low_area reserved at 0x%lx with size \
-				0x%x\n", fixed_low_start,
-				fixed_low_size + HOLE_SIZE);
 		BUG_ON(ret);
 	}
 
@@ -712,9 +702,6 @@
 	} else {
 		BUG_ON(!IS_ALIGNED(fixed_middle_size, SECTION_SIZE));
 		ret = memblock_remove(fixed_middle_start, fixed_middle_size);
-		pr_info("mem_map: fixed_middle_area reserved at 0x%lx with \
-				size 0x%x\n", fixed_middle_start,
-				fixed_middle_size);
 		BUG_ON(ret);
 	}
 
@@ -726,9 +713,6 @@
 		/* This is the end of the fixed area so it's okay to round up */
 		fixed_high_size = ALIGN(fixed_high_size, SECTION_SIZE);
 		ret = memblock_remove(fixed_high_start, fixed_high_size);
-		pr_info("mem_map: fixed_high_area reserved at 0x%lx with size \
-				0x%x\n", fixed_high_start,
-				fixed_high_size);
 		BUG_ON(ret);
 	}
 
@@ -785,6 +769,29 @@
 #endif
 }
 
+static void ion_adjust_secure_allocation(void)
+{
+	int i;
+
+	for (i = 0; i < msm8960_ion_pdata.nr; i++) {
+		struct ion_platform_heap *heap =
+			&(msm8960_ion_pdata.heaps[i]);
+
+
+		if (heap->extra_data) {
+			switch ((int) heap->type) {
+			case ION_HEAP_TYPE_CP:
+				if (cpu_is_msm8960()) {
+					((struct ion_cp_heap_pdata *)
+					heap->extra_data)->no_nonsecure_alloc =
+						0;
+				}
+
+			}
+		}
+	}
+}
+
 static void __init reserve_mdp_memory(void)
 {
 	msm8960_mdp_writeback(msm8960_reserve_table);
@@ -798,8 +805,6 @@
 	total = msm8960_cache_dump_pdata.l1_size +
 		msm8960_cache_dump_pdata.l2_size;
 	msm8960_reserve_table[MEMTYPE_EBI1].size += total;
-	pr_info("mem_map: cache_dump reserved with size 0x%x in pool\n",
-			total);
 #endif
 }
 
@@ -1343,8 +1348,6 @@
 static struct mdm_platform_data sglte_platform_data = {
 	.mdm_version = "4.0",
 	.ramdump_delay_ms = 1000,
-	/* delay between two PS_HOLDs */
-	.ps_hold_delay_ms = 500,
 	.soft_reset_inverted = 1,
 	.peripheral_platform_device = NULL,
 	.ramdump_timeout_ms = 600000,
@@ -1390,49 +1393,26 @@
 
 static struct resource tspp_resources[] = {
 	[0] = {
-		.name = "TSIF_TSPP_IRQ",
 		.flags = IORESOURCE_IRQ,
 		.start = TSIF_TSPP_IRQ,
-		.end   = TSIF_TSPP_IRQ,
-	},
-	[1] = {
-		.name = "TSIF0_IRQ",
-		.flags = IORESOURCE_IRQ,
-		.start = TSIF1_IRQ,
 		.end   = TSIF1_IRQ,
 	},
-	[2] = {
-		.name = "TSIF1_IRQ",
-		.flags = IORESOURCE_IRQ,
-		.start = TSIF2_IRQ,
-		.end   = TSIF2_IRQ,
-	},
-	[3] = {
-		.name = "TSIF_BAM_IRQ",
-		.flags = IORESOURCE_IRQ,
-		.start = TSIF_BAM_IRQ,
-		.end   = TSIF_BAM_IRQ,
-	},
-	[4] = {
-		.name = "MSM_TSIF0_PHYS",
+	[1] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSIF0_PHYS,
 		.end   = MSM_TSIF0_PHYS + MSM_TSIF_SIZE - 1,
 	},
-	[5] = {
-		.name = "MSM_TSIF1_PHYS",
+	[2] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSIF1_PHYS,
 		.end   = MSM_TSIF1_PHYS + MSM_TSIF_SIZE - 1,
 	},
-	[6] = {
-		.name = "MSM_TSPP_PHYS",
+	[3] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSPP_PHYS,
 		.end   = MSM_TSPP_PHYS + MSM_TSPP_SIZE - 1,
 	},
-	[7] = {
-		.name = "MSM_TSPP_BAM_PHYS",
+	[4] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSPP_BAM_PHYS,
 		.end   = MSM_TSPP_BAM_PHYS + MSM_TSPP_BAM_SIZE - 1,
@@ -1711,18 +1691,17 @@
 
 /* 8960AB has a different command to assert apc_pdn */
 static uint8_t spm_power_collapse_without_rpm_krait_v3[] __initdata = {
-	0x00, 0x30, 0x24, 0x30,
-	0x84, 0x10, 0x09, 0x03,
-	0x01, 0x10, 0x84, 0x30,
-	0x0C, 0x24, 0x30, 0x0f,
+	0x00, 0x24, 0x84, 0x10,
+	0x09, 0x03, 0x01,
+	0x10, 0x84, 0x30, 0x0C,
+	0x24, 0x30, 0x0f,
 };
 
 static uint8_t spm_power_collapse_with_rpm_krait_v3[] __initdata = {
-	0x00, 0x30, 0x24, 0x30,
-	0x84, 0x10, 0x09, 0x07,
-	0x01, 0x0B, 0x10, 0x84,
-	0x30, 0x0C, 0x24, 0x30,
-	0x0f,
+	0x00, 0x24, 0x84, 0x10,
+	0x09, 0x07, 0x01, 0x0B,
+	0x10, 0x84, 0x30, 0x0C,
+	0x24, 0x30, 0x0f,
 };
 
 static struct msm_spm_seq_entry msm_spm_boot_cpu_seq_list[] __initdata = {
@@ -2559,13 +2538,6 @@
 };
 #endif
 
-#ifdef CONFIG_BATTERY_BCL
-static struct platform_device battery_bcl_device = {
-	.name = "battery_current_limit",
-	.id = -1,
-	};
-#endif
-
 static struct platform_device msm8960_device_ext_5v_vreg __devinitdata = {
 	.name	= GPIO_REGULATOR_DEV_NAME,
 	.id	= PM8921_MPP_PM_TO_SYS(7),
@@ -2622,7 +2594,6 @@
 	.uart_rx_gpio		= 35,
 	.uart_cts_gpio		= 36,
 	.uart_rfr_gpio		= 37,
-	.uartdm_rx_buf_size	= 1024,
 };
 #else
 static struct msm_serial_hs_platform_data msm_uart_dm8_pdata;
@@ -2826,9 +2797,6 @@
 #ifdef CONFIG_MSM_FAKE_BATTERY
 	&fish_battery_device,
 #endif
-#ifdef CONFIG_BATTERY_BCL
-	&battery_bcl_device,
-#endif
 	&msm8960_fmem_device,
 #ifdef CONFIG_ANDROID_PMEM
 #ifndef CONFIG_MSM_MULTIMEDIA_USE_ION
@@ -2952,14 +2920,21 @@
 
 	/* Fixup data that needs to change based on GPU ID */
 	if (cpu_is_msm8960ab()) {
-		if (SOCINFO_VERSION_MINOR(soc_platform_version) == 0)
-			kgsl_3d0_pdata->chipid = ADRENO_CHIPID(3, 2, 1, 0);
-		else
-			kgsl_3d0_pdata->chipid = ADRENO_CHIPID(3, 2, 1, 1);
+		kgsl_3d0_pdata->chipid = ADRENO_CHIPID(3, 2, 1, 0);
 		/* 8960PRO nominal clock rate is 320Mhz */
 		kgsl_3d0_pdata->pwrlevel[1].gpu_freq = 320000000;
+
+		/*
+		 * If this an A320 GPU device (MSM8960AB), then
+		 * switch the resource table to 8960AB, to reflect the
+		 * separate register and shader memory mapping used in A320.
+		 */
+
+		msm_kgsl_3d0.num_resources = kgsl_num_resources_8960ab;
+		msm_kgsl_3d0.resource = kgsl_3d0_resources_8960ab;
 	} else {
 		kgsl_3d0_pdata->iommu_count = 1;
+
 		if (SOCINFO_VERSION_MAJOR(soc_platform_version) == 1) {
 			kgsl_3d0_pdata->pwrlevel[0].gpu_freq = 320000000;
 			kgsl_3d0_pdata->pwrlevel[1].gpu_freq = 266667000;
@@ -3095,12 +3070,6 @@
 	int                    len;
 };
 
-/* AVTimer */
-static struct platform_device msm_dev_avtimer_device = {
-	.name = "dev_avtimer",
-	.dev = { .platform_data = &dev_avtimer_pdata },
-};
-
 /* Sensors DSPS platform data */
 #ifdef CONFIG_MSM_DSPS
 #define DSPS_PIL_GENERIC_NAME		"dsps"
@@ -3311,6 +3280,12 @@
  {
  	int i;
  
+	/* Reset the AVS registers until we have support for AVS */
+ 	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+ 		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+ 		pdata->reg_init_values[MSM_SPM_REG_SAW2_AVS_CTL] = 0;
+ 		pdata->reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0;
+ 	}
 
 	/* Update the SPM sequences for SPC and PC */
 	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
@@ -3473,10 +3448,7 @@
 		mdm_sglte_device.dev.platform_data = &sglte_platform_data;
 		platform_device_register(&mdm_sglte_device);
 	}
-	if (machine_is_msm8960_mtp() || machine_is_msm8960_fluid() ||
-		machine_is_msm8960_cdp()) {
-		platform_device_register(&msm_dev_avtimer_device);
-	}
+	ion_adjust_secure_allocation();
 }
 
 MACHINE_START(MSM8960_CDP, "QCT MSM8960 CDP")
diff --unified -r mach-msm/board-8960-camera.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-camera.c
--- mach-msm/board-8960-camera.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-camera.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -260,7 +260,7 @@
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab  = 27648000,
-		.ib  = 2656000000UL,
+		.ib  = 110592000,
 	},
 	{
 		.src = MSM_BUS_MASTER_VPE,
@@ -292,8 +292,8 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 600000000,
-		.ib  = 2656000000UL,
+		.ab  = 274406400,
+		.ib  = 617103360,
 	},
 	{
 		.src = MSM_BUS_MASTER_VPE,
@@ -325,8 +325,8 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 600000000,
-		.ib  = 2656000000UL,
+		.ab  = 274423680,
+		.ib  = 1097694720,
 	},
 	{
 		.src = MSM_BUS_MASTER_VPE,
@@ -358,8 +358,8 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 800000000,
-		.ib  = 4264000000UL,
+		.ab  = 302071680,
+		.ib  = 1208286720,
 	},
 	{
 		.src = MSM_BUS_MASTER_VPE,
@@ -370,7 +370,7 @@
 	{
 		.src = MSM_BUS_MASTER_JPEG_ENC,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 0,
+		.ab  = 540000000,
 		.ib  = 1350000000,
 	},
 	{
@@ -424,8 +424,8 @@
 	{
 		.src = MSM_BUS_MASTER_VFE,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 600000000,
-		.ib  = 2656000000UL,
+		.ab  = 348192000,
+		.ib  = 1208286720,
 	},
 	{
 		.src = MSM_BUS_MASTER_VPE,
@@ -769,34 +769,6 @@
 	.eeprom_info = &imx091_eeprom_info,
 };
 
-static struct msm_camera_sensor_flash_data flash_imx135 = {
-	.flash_type = MSM_CAMERA_FLASH_NONE,
-};
-
-static struct msm_camera_csi_lane_params imx135_csi_lane_params = {
-	.csi_lane_assign = 0xE4,
-	.csi_lane_mask = 0xF,
-};
-
-static struct msm_camera_sensor_platform_info sensor_board_info_imx135 = {
-	.mount_angle = 90,
-	.cam_vreg = msm_8960_cam_vreg,
-	.num_vreg = ARRAY_SIZE(msm_8960_cam_vreg),
-	.gpio_conf = &msm_8960_back_cam_gpio_conf,
-	.csi_lane_params = &imx135_csi_lane_params,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_imx135_data = {
-	.sensor_name = "imx135",
-	.pdata = &msm_camera_csi_device_data[0],
-	.flash_data = &flash_imx135,
-	.sensor_platform_info = &sensor_board_info_imx135,
-	.csi_if = 1,
-	.camera_type = BACK_CAMERA_2D,
-	.sensor_type = BAYER_SENSOR,
-	.actuator_info = &msm_act_main_cam_1_info,
-};
-
 static struct pm8xxx_mpp_config_data privacy_light_on_config = {
 	.type		= PM8XXX_MPP_TYPE_SINK,
 	.level		= PM8XXX_MPP_CS_OUT_5MA,
@@ -891,10 +863,6 @@
 	.platform_data = &msm_camera_sensor_imx074_data,
 	},
 	{
-	I2C_BOARD_INFO("imx135", 0x10),
-	.platform_data = &msm_camera_sensor_imx135_data,
-	},
-	{
 	I2C_BOARD_INFO("ov2720", 0x6C),
 	.platform_data = &msm_camera_sensor_ov2720_data,
 	},
diff --unified -r mach-msm/board-8960-display.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-display.c
--- mach-msm/board-8960-display.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-display.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -578,7 +578,7 @@
 	.mdp_max_clk = 200000000,
 	.mdp_max_bw = 2000000000,
 	.mdp_bw_ab_factor = 115,
-	.mdp_bw_ib_factor = 150,
+	.mdp_bw_ib_factor = 125,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.mdp_bus_scale_table = &mdp_bus_scale_pdata,
 #endif
@@ -589,8 +589,6 @@
 	.mem_hid = MEMTYPE_EBI1,
 #endif
 	.cont_splash_enabled = 0x01,
-	.splash_screen_addr = 0x00,
-	.splash_screen_size = 0x00,
 	.mdp_iommu_split_domain = 0,
 };
 
@@ -603,9 +601,6 @@
 		mdp_pdata.ov0_wb_size;
 	reserve_table[mdp_pdata.mem_hid].size +=
 		mdp_pdata.ov1_wb_size;
-
-	pr_info("mem_map: mdp reserved with size 0x%lx in pool\n",
-			mdp_pdata.ov0_wb_size + mdp_pdata.ov1_wb_size);
 #endif
 }
 
@@ -726,8 +721,6 @@
 	.resource = hdmi_msm_resources,
 	.dev.platform_data = &hdmi_msm_data,
 };
-#else
-static int hdmi_panel_power(int on) { return 0; }
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
 
 #ifdef CONFIG_FB_MSM_WRITEBACK_MSM_PANEL
@@ -782,6 +775,19 @@
 	.bus_scale_table = &dtv_bus_scale_pdata,
 	.lcdc_power_save = hdmi_panel_power,
 };
+
+static int hdmi_panel_power(int on)
+{
+	int rc;
+
+	pr_debug("%s: HDMI Core: %s\n", __func__, (on ? "ON" : "OFF"));
+	rc = hdmi_core_power(on, 1);
+	if (rc)
+		rc = hdmi_cec_power(on);
+
+	pr_debug("%s: HDMI Core: %s Success\n", __func__, (on ? "ON" : "OFF"));
+	return rc;
+}
 #endif
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
@@ -979,19 +985,6 @@
 error:
 	return rc;
 }
-
-static int hdmi_panel_power(int on)
-{
-	int rc;
-
-	pr_debug("%s: HDMI Core: %s\n", __func__, (on ? "ON" : "OFF"));
-	rc = hdmi_core_power(on, 1);
-	if (rc)
-		rc = hdmi_cec_power(on);
-
-	pr_debug("%s: HDMI Core: %s Success\n", __func__, (on ? "ON" : "OFF"));
-	return rc;
-}
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL */
 
 void __init msm8960_init_fb(void)
diff --unified -r mach-msm/board-8960-gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-gpiomux.c
--- mach-msm/board-8960-gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-gpiomux.c	2013-12-17 17:08:05.610151166 -0800
@@ -108,7 +108,7 @@
 };
 
 static struct gpiomux_setting gsbi9_suspended_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
+	.func = GPIOMUX_FUNC_2,
 	.drv = GPIOMUX_DRV_2MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
@@ -243,25 +243,25 @@
 
 static struct gpiomux_setting ap2mdm_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting mdm2ap_status_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 static struct gpiomux_setting mdm2ap_errfatal_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_16MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting ap2mdm_kpdpwr_n_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
diff --unified -r mach-msm/board-8960-pmic.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-pmic.c
--- mach-msm/board-8960-pmic.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-pmic.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -249,8 +249,8 @@
 static const unsigned int keymap[] = {
 	KEY(0, 0, KEY_VOLUMEUP),
 	KEY(0, 1, KEY_VOLUMEDOWN),
-	KEY(0, 2, KEY_CAMERA_FOCUS),
-	KEY(0, 3, KEY_CAMERA_SNAPSHOT),
+	KEY(0, 2, KEY_CAMERA_SNAPSHOT),
+	KEY(0, 3, KEY_CAMERA_FOCUS),
 };
 
 static struct matrix_keymap_data keymap_data = {
@@ -396,17 +396,16 @@
 #define MAX_VOLTAGE_MV		4200
 #define CHG_TERM_MA		100
 static struct pm8921_charger_platform_data pm8921_chg_pdata __devinitdata = {
+	.safety_time		= 180,
 	.update_time		= 60000,
 	.max_voltage		= MAX_VOLTAGE_MV,
 	.min_voltage		= 3200,
 	.uvd_thresh_voltage	= 4050,
-	.alarm_low_mv		= 3400,
-	.alarm_high_mv		= 4000,
-	.resume_voltage_delta	= 60,
-	.resume_charge_percent	= 99,
+	.alarm_voltage		= 3400,
+	.resume_voltage_delta	= 100,
 	.term_current		= CHG_TERM_MA,
 	.cool_temp		= 10,
-	.warm_temp		= 45,
+	.warm_temp		= 40,
 	.temp_check_period	= 1,
 	.max_bat_chg_current	= 1100,
 	.cool_bat_chg_current	= 350,
@@ -424,24 +423,13 @@
 
 static struct pm8921_bms_platform_data pm8921_bms_pdata __devinitdata = {
 	.battery_type			= BATT_UNKNOWN,
-	.r_sense_uohm			= 10000,
+	.r_sense			= 10,
 	.v_cutoff			= 3400,
 	.max_voltage_uv			= MAX_VOLTAGE_MV * 1000,
 	.rconn_mohm			= 18,
 	.shutdown_soc_valid_limit	= 20,
 	.adjust_soc_low_threshold	= 25,
 	.chg_term_ua			= CHG_TERM_MA * 1000,
-	.normal_voltage_calc_ms		= 20000,
-	.low_voltage_calc_ms		= 1000,
-	.alarm_low_mv			= 3400,
-	.alarm_high_mv			= 4000,
-	.high_ocv_correction_limit_uv	= 50,
-	.low_ocv_correction_limit_uv	= 100,
-	.hold_soc_est			= 3,
-	.enable_fcc_learning		= 1,
-	.min_fcc_learning_soc		= 20,
-	.min_fcc_ocv_pc			= 30,
-	.min_fcc_learning_samples	= 5,
 };
 
 #define	PM8921_LC_LED_MAX_CURRENT	4	/* I = 4mA */
@@ -563,7 +551,7 @@
 };
 
 static struct pm8xxx_ccadc_platform_data pm8xxx_ccadc_pdata = {
-	.r_sense_uohm		= 10000,
+	.r_sense		= 10,
 	.calib_delay_ms		= 600000,
 };
 
@@ -622,8 +610,4 @@
 
 	if (machine_is_msm8960_fluid())
 		pm8921_bms_pdata.rconn_mohm = 20;
-
-	if (!machine_is_msm8960_fluid() && !machine_is_msm8960_liquid()
-			&& !machine_is_msm8960_mtp())
-		pm8921_chg_pdata.battery_less_hardware = 1;
 }
diff --unified -r mach-msm/board-8960-regulator.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-regulator.c
--- mach-msm/board-8960-regulator.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8960-regulator.c	2013-12-17 17:08:05.610151166 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -74,7 +74,6 @@
 VREG_CONSUMERS(L11) = {
 	REGULATOR_SUPPLY("8921_l11",		NULL),
 	REGULATOR_SUPPLY("cam_vana",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vana",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vana",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vana",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vana",		"4-0020"),
@@ -83,7 +82,6 @@
 VREG_CONSUMERS(L12) = {
 	REGULATOR_SUPPLY("8921_l12",		NULL),
 	REGULATOR_SUPPLY("cam_vdig",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vdig",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vdig",		"4-0020"),
@@ -92,7 +90,6 @@
 VREG_CONSUMERS(L14) = {
 	REGULATOR_SUPPLY("8921_l14",		NULL),
 	REGULATOR_SUPPLY("pa_therm",		"pm8xxx-adc"),
-	REGULATOR_SUPPLY("vreg_xoadc",		"pm8921-charger"),
 };
 VREG_CONSUMERS(L15) = {
 	REGULATOR_SUPPLY("8921_l15",		NULL),
@@ -100,7 +97,6 @@
 VREG_CONSUMERS(L16) = {
 	REGULATOR_SUPPLY("8921_l16",		NULL),
 	REGULATOR_SUPPLY("cam_vaf",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vaf",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vaf",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vaf",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vaf",		"4-0020"),
@@ -221,7 +217,6 @@
 VREG_CONSUMERS(LVS5) = {
 	REGULATOR_SUPPLY("8921_lvs5",		NULL),
 	REGULATOR_SUPPLY("cam_vio",		"4-001a"),
-	REGULATOR_SUPPLY("cam_vio",		"4-0010"),
 	REGULATOR_SUPPLY("cam_vio",		"4-006c"),
 	REGULATOR_SUPPLY("cam_vio",		"4-0048"),
 	REGULATOR_SUPPLY("cam_vio",		"4-0020"),
@@ -630,27 +625,16 @@
 	static struct rpm_regulator_init_data *rpm_data;
 	int i;
 
-	if (machine_is_msm8960_cdp() || cpu_is_msm8960ab()) {
+	if (machine_is_msm8960_cdp()) {
 		/* Only modify LVS6 consumers for CDP targets. */
 		for (i = 0; i < ARRAY_SIZE(msm_rpm_regulator_init_data); i++) {
 			rpm_data = &msm_rpm_regulator_init_data[i];
-			if (machine_is_msm8960_cdp() &&
-				rpm_data->id == RPM_VREG_ID_PM8921_LVS6) {
+			if (rpm_data->id == RPM_VREG_ID_PM8921_LVS6) {
 				rpm_data->init_data.consumer_supplies
 					= vreg_consumers_CDP_LVS6;
 				rpm_data->init_data.num_consumer_supplies
 					= ARRAY_SIZE(vreg_consumers_CDP_LVS6);
 			}
-			if (cpu_is_msm8960ab() &&
-				rpm_data->id == RPM_VREG_ID_PM8921_S7) {
-				rpm_data->init_data.constraints.min_uV =
-								1275000;
-				rpm_data->init_data.constraints.max_uV =
-								1275000;
-				rpm_data->init_data.constraints.input_uV =
-								1275000;
-				rpm_data->default_uV = 1275000;
-			}
 		}
 	}
 }
diff --unified -r mach-msm/board-8974.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8974.c
--- mach-msm/board-8974.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-8974.c	2013-12-17 17:08:05.610151166 -0800
@@ -21,9 +21,6 @@
 #include <linux/of_platform.h>
 #include <linux/of_irq.h>
 #include <linux/memory.h>
-#ifdef CONFIG_ANDROID_PMEM
-#include <linux/android_pmem.h>
-#endif
 #include <linux/regulator/machine.h>
 #include <linux/regulator/krait-regulator.h>
 #include <linux/msm_thermal.h>
diff --unified -r mach-msm/board-fusion3-battery.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-fusion3-battery.c
--- mach-msm/board-fusion3-battery.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-fusion3-battery.c	2013-12-17 17:08:05.610151166 -0800
@@ -42,7 +42,7 @@
 	{460,	460,	200,	40*60},
 	{1900,	1600,	200,	40*60},
 	{460,	460,	200,	40*60},
-	{460,	460,	200,	40*60},
+	{1000,	1000,	200,	40*60},
 	{1000,	1000,	200,	40*60},
 	{460,	460,	200,	40*60},
 	{1700,	1600,	200,	40*60},
@@ -273,12 +273,12 @@
 				charge_current = 400;
 				break;
 			case ONLINE_POWER_TYPE_MHL_900:
-				cable_type = POWER_SUPPLY_TYPE_MAINS;
+				cable_type = POWER_SUPPLY_TYPE_MISC;
 				charge_current_max = 700;
 				charge_current = 700;
 				break;
 			case ONLINE_POWER_TYPE_MHL_1500:
-				cable_type = POWER_SUPPLY_TYPE_MAINS;
+				cable_type = POWER_SUPPLY_TYPE_MISC;
 				charge_current_max = 1300;
 				charge_current = 1300;
 				break;
@@ -325,14 +325,6 @@
 
 	if(system_rev >= 0x8)
 	{
-#ifdef CONFIG_SAMSUNG_BATTERY_FACTORY
-		pr_info("%s set ldo on\n", __func__);
-		l29 = regulator_get(NULL, "8921_l29");
-		if(l29 > 0)
-		{
-			regulator_enable(l29);
-		}
-#else
 		if (current_cable_type == POWER_SUPPLY_TYPE_BATTERY)
 		{
 			pr_info("%s set ldo off\n", __func__);
@@ -351,7 +343,6 @@
 				regulator_enable(l29);
 			}
 		}
-#endif
 	}
 	return true;
 }
@@ -502,11 +493,7 @@
 	30,	/* CHARGING */
 	30,	/* DISCHARGING */
 	30,	/* NOT_CHARGING */
-#if defined(CONFIG_MACH_JACTIVE_EUR)
-	5 * 60,	/* SLEEP */
-#else
 	60 * 60,	/* SLEEP */
-#endif
 };
 
 #if defined(CONFIG_MACH_JF_ATT) || defined(CONFIG_MACH_JF_TMO) || \
@@ -673,7 +660,7 @@
 	.temp_low_threshold_normal = -30,
 	.temp_low_recovery_normal = 0,
 
-	.temp_high_threshold_lpm = 470,
+	.temp_high_threshold_lpm = 500,
 	.temp_high_recovery_lpm = 430,
 	.temp_low_threshold_lpm = -30,
 	.temp_low_recovery_lpm = 0,
diff --unified -r mach-msm/board-jactive_att.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_att.c
--- mach-msm/board-jactive_att.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_att.c	2013-12-17 17:08:05.610151166 -0800
@@ -291,7 +291,7 @@
 
 	if (!reg_l8) {
 		reg_l8 = regulator_get(NULL, "8921_l8");
-		ret = regulator_set_voltage(reg_l8, 1800000, 3000000);
+		ret = regulator_set_voltage(reg_l8, 3000000, 3000000);
 
 		if (IS_ERR(reg_l8)) {
 			printk(KERN_ERR"could not get 8921_l8, rc = %ld\n",
@@ -1034,47 +1034,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1176,12 +1135,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1221,21 +1174,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -4046,7 +3987,6 @@
 	&msm_rotator_device,
 #endif
 	&msm8064_pc_cntr,
-	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -4421,7 +4361,7 @@
 		.desc           = "volume_up_key",
 		.active_low     = 1,
 		.type		= EV_KEY,
-		.wakeup		= 0,
+		.wakeup		= 1,
 		.debounce_interval = 5,
 	},
 	{
@@ -4430,7 +4370,7 @@
 		.desc           = "volume_down_key",
 		.active_low     = 1,
 		.type		= EV_KEY,
-		.wakeup		= 0,
+		.wakeup		= 1,
 		.debounce_interval = 5,
 	},
 	{
@@ -5255,7 +5195,7 @@
 	printk(KERN_DEBUG"[TSP] System revision, LPM mode : %d %d\n",
 				system_rev, poweroff_charging);
 	if (!poweroff_charging) 
-		S5000_tsp_input_init(lcd_tsp_panel_version);
+			S5000_tsp_input_init(lcd_tsp_panel_version);
 #endif
 
 #if defined(CONFIG_VIDEO_MHL_V2)
@@ -5383,7 +5323,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jactive_att-gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_att-gpiomux.c
--- mach-msm/board-jactive_att-gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_att-gpiomux.c	2013-12-17 17:08:05.610151166 -0800
@@ -27,14 +27,12 @@
 #include "board-8064.h"
 #include <mach/apq8064-gpio.h>
 
-#if 0
 /* The SPI configurations apply to GSBI 5*/
 static struct gpiomux_setting gpio_spi_config = {
 	.func = GPIOMUX_FUNC_2,
 	.drv = GPIOMUX_DRV_12MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
-#endif
 
 #if defined(CONFIG_KS8851) || defined(CONFIG_KS8851_MODULE)
 static struct gpiomux_setting gpio_eth_config = {
@@ -138,13 +136,6 @@
 
 struct msm_gpiomux_config vcap_configs[] = {
 	{
-		.gpio = 20,
-		.settings = {
-			[GPIOMUX_SUSPENDED] =	&gpio_vcap_config[7],
-			[GPIOMUX_ACTIVE] =		&gpio_vcap_config[7],
-		}
-	},
-	{
 		.gpio = 25,
 		.settings = {
 			[GPIOMUX_SUSPENDED] =	&gpio_vcap_config[2],
@@ -336,16 +327,10 @@
 };
 #endif
 
-static struct gpiomux_setting gpio_i2c_config = {
-	.func = GPIOMUX_FUNC_1,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct gpiomux_setting gpio_i2c_config_sus = {
-	.func = GPIOMUX_FUNC_1,
+static struct gpiomux_setting gpio_nc_config = {
+	.func = GPIOMUX_FUNC_GPIO,
 	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_KEEPER,
+	.pull = GPIOMUX_PULL_DOWN,
 };
 
 static struct gpiomux_setting mbhc_hs_detect = {
@@ -485,63 +470,6 @@
 };
 
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
-static struct gpiomux_setting cyts_sleep_sus_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_6MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct gpiomux_setting cyts_sleep_act_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_6MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct gpiomux_setting cyts_int_act_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_UP,
-};
-
-static struct gpiomux_setting cyts_int_sus_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct msm_gpiomux_config cyts_gpio_configs[] __initdata = {
-	{	/* TS INTERRUPT */
-		.gpio = 6,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cyts_int_act_cfg,
-			[GPIOMUX_SUSPENDED] = &cyts_int_sus_cfg,
-		},
-	},
-	{	/* TS SLEEP */
-		.gpio = 33,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cyts_sleep_act_cfg,
-			[GPIOMUX_SUSPENDED] = &cyts_sleep_sus_cfg,
-		},
-	},
-};
-static struct msm_gpiomux_config cyts_gpio_alt_config[] __initdata = {
-	{	/* TS INTERRUPT */
-		.gpio = 6,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cyts_int_act_cfg,
-			[GPIOMUX_SUSPENDED] = &cyts_int_sus_cfg,
-		},
-	},
-	{	/* TS SLEEP */
-		.gpio = 12,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &cyts_sleep_act_cfg,
-			[GPIOMUX_SUSPENDED] = &cyts_sleep_sus_cfg,
-		},
-	},
-};
-
 static struct gpiomux_setting hsic_act_cfg = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_8MA,
@@ -742,20 +670,6 @@
 		},
 	},
 	{
-		.gpio      = 21,		/* GSBI1 QUP I2C_CLK */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gpio_i2c_config_sus,
-			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
-		},
-	},
-	{
-		.gpio      = 20,		/* GSBI1 QUP I2C_DATA */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gpio_i2c_config_sus,
-			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
-		},
-	},
-	{
 		.gpio      = 24,	/* GSBI2 I2C QUP SDA */
 		.settings = {
 			[GPIOMUX_SUSPENDED] = &gsbi2_suspend_cfg,
@@ -772,29 +686,29 @@
 	{
 		.gpio      = 51,		/* GSBI5 QUP SPI_DATA_MOSI */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
 		},
 	},
 	{
 		.gpio      = 52,		/* GSBI5 QUP SPI_DATA_MISO */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
 		},
 	},
 	{
 		.gpio      = 53,		/* Funny CS0 */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
 		},
 	},
 	{
 		.gpio      = 54,		/* GSBI5 QUP SPI_CLK */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
+			[GPIOMUX_ACTIVE] = &gpio_spi_config,
 		},
 	},
 #if !defined(CONFIG_USB_EHCI_MSM_HSIC)
@@ -819,6 +733,50 @@
 	},
 };
 
+static struct msm_gpiomux_config apq8064_nc_configs[] __initdata = {
+	{
+		.gpio      = 20,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
+		},
+	},
+	{
+		.gpio      = 21,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
+		},
+	},
+	{
+		.gpio      = 29,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
+		},
+	},
+};
+
+static struct msm_gpiomux_config apq8064_nc_configs_rev05[] __initdata = {
+#if !defined(CONFIG_FB_MSM_ENABLE_LCD_EN2)
+	{
+		.gpio      = 20,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
+		},
+	},
+#endif
+	{
+		.gpio      = 21,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
+		},
+	},
+	{
+		.gpio      = 29,
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
+		},
+	},
+};
+
 static struct msm_gpiomux_config apq8064_slimbus_config[] __initdata = {
 	{
 		.gpio   = 40,           /* slimbus clk */
@@ -1376,23 +1334,49 @@
 	},
 };
 
-static struct gpiomux_setting sd_det_line = {
+static struct gpiomux_setting sd_det_active_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
 	.drv = GPIOMUX_DRV_2MA,
 	.pull = GPIOMUX_PULL_UP,
 	.dir = GPIOMUX_IN,
 };
 
+static struct gpiomux_setting sd_det_suspended_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_IN,
+};
+
 static struct msm_gpiomux_config msm8064_sd_det_config[] = {
 	{
 		.gpio = 26,	/* SD Card Detect Line */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &sd_det_line,
-			[GPIOMUX_ACTIVE] = &sd_det_line,
+			[GPIOMUX_SUSPENDED] = &sd_det_suspended_cfg,
+			[GPIOMUX_ACTIVE] = &sd_det_active_cfg,
 		},
 	},
 };
 
+#ifdef CONFIG_MMC_MSM_SDC4_SUPPORT
+
+static struct gpiomux_setting ls_en_suspended_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_LOW,
+};
+
+static struct msm_gpiomux_config msm8064_ls_en_config[] = {
+	{
+		.gpio = 64,	/* Level Shifter Enable */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &ls_en_suspended_cfg,
+		},
+	},
+};
+
+#endif
+
 #if defined(CONFIG_LEDS_AN30259A)
 static struct gpiomux_setting leds_active_cfg = {
 		.func = GPIOMUX_FUNC_GPIO,
@@ -1542,6 +1526,9 @@
 	else
 		msm_gpiomux_install(sdc2_interface,
 				ARRAY_SIZE(sdc2_interface));
+
+	msm_gpiomux_install(msm8064_ls_en_config,
+			ARRAY_SIZE(msm8064_ls_en_config));
 #else
 	msm_gpiomux_install(wcnss_5wire_interface,
 			ARRAY_SIZE(wcnss_5wire_interface));
@@ -1567,6 +1554,17 @@
 				ARRAY_SIZE(apq8064_gsbi_configs));
 	}
 
+	if( system_rev >= 13 ) // rev0.5 + 8
+	{
+		msm_gpiomux_install(apq8064_nc_configs_rev05,
+				ARRAY_SIZE(apq8064_nc_configs_rev05));
+	}
+	else
+	{
+		msm_gpiomux_install(apq8064_nc_configs,
+				ARRAY_SIZE(apq8064_nc_configs));
+	}
+
 	msm_gpiomux_install(sensorhub_configs,
 			ARRAY_SIZE(sensorhub_configs));
 	msm_gpiomux_install(apq8064_slimbus_config,
@@ -1602,16 +1600,6 @@
 					ARRAY_SIZE(mdm_configs));
 	}
 
-	if (machine_is_apq8064_mtp()|| machine_is_JF()) {
-		if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
-			msm_gpiomux_install(cyts_gpio_alt_config,
-					ARRAY_SIZE(cyts_gpio_alt_config));
-		} else {
-			msm_gpiomux_install(cyts_gpio_configs,
-					ARRAY_SIZE(cyts_gpio_configs));
-		}
-	}
-
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
 	if (machine_is_apq8064_mtp()|| machine_is_JF())
 		msm_gpiomux_install(apq8064_hsic_configs,
diff --unified -r mach-msm/board-jactive_eur.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_eur.c
--- mach-msm/board-jactive_eur.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_eur.c	2013-12-17 17:08:05.614151159 -0800
@@ -1028,47 +1028,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1168,13 +1127,36 @@
 	},
 };
 
-#endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
+static struct i2c_gpio_platform_data  cypress_touchkey_i2c_gpio_data = {
+	.sda_pin		= GPIO_TOUCHKEY_SDA,	
+	.scl_pin		= GPIO_TOUCHKEY_SCL,
+	.udelay			= 0,
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 0,
+};
+static struct platform_device touchkey_i2c_gpio_device = {
+	.name			= "i2c-gpio",
+	.id			= MSM_TOUCHKEY_I2C_BUS_ID,
+	.dev.platform_data	= &cypress_touchkey_i2c_gpio_data,
+};
+
+static struct i2c_gpio_platform_data  cypress_touchkey_i2c_gpio_data_2 = {
+	.sda_pin		= GPIO_TOUCHKEY_SDA,	
+	.scl_pin		= GPIO_TOUCHKEY_SCL_2,
+	.udelay			= 0,
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 0,
+};
+static struct platform_device touchkey_i2c_gpio_device_2 = {
+	.name			= "i2c-gpio",
+	.id			= MSM_TOUCHKEY_I2C_BUS_ID,
+	.dev.platform_data	= &cypress_touchkey_i2c_gpio_data_2,
+};
+
+#endif
 
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
@@ -1215,21 +1197,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -1900,48 +1870,6 @@
 
 #define MPP_MCU_NRST PM8921_MPP_PM_TO_SYS(4)
 
-static void clear_ssp_gpio(void)
-{
-	struct pm_gpio ap_mcu_int_cfg = {
-		.direction = PM_GPIO_DIR_IN,
-		.pull = PM_GPIO_PULL_DN,
-		.vin_sel = 2,
-		.function = PM_GPIO_FUNC_NORMAL,
-		.inv_int_pol = 0,
-	};
-	struct pm_gpio mcu_ap_int_2_cfg = {
-		.direction = PM_GPIO_DIR_IN,
-		.pull = PM_GPIO_PULL_DN,
-		.vin_sel = 2,
-		.function = PM_GPIO_FUNC_NORMAL,
-		.inv_int_pol = 0,
-	};
-	struct pm_gpio mcu_ap_int_cfg = {
-		.direction = PM_GPIO_DIR_IN,
-		.pull = PM_GPIO_PULL_DN,
-		.vin_sel = 2,
-		.function = PM_GPIO_FUNC_NORMAL,
-		.inv_int_pol = 0,
-	};
-	struct pm_gpio ap_mcu_nrst_cfg = {
-		.direction = PM_GPIO_DIR_OUT,
-		.pull = PM_GPIO_PULL_NO,
-		.vin_sel = 2,
-		.function = PM_GPIO_FUNC_NORMAL,
-		.inv_int_pol = 0,
-		.out_strength = PM_GPIO_STRENGTH_HIGH,
-	};
-
-	pm8xxx_gpio_config(GPIO_AP_MCU_INT, &ap_mcu_int_cfg);
-	pm8xxx_gpio_config(GPIO_MCU_AP_INT, &mcu_ap_int_cfg);
-	pm8xxx_gpio_config(GPIO_MCU_AP_INT_2, &mcu_ap_int_2_cfg);
-	if (system_rev >= 5)
-		pm8xxx_gpio_config(GPIO_MCU_NRST, &ap_mcu_nrst_cfg);
-	gpio_set_value_cansleep(GPIO_MCU_NRST, 0);
-	mdelay(1);
-	pr_info("[SSP] %s done\n", __func__);
-}
-
 static int initialize_ssp_gpio(void)
 {
 	int err;
@@ -1973,7 +1901,6 @@
 		.vin_sel = 2,
 		.function = PM_GPIO_FUNC_NORMAL,
 		.inv_int_pol = 0,
-		.out_strength = PM_GPIO_STRENGTH_HIGH,
 	};
 
 	pr_info("[SSP]%s\n", __func__);
@@ -2101,36 +2028,32 @@
 		GPIO_CFG_NO_PULL, GPIO_CFG_2MA), 1);
 }
 #endif
-#define GPIO_NFC_FIRMWARE_REV2	PM8921_GPIO_PM_TO_SYS(12)
 static int __init bcm2079x_init(void)
 {
 	struct pm_gpio nfc_irq_cfg = {
 		.direction = PM_GPIO_DIR_IN,
-		.pull = PM_GPIO_PULL_DN,
+		.pull = PM_GPIO_PULL_NO,
 		.vin_sel = 2,
 		.function = PM_GPIO_FUNC_NORMAL,
 		.inv_int_pol = 0,
 	};
 	struct pm_gpio nfc_en_cfg = {
 		.direction = PM_GPIO_DIR_OUT,
-		.pull = PM_GPIO_PULL_DN,
+		.pull = PM_GPIO_PULL_UP_31P5,
 		.vin_sel = 2,
 		.function = PM_GPIO_FUNC_NORMAL,
 		.inv_int_pol = 0,
 	};
 	struct pm_gpio nfc_firmware_cfg = {
 		.direction = PM_GPIO_DIR_OUT,
-		.pull = PM_GPIO_PULL_NO,
+		.pull = PM_GPIO_PULL_UP_31P5,
 		.vin_sel = 2,
 		.function = PM_GPIO_FUNC_NORMAL,
 		.inv_int_pol = 0,
 	};
 	pm8xxx_gpio_config(GPIO_NFC_IRQ, &nfc_irq_cfg);
 	pm8xxx_gpio_config(GPIO_NFC_EN, &nfc_en_cfg);
-	if (system_rev > BOARD_REV13)
-		pm8xxx_gpio_config(GPIO_NFC_FIRMWARE_REV2, &nfc_firmware_cfg);
-	else
-		pm8xxx_gpio_config(GPIO_NFC_FIRMWARE, &nfc_firmware_cfg);
+	pm8xxx_gpio_config(GPIO_NFC_FIRMWARE, &nfc_firmware_cfg);
 #ifdef NFC_SW_I2C
 	bcm2079x_sw_i2c_config();
 #endif
@@ -2155,7 +2078,7 @@
 static struct bcm2079x_platform_data bcm2079x_i2c_pdata = {
 	.irq_gpio = GPIO_NFC_IRQ,
 	.en_gpio = GPIO_NFC_EN,
-	.wake_gpio = GPIO_NFC_FIRMWARE_REV2,
+	.wake_gpio = GPIO_NFC_FIRMWARE,
 };
 
 static struct i2c_board_info nfc_bcm2079x_info[] __initdata = {
@@ -3117,29 +3040,6 @@
 	},
 };
 
-#ifdef CONFIG_CAMERA_SW_I2C_ACT
-static struct i2c_gpio_platform_data hvca_i2c_gpio_data = {
-	.sda_pin = 71,
-	.scl_pin = 70,
-	.udelay = 5,
-};
-struct platform_device hvca_i2c_gpio_device = {
-	.name = "i2c-gpio",
-	.id = MSM_CAMERA_SW_I2C_BUS_ID, // 27
-	.dev = {
-		.platform_data  = &hvca_i2c_gpio_data,
-	},
-};
-#endif
-static struct spi_board_info eeprom_spi_info[] __initdata = {
-    {
-        .modalias               = "imx175_spi",
-        .max_speed_hz           = 9963243,
-        .bus_num                = 0,
-        .chip_select            = 0,
-        .mode                   = SPI_MODE_0,
-    },
-};
 static struct msm_rpmrs_level msm_rpmrs_levels[] = {
 	{
 		MSM_PM_SLEEP_MODE_WAIT_FOR_INTERRUPT,
@@ -3727,7 +3627,7 @@
 static struct platform_device *early_common_devices[] __initdata = {
 	&apq8064_device_acpuclk,
 	&apq8064_device_dmov,
-	//&apq8064_device_qup_spi_gsbi5,
+	&apq8064_device_qup_spi_gsbi5,
 };
 
 static struct platform_device *pm8921_common_devices[] __initdata = {
@@ -3757,10 +3657,6 @@
 	&apq8064_device_hsusb_host,
 	&android_usb_device,
 	&msm_device_wcnss_wlan,
-	&apq8064_device_qup_spi_gsbi5, // Fortius AF
-#if 0 
-    &msm8930_device_qup_spi_gsbi1,
-#endif
 	&msm_device_iris_fm,
 	&apq8064_fmem_device,
 #ifdef CONFIG_ANDROID_PMEM
@@ -3901,9 +3797,6 @@
 #ifdef CONFIG_ANDROID_RAM_CONSOLE
 	&ram_console_device,
 #endif
-#ifdef CONFIG_CAMERA_SW_I2C_ACT
-	&hvca_i2c_gpio_device,
-#endif
 };
 
 static struct platform_device *cdp_devices[] __initdata = {
@@ -3913,8 +3806,6 @@
 #ifdef CONFIG_MSM_ROTATOR
 	&msm_rotator_device,
 #endif
-	&msm8064_pc_cntr,
-	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -4059,38 +3950,20 @@
 static int  es325_enable_VDD_CORE(void)
 {
 	static struct regulator *l18;
-	static struct regulator *l27;
 	int ret;
-	
-	if (system_rev <= 13 ) {
-		l18 = regulator_get(NULL, "8921_l18");
-		if (IS_ERR(l18)) {
-			pr_err("%s: error regulator_get\n", __func__);
-			return -1;
-		}
-		ret = regulator_set_voltage(l18, 1100000, 1100000);
-		if (ret)
-			pr_err("%s: error set voltage ret=%d\n", __func__, ret);
-		ret = regulator_enable(l18);
-		if (ret) {
-			pr_err("%s: error enable l18 ret=%d\n", __func__, ret);
-			return -1;
-		}
+
+	l18 = regulator_get(NULL, "8921_l18");
+	if (IS_ERR(l18)) {
+		pr_err("%s: error regulator_get\n", __func__);
+		return -1;
 	}
-	else {
-		l27 = regulator_get(NULL, "8921_l27");
-		if (IS_ERR(l27)) {
-			pr_err("%s: error regulator_get\n", __func__);
-			return -1;
-		}
-		ret = regulator_set_voltage(l27, 1100000, 1100000);
-		if (ret)
-			pr_err("%s: error set voltage ret=%d\n", __func__, ret);
-		ret = regulator_enable(l27);
-		if (ret) {
-			pr_err("%s: error enable l27 ret=%d\n", __func__, ret);
-			return -1;
-		}
+	ret = regulator_set_voltage(l18, 1100000, 1100000);
+	if (ret)
+		pr_err("%s: error set voltage ret=%d\n", __func__, ret);
+	ret = regulator_enable(l18);
+	if (ret) {
+		pr_err("%s: error enable l18 ret=%d\n", __func__, ret);
+		return -1;
 	}
 	return 0;
 }
@@ -4319,6 +4192,15 @@
 		.debounce_interval = 5,
 	},
 	{
+		.code           = KEY_HOMEPAGE,
+		.gpio           = GPIO_KEY_HOME,
+		.desc           = "home_key",
+		.active_low     = 1,
+		.type		= EV_KEY,
+		.wakeup		= 1,
+		.debounce_interval = 5,
+	},
+	{
 		.code           = KEY_MENU,
 		.gpio           = GPIO_KEY_MENU,
 		.desc           = "menu_key",
@@ -4336,15 +4218,6 @@
 		.wakeup		= 0,
 		.debounce_interval = 5,
 	},
-	{
-		.code           = KEY_HOMEPAGE,
-		.gpio           = GPIO_KEY_HOME,
-		.desc           = "home_key",
-		.active_low     = 1,
-		.type		= EV_KEY,
-		.wakeup		= 1,
-		.debounce_interval = 5,
-	},
 };
 
 static struct gpio_keys_platform_data gpio_keys_data = {
@@ -5062,6 +4935,8 @@
 	apq8064_i2c_init();
 	register_i2c_devices();
 
+	apq8064_device_qup_spi_gsbi5.dev.platform_data =
+						&apq8064_qup_spi_gsbi5_pdata;
 	apq8064_init_pmic();
 	if (machine_is_apq8064_liquid())
 		msm_otg_pdata.mhl_enable = true;
@@ -5087,6 +4962,13 @@
 		platform_add_devices(common_not_mpq_devices,
 			ARRAY_SIZE(common_not_mpq_devices));
 	
+#ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
+	if (system_rev < 9)
+		platform_device_register(&touchkey_i2c_gpio_device);
+	else
+		platform_device_register(&touchkey_i2c_gpio_device_2);
+#endif
+
 	enable_ddr3_regulator();
 	msm_hsic_pdata.swfi_latency =
 		msm_rpmrs_levels[0].latency_us;
@@ -5194,14 +5076,8 @@
 	pm8xxx_gpio_config(GPIO_KEY_BACK, &param);
 }
 
-static void __init nfc_gpio_rev_init(void)
-{
-	if (system_rev < BOARD_REV14)
-		bcm2079x_i2c_pdata.wake_gpio = GPIO_NFC_FIRMWARE;
-}
 static void __init samsung_jf_init(void)
 {
-	int ret = -1;
 #ifdef CONFIG_SEC_DEBUG
 	sec_debug_init();
 #endif
@@ -5231,12 +5107,6 @@
 						ARRAY_SIZE(spi_board_info));
 #endif
 	}
-#if 1
-	apq8064_device_qup_spi_gsbi5.dev.platform_data =
-						&apq8064_qup_spi_gsbi5_pdata;
-    ret = spi_register_board_info(eeprom_spi_info,
-		ARRAY_SIZE(eeprom_spi_info));
-#endif
 	apq8064_init_fb();
 	apq8064_init_gpu();
 	platform_add_devices(apq8064_footswitch, apq8064_num_footswitch);
@@ -5248,7 +5118,6 @@
 	msm8960_init_battery();
 #endif
 #ifdef CONFIG_SENSORS_SSP
-	clear_ssp_gpio();
 	sensor_power_on_vdd(SNS_PWR_ON, SNS_PWR_ON);
 	initialize_ssp_gpio();
 #endif
@@ -5263,9 +5132,7 @@
 #endif
 #ifdef CONFIG_BCM2079X_NFC_I2C
 	bcm2079x_init();
-	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jactive_eur-gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_eur-gpiomux.c
--- mach-msm/board-jactive_eur-gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jactive_eur-gpiomux.c	2013-12-17 17:08:05.610151166 -0800
@@ -429,17 +429,6 @@
 	.pull = GPIOMUX_PULL_NONE,
 };
 
-static struct gpiomux_setting gsbi2_suspend_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct gpiomux_setting mcu_chg_cfg = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
 static struct gpiomux_setting gsbi2 = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_8MA,
@@ -452,13 +441,11 @@
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
-#if 0
 static struct gpiomux_setting hdmi_active_1_cfg = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_2MA,
 	.pull = GPIOMUX_PULL_UP,
 };
-#endif
 
 static struct gpiomux_setting hdmi_active_2_cfg = {
 	.func = GPIOMUX_FUNC_1,
@@ -491,6 +478,63 @@
 };
 
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
+static struct gpiomux_setting cyts_sleep_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting cyts_sleep_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_6MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct gpiomux_setting cyts_int_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_UP,
+};
+
+static struct gpiomux_setting cyts_int_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+
+static struct msm_gpiomux_config cyts_gpio_configs[] __initdata = {
+	{	/* TS INTERRUPT */
+		.gpio = 6,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cyts_int_act_cfg,
+			[GPIOMUX_SUSPENDED] = &cyts_int_sus_cfg,
+		},
+	},
+	{	/* TS SLEEP */
+		.gpio = 33,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cyts_sleep_act_cfg,
+			[GPIOMUX_SUSPENDED] = &cyts_sleep_sus_cfg,
+		},
+	},
+};
+static struct msm_gpiomux_config cyts_gpio_alt_config[] __initdata = {
+	{	/* TS INTERRUPT */
+		.gpio = 6,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cyts_int_act_cfg,
+			[GPIOMUX_SUSPENDED] = &cyts_int_sus_cfg,
+		},
+	},
+	{	/* TS SLEEP */
+		.gpio = 12,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cyts_sleep_act_cfg,
+			[GPIOMUX_SUSPENDED] = &cyts_sleep_sus_cfg,
+		},
+	},
+};
+
 static struct gpiomux_setting hsic_act_cfg = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_8MA,
@@ -623,14 +667,14 @@
 };
 #endif
 static struct msm_gpiomux_config apq8064_hdmi_configs[] __initdata = {
-	/*{
+	{
 		.gpio = 69,
 		.settings = {
 			[GPIOMUX_ACTIVE]    = &hdmi_active_1_cfg,
 			[GPIOMUX_SUSPENDED] = &hdmi_suspend_cfg,
 		},
-	},*/
-	/*{
+	},
+	{
 		.gpio = 70,
 		.settings = {
 			[GPIOMUX_ACTIVE]    = &hdmi_active_1_cfg,
@@ -643,7 +687,7 @@
 			[GPIOMUX_ACTIVE]    = &hdmi_active_1_cfg,
 			[GPIOMUX_SUSPENDED] = &hdmi_suspend_cfg,
 		},
-	},*/
+	},
 	{
 		.gpio = 72,
 		.settings = {
@@ -653,16 +697,6 @@
 	},
 };
 
-static struct msm_gpiomux_config sensorhub_configs[] __initdata = {
-	{
-		.gpio      = 69,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mcu_chg_cfg,
-			[GPIOMUX_ACTIVE] = &mcu_chg_cfg,
-		},
-	},
-};
-
 static struct msm_gpiomux_config apq8064_gsbi_configs[] __initdata = {
 	{
 		.gpio      = 8,			/* GSBI3 I2C QUP SDA */
@@ -691,69 +725,49 @@
 		},
 	},
 	{
-		.gpio      = 21,		/* GSBI1 QUP I2C_CLK */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gpio_i2c_config_sus,
-			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
-		},
-	},
-	{
-		.gpio      = 20,		/* GSBI1 QUP I2C_DATA */
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &gpio_i2c_config_sus,
-			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
-		},
-	},
-	{
 		.gpio      = 24,	/* GSBI2 I2C QUP SDA */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi2_suspend_cfg,
+			[GPIOMUX_SUSPENDED] = &gsbi2,
 			[GPIOMUX_ACTIVE] = &gsbi2,
 		},
 	},
 	{
 		.gpio      = 25,	/* GSBI2 I2C QUP SCL */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi2_suspend_cfg,
+			[GPIOMUX_SUSPENDED] = &gsbi2,
 			[GPIOMUX_ACTIVE] = &gsbi2,
 		},
 	},
 	{
 		.gpio      = 51,		/* GSBI5 QUP SPI_DATA_MOSI */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
 		},
 	},
 	{
 		.gpio      = 52,		/* GSBI5 QUP SPI_DATA_MISO */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
 		},
 	},
 	{
 		.gpio      = 53,		/* Funny CS0 */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
 		},
 	},
 	{
 		.gpio      = 54,		/* GSBI5 QUP SPI_CLK */
 		.settings = {
-			[GPIOMUX_SUSPENDED] = &gsbi5_suspended_cfg,
-			[GPIOMUX_ACTIVE] = &gsbi5_active_cfg,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_config,
 		},
 	},
-#if !defined(CONFIG_USB_EHCI_MSM_HSIC)
 	{
 		.gpio      = 30,		/* FP CS */
 		.settings = {
 			[GPIOMUX_SUSPENDED] = &gpio_spi_cs_config,
 		},
 	},
-#endif
 	{
 		.gpio      = 32,		/* EPM CS */
 		.settings = {
@@ -761,6 +775,12 @@
 		},
 	},
 	{
+		.gpio      = 53,		/* NOR CS */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_spi_cs_config,
+		},
+	},
+	{
 		.gpio      = 82,	/* GSBI7 UART2 TX */
 		.settings = {
 			[GPIOMUX_SUSPENDED] = &gsbi7_func2_cfg,
@@ -772,6 +792,20 @@
 			[GPIOMUX_SUSPENDED] = &gsbi7_func1_cfg,
 		},
 	},
+	{
+		.gpio      = 21,		/* GSBI1 QUP I2C_CLK */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config_sus,
+			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
+		},
+	},
+	{
+		.gpio      = 20,		/* GSBI1 QUP I2C_DATA */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config_sus,
+			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
+		},
+	},
 };
 
 static struct msm_gpiomux_config apq8064_slimbus_config[] __initdata = {
@@ -1413,8 +1447,6 @@
 				ARRAY_SIZE(apq8064_gsbi_configs));
 	}
 
-	msm_gpiomux_install(sensorhub_configs,
-			ARRAY_SIZE(sensorhub_configs));
 	msm_gpiomux_install(apq8064_slimbus_config,
 			ARRAY_SIZE(apq8064_slimbus_config));
 
@@ -1445,6 +1477,16 @@
 					ARRAY_SIZE(mdm_configs));
 	}
 
+	if (machine_is_apq8064_mtp()|| machine_is_JF()) {
+		if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
+			msm_gpiomux_install(cyts_gpio_alt_config,
+					ARRAY_SIZE(cyts_gpio_alt_config));
+		} else {
+			msm_gpiomux_install(cyts_gpio_configs,
+					ARRAY_SIZE(cyts_gpio_configs));
+		}
+	}
+
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
 	if (machine_is_apq8064_mtp()|| machine_is_JF())
 		msm_gpiomux_install(apq8064_hsic_configs,
diff --unified -r mach-msm/board-jf_att.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_att.c
--- mach-msm/board-jf_att.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_att.c	2013-12-17 17:08:05.614151159 -0800
@@ -150,6 +150,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -459,7 +463,7 @@
 		pr_info("%s irda_vreg 1.8V off is finished.\n", __func__);
 	}
 }
-
+#if defined(CONFIG_IRDA_MC96)
 static struct i2c_gpio_platform_data mc96_i2c_gpio_data = {
 	.udelay			= 2,
 	.sda_is_open_drain	= 0,
@@ -485,6 +489,7 @@
 		.platform_data = &mc96_pdata,
 	},
 };
+#endif /* CONFIG_IRDA_MC96 */
 #endif
 
 #ifdef CONFIG_KERNEL_MSM_CONTIG_MEM_REGION
@@ -1015,7 +1020,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1066,47 +1079,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1237,12 +1209,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1282,21 +1248,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3400,6 +3354,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3436,11 +3397,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3520,9 +3486,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3535,9 +3501,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3550,9 +3516,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -5181,6 +5147,24 @@
 			&vps_sound_en);
 
 }
+
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5284,11 +5268,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);	
 	samsung_sys_class_init();
 
 #ifdef CONFIG_MFD_MAX77693
@@ -5417,7 +5406,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_cri.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_cri.c
--- mach-msm/board-jf_cri.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_cri.c	2013-12-17 17:08:05.614151159 -0800
@@ -144,6 +144,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -962,7 +966,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1013,47 +1025,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1184,12 +1155,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1229,21 +1194,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3311,6 +3264,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3347,11 +3307,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3431,9 +3396,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3446,9 +3411,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3461,9 +3426,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3989,6 +3954,7 @@
 	&msm_rotator_device,
 #endif
 	&msm8064_pc_cntr,
+	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -4364,11 +4330,7 @@
 		.active_low     = 1,
 		.type		= EV_KEY,
 		.wakeup		= 0,
-#ifdef CONFIG_SEC_FACTORY
-		.debounce_interval = 10,
-#else
 		.debounce_interval = 5,
-#endif
 	},
 	{
 		.code           = KEY_VOLUMEDOWN,
@@ -4377,11 +4339,7 @@
 		.active_low     = 1,
 		.type		= EV_KEY,
 		.wakeup		= 0,
-#ifdef CONFIG_SEC_FACTORY
-		.debounce_interval = 10,
-#else
 		.debounce_interval = 5,
-#endif
 	},
 	{
 		.code           = KEY_HOMEPAGE,
@@ -4390,11 +4348,7 @@
 		.active_low     = 1,
 		.type		= EV_KEY,
 		.wakeup		= 1,
-#ifdef CONFIG_SEC_FACTORY
-		.debounce_interval = 10,
-#else
 		.debounce_interval = 5,
-#endif
 	},
 };
 
@@ -5079,6 +5033,23 @@
 }
 #endif
 
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5182,11 +5153,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 	
 #if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI) || defined(CONFIG_TOUCHSCREEN_ATMEL_MXTS)
@@ -5315,7 +5291,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_dcm.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_dcm.c
--- mach-msm/board-jf_dcm.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_dcm.c	2013-12-17 17:08:05.614151159 -0800
@@ -158,6 +158,10 @@
 
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -970,7 +974,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1021,47 +1033,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1192,12 +1163,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1237,21 +1202,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3576,6 +3529,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3612,11 +3572,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3696,9 +3661,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3711,9 +3676,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3726,9 +3691,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -4313,6 +4278,7 @@
 	&msm_rotator_device,
 #endif
 	&msm8064_pc_cntr,
+	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -4691,11 +4657,7 @@
 		.active_low     = 1,
 		.type		= EV_KEY,
 		.wakeup		= 0,
-#ifdef CONFIG_SEC_FACTORY
-		.debounce_interval = 10,
-#else
 		.debounce_interval = 5,
-#endif
 	},
 	{
 		.code           = KEY_VOLUMEDOWN,
@@ -4704,11 +4666,7 @@
 		.active_low     = 1,
 		.type		= EV_KEY,
 		.wakeup		= 0,
-#ifdef CONFIG_SEC_FACTORY
-		.debounce_interval = 10,
-#else
 		.debounce_interval = 5,
-#endif
 	},
 	{
 		.code           = KEY_HOMEPAGE,
@@ -4717,11 +4675,7 @@
 		.active_low     = 1,
 		.type		= EV_KEY,
 		.wakeup		= 1,
-#ifdef CONFIG_SEC_FACTORY
-		.debounce_interval = 10,
-#else
 		.debounce_interval = 5,
-#endif
 	},
 };
 
@@ -5380,6 +5334,24 @@
 			&vps_sound_en);
 
 }
+
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5483,11 +5455,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 	
 #ifdef CONFIG_MFD_MAX77693
@@ -5620,7 +5597,6 @@
 #ifdef CONFIG_BCM2079X_NFC_I2C
 	bcm2079x_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_eur.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_eur.c
--- mach-msm/board-jf_eur.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_eur.c	2013-12-17 17:08:05.614151159 -0800
@@ -146,6 +146,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -961,7 +965,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1012,47 +1024,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1201,12 +1172,6 @@
 */
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1246,21 +1211,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3355,6 +3308,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3391,11 +3351,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3475,9 +3440,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3490,9 +3455,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3505,9 +3470,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -5116,6 +5081,24 @@
 			&vps_sound_en);
 
 }
+
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5219,11 +5202,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 
 #ifdef CONFIG_MFD_MAX77693
@@ -5357,7 +5345,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_ktt.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_ktt.c
--- mach-msm/board-jf_ktt.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_ktt.c	2013-12-17 17:08:05.614151159 -0800
@@ -150,6 +150,10 @@
 #include <mach/tdmb_pdata.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -987,7 +991,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1038,47 +1050,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1209,12 +1180,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1254,21 +1219,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3504,6 +3457,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3540,11 +3500,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3624,9 +3589,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3639,9 +3604,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3654,9 +3619,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -4204,6 +4169,7 @@
 	&msm_rotator_device,
 #endif
 	&msm8064_pc_cntr,
+	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -5296,6 +5262,24 @@
 			&vps_sound_en);
 
 }
+
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5399,11 +5383,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);	
 	samsung_sys_class_init();
 	
 #if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI) || defined(CONFIG_TOUCHSCREEN_ATMEL_MXTS)
@@ -5529,7 +5518,6 @@
 #ifdef CONFIG_BCM2079X_NFC_I2C
 	bcm2079x_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_lgt.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_lgt.c
--- mach-msm/board-jf_lgt.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_lgt.c	2013-12-17 17:08:05.618151151 -0800
@@ -148,6 +148,10 @@
 #include <mach/tdmb_pdata.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -985,7 +989,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1036,47 +1048,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1207,12 +1178,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1252,21 +1217,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3490,6 +3443,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3526,11 +3486,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3610,9 +3575,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3625,9 +3590,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3640,9 +3605,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -4190,6 +4155,7 @@
 	&msm_rotator_device,
 #endif
 	&msm8064_pc_cntr,
+	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -5292,6 +5258,23 @@
 }
 #endif
 
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5395,11 +5378,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 	
 #if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI) || defined(CONFIG_TOUCHSCREEN_ATMEL_MXTS)
@@ -5525,7 +5513,6 @@
 #ifdef CONFIG_BCM2079X_NFC_I2C
 	bcm2079x_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_skt.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_skt.c
--- mach-msm/board-jf_skt.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_skt.c	2013-12-17 17:08:05.618151151 -0800
@@ -150,6 +150,10 @@
 #include <mach/tdmb_pdata.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -987,7 +991,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1038,47 +1050,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1209,12 +1180,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1254,21 +1219,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3504,6 +3457,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3540,11 +3500,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3624,9 +3589,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3639,9 +3604,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3654,9 +3619,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -4204,6 +4169,7 @@
 	&msm_rotator_device,
 #endif
 	&msm8064_pc_cntr,
+	&msm8064_cpu_slp_status,
 	&sec_device_jack,
 #ifdef CONFIG_SENSORS_SSP_C12SD
 	&uv_device,
@@ -5296,6 +5262,24 @@
 			&vps_sound_en);
 
 }
+
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5399,11 +5383,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 	
 #if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI) || defined(CONFIG_TOUCHSCREEN_ATMEL_MXTS)
@@ -5529,7 +5518,6 @@
 #ifdef CONFIG_BCM2079X_NFC_I2C
 	bcm2079x_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_spr.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_spr.c
--- mach-msm/board-jf_spr.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_spr.c	2013-12-17 17:08:05.618151151 -0800
@@ -144,6 +144,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -962,7 +966,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1013,47 +1025,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1184,12 +1155,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1229,21 +1194,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3314,6 +3267,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3350,11 +3310,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3434,9 +3399,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3449,9 +3414,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3464,9 +3429,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -5082,6 +5047,23 @@
 }
 #endif
 
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5185,11 +5167,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 
 #ifdef CONFIG_MFD_MAX77693
@@ -5318,7 +5305,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_tmo.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_tmo.c
--- mach-msm/board-jf_tmo.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_tmo.c	2013-12-17 17:08:05.618151151 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -80,7 +80,6 @@
 #include <linux/msm_tsens.h>
 #include <mach/msm_xo.h>
 #include <mach/msm_rtb.h>
-#include <mach/msm_serial_hs.h>
 #include <sound/cs8427.h>
 #include <media/gpio-ir-recv.h>
 #include <linux/fmem.h>
@@ -107,7 +106,6 @@
 #include "pm-boot.h"
 #include "devices-msm8x60.h"
 #include "smd_private.h"
-#include "sysmon.h"
 
 #ifdef CONFIG_SEC_DEBUG
 #include <mach/sec_debug.h>
@@ -146,6 +144,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -168,13 +170,12 @@
 
 #ifdef CONFIG_MSM_MULTIMEDIA_USE_ION
 #define HOLE_SIZE		0x20000
-#define MSM_ION_MFC_META_SIZE  0x40000 /* 256 Kbytes */
 #define MSM_CONTIG_MEM_SIZE  0x65000
 #ifdef CONFIG_MSM_IOMMU
 #define MSM_ION_MM_SIZE		0x6600000    /* 56MB(0x3800000) -> 98MB -> 102MB */
 #define MSM_ION_SF_SIZE		0
 #define MSM_ION_QSECOM_SIZE	0x1700000    /* 7.5MB(0x780000) -> 23MB */
-#define MSM_ION_HEAP_NUM	8
+#define MSM_ION_HEAP_NUM	7
 #else
 #define MSM_ION_MM_SIZE		MSM_PMEM_ADSP_SIZE
 #define MSM_ION_SF_SIZE		MSM_PMEM_SIZE
@@ -182,7 +183,7 @@
 #define MSM_ION_HEAP_NUM	8
 #endif
 #define MSM_ION_MM_FW_SIZE	(0x200000 - HOLE_SIZE) /* (2MB - 128KB) */
-#define MSM_ION_MFC_SIZE	(SZ_8K + MSM_ION_MFC_META_SIZE)
+#define MSM_ION_MFC_SIZE	SZ_8K
 #define MSM_ION_AUDIO_SIZE	MSM_PMEM_AUDIO_SIZE
 #else
 #define MSM_CONTIG_MEM_SIZE  0x110C000
@@ -194,7 +195,6 @@
 #define MAX_FIXED_AREA_SIZE	0x10000000
 #define MSM_MM_FW_SIZE		(0x200000 - HOLE_SIZE)
 #define APQ8064_FW_START	APQ8064_FIXED_AREA_START
-#define MSM_ION_ADSP_SIZE	SZ_8M
 
 #define QFPROM_RAW_FEAT_CONFIG_ROW0_MSB     (MSM_QFPROM_BASE + 0x23c)
 #define QFPROM_RAW_OEM_CONFIG_ROW0_LSB      (MSM_QFPROM_BASE + 0x220)
@@ -517,13 +517,6 @@
 #endif /* CONFIG_MSM_MULTIMEDIA_USE_ION */
 #endif /* CONFIG_ANDROID_PMEM */
 
-#ifdef CONFIG_BATTERY_BCL
-static struct platform_device battery_bcl_device = {
-	.name = "battery_current_limit",
-	.id = -1,
-	};
-#endif
-
 struct fmem_platform_data apq8064_fmem_pdata = {
 };
 
@@ -542,8 +535,6 @@
 {
 #if defined(CONFIG_MSM_RTB)
 	apq8064_reserve_table[MEMTYPE_EBI1].size += apq8064_rtb_pdata.size;
-	pr_info("mem_map: rtb reserved with size 0x%x in pool\n",
-			apq8064_rtb_pdata.size);
 #endif
 }
 
@@ -577,8 +568,6 @@
 	reserve_memory_for(&android_pmem_audio_pdata);
 #endif /*CONFIG_MSM_MULTIMEDIA_USE_ION*/
 	apq8064_reserve_table[MEMTYPE_EBI1].size += msm_contig_mem_size;
-	pr_info("mem_map: contig_mem reserved with size 0x%x in pool\n",
-			msm_contig_mem_size);
 #endif /*CONFIG_ANDROID_PMEM*/
 }
 
@@ -635,14 +624,6 @@
 	}
 };
 
-static struct platform_device ion_adsp_heap_device = {
-	.name = "ion-adsp-heap-device",
-	.id = -1,
-	.dev = {
-		.dma_mask = &msm_dmamask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	}
-};
 /**
  * These heaps are listed in the order they will be allocated. Due to
  * video hardware restrictions and content protection the FW heap has to
@@ -717,15 +698,6 @@
 			.memory_type = ION_EBI_TYPE,
 			.extra_data = (void *) &co_apq8064_ion_pdata,
 		},
-		{
-			.id     = ION_ADSP_HEAP_ID,
-			.type   = ION_HEAP_TYPE_DMA,
-			.name   = ION_ADSP_HEAP_NAME,
-			.size   = MSM_ION_ADSP_SIZE,
-			.memory_type = ION_EBI_TYPE,
-			.extra_data = (void *) &co_apq8064_ion_pdata,
-			.priv = &ion_adsp_heap_device.dev,
-		},
 #endif
 };
 
@@ -767,9 +739,6 @@
 
 	ret = memblock_remove(reserve_info->fixed_area_start,
 		reserve_info->fixed_area_size);
-	pr_info("mem_map: fixed_area reserved at 0x%lx with size 0x%lx\n",
-			reserve_info->fixed_area_start,
-			reserve_info->fixed_area_size);
 	BUG_ON(ret);
 #endif
 }
@@ -858,7 +827,7 @@
 
 			if (fixed_position != NOT_FIXED)
 				fixed_size += heap->size;
-			else if (!use_cma)
+			else
 				reserve_mem_for_ion(MEMTYPE_EBI1, heap->size);
 
 			if (fixed_position == FIXED_LOW) {
@@ -902,9 +871,6 @@
 		BUG_ON(!IS_ALIGNED(fixed_low_size + HOLE_SIZE, SECTION_SIZE));
 		ret = memblock_remove(fixed_low_start,
 				      fixed_low_size + HOLE_SIZE);
-		pr_info("mem_map: fixed_low_area reserved at 0x%lx with size \
-				0x%x\n", fixed_low_start,
-				fixed_low_size + HOLE_SIZE);
 		BUG_ON(ret);
 	}
 
@@ -915,9 +881,6 @@
 	} else {
 		BUG_ON(!IS_ALIGNED(fixed_middle_size, SECTION_SIZE));
 		ret = memblock_remove(fixed_middle_start, fixed_middle_size);
-		pr_info("mem_map: fixed_middle_area reserved at 0x%lx with \
-				size 0x%x\n", fixed_middle_start,
-				fixed_middle_size);
 		BUG_ON(ret);
 	}
 
@@ -929,9 +892,6 @@
 		/* This is the end of the fixed area so it's okay to round up */
 		fixed_high_size = ALIGN(fixed_high_size, SECTION_SIZE);
 		ret = memblock_remove(fixed_high_start, fixed_high_size);
-		pr_info("mem_map: fixed_high_area reserved at 0x%lx with size \
-				0x%x\n", fixed_high_start,
-				fixed_high_size);
 		BUG_ON(ret);
 	}
 
@@ -987,23 +947,8 @@
 }
 
 #ifdef CONFIG_ANDROID_RAM_CONSOLE
-static char bootreason[128] = {0,};
-int __init device_boot_reason(char *s)
-{
-	int n;
-
-	if (*s == '=')
-		s++;
-	n = snprintf(bootreason, sizeof(bootreason),
-		 "Boot info:\n"
-		 "Last boot reason: %s\n", s);
-	bootreason[n] = '\0';
-	return 1;
-}
-__setup("bootreason", device_boot_reason);
-
 static struct ram_console_platform_data ram_console_pdata = {
-	.bootinfo = bootreason,
+	.bootinfo = NULL,
 };
 
 static struct platform_device ram_console_device = {
@@ -1020,7 +965,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1045,8 +998,6 @@
 	total = apq8064_cache_dump_pdata.l1_size +
 		apq8064_cache_dump_pdata.l2_size;
 	apq8064_reserve_table[MEMTYPE_EBI1].size += total;
-	pr_info("mem_map: cache_dump reserved with size 0x%x in pool\n",
-			total);
 #endif
 }
 
@@ -1245,6 +1196,7 @@
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
+
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
 /* Bandwidth requests (zero) if no vote placed */
@@ -3114,7 +3066,7 @@
 
 static struct gpiomux_setting mdm2ap_status_gpio_run_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
@@ -3123,78 +3075,10 @@
 	.ramdump_delay_ms = 2000,
 	.early_power_on = 1,
 	.sfr_query = 1,
-	.send_shdn = 1,
-	.vddmin_resource = &mdm_vddmin_rscs,
-	.peripheral_platform_device = &apq8064_device_hsic_host,
-	.ramdump_timeout_ms = 120000,
-	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM,
-};
-
-static struct mdm_platform_data amdm_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-	.early_power_on = 1,
-	.sfr_query = 1,
-	.send_shdn = 1,
-	.vddmin_resource = &mdm_vddmin_rscs,
-	.peripheral_platform_device = &apq8064_device_hsic_host,
-	.ramdump_timeout_ms = 120000,
-	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM,
-	.no_a2m_errfatal_on_ssr = 1,
-};
-
-static struct mdm_vddmin_resource bmdm_vddmin_rscs = {
-	.rpm_id = MSM_RPM_ID_VDDMIN_GPIO,
-	.ap2mdm_vddmin_gpio = 30,
-	.modes  = 0x03,
-	.drive_strength = 8,
-	.mdm2ap_vddmin_gpio = 64,
-};
-
-static struct mdm_platform_data bmdm_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-	.sfr_query = 1,
-	.send_shdn = 1,
-	.vddmin_resource = &bmdm_vddmin_rscs,
-	.peripheral_platform_device = &apq8064_device_ehci_host3,
-	.ramdump_timeout_ms = 120000,
-	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM2,
-	.no_a2m_errfatal_on_ssr = 1,
-};
-
-static struct mdm_platform_data sglte2_mdm_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-	.early_power_on = 1,
-	.sfr_query = 1,
 	.vddmin_resource = &mdm_vddmin_rscs,
 	.peripheral_platform_device = &apq8064_device_hsic_host,
 	.ramdump_timeout_ms = 120000,
 	.mdm2ap_status_gpio_run_cfg = &mdm2ap_status_gpio_run_cfg,
-	.sysmon_subsys_id_valid = 1,
-	.sysmon_subsys_id = SYSMON_SS_EXT_MODEM,
-	.no_a2m_errfatal_on_ssr = 1,
-	.subsys_name = "external_modem_mdm",
-};
-
-static struct mdm_platform_data sglte2_qsc_platform_data = {
-	.mdm_version = "3.0",
-	.ramdump_delay_ms = 2000,
-     /* delay between two PS_HOLDs */
-	.ps_hold_delay_ms = 500,
-	.ramdump_timeout_ms = 600000,
-	.no_powerdown_after_ramdumps = 1,
-	.image_upgrade_supported = 1,
-	.no_a2m_errfatal_on_ssr = 1,
-	.kpd_not_inverted = 1,
-	.subsys_name = "external_modem",
 };
 
 static struct tsens_platform_data apq_tsens_pdata  = {
@@ -3216,9 +3100,6 @@
 	.limit_temp_degC = 60,
 	.temp_hysteresis_degC = 10,
 	.freq_step = 2,
-	.core_limit_temp_degC = 80,
-	.core_temp_hysteresis_degC = 10,
-	.core_control_mask = 0xe,
 };
 
 #define MSM_SHARED_RAM_PHYS 0x80000000
@@ -3405,21 +3286,6 @@
 	0x24, 0x30, 0x0f,
 };
 
-/* 8064AB has a different command to assert apc_pdn */
-static uint8_t spm_power_collapse_without_rpm_krait_v3[] __initdata = {
-	0x00, 0x24, 0x84, 0x10,
-	0x09, 0x03, 0x01,
-	0x10, 0x84, 0x30, 0x0C,
-	0x24, 0x30, 0x0f,
-};
-
-static uint8_t spm_power_collapse_with_rpm_krait_v3[] __initdata = {
-	0x00, 0x24, 0x84, 0x10,
-	0x09, 0x07, 0x01, 0x0B,
-	0x10, 0x84, 0x30, 0x0C,
-	0x24, 0x30, 0x0f,
-};
-
 static struct msm_spm_seq_entry msm_spm_boot_cpu_seq_list[] __initdata = {
 	[0] = {
 		.mode = MSM_SPM_MODE_CLOCK_GATING,
@@ -3577,27 +3443,6 @@
 	},
 };
 
-static void __init apq8064ab_update_krait_spm(void)
-{
-	int i;
-
-	/* Update the SPM sequences for SPC and PC */
-	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
-		int j;
-		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
-		for (j = 0; j < pdata->num_modes; j++) {
-			if (pdata->modes[j].cmd ==
-					spm_power_collapse_without_rpm)
-				pdata->modes[j].cmd =
-				spm_power_collapse_without_rpm_krait_v3;
-			else if (pdata->modes[j].cmd ==
-					spm_power_collapse_with_rpm)
-				pdata->modes[j].cmd =
-				spm_power_collapse_with_rpm_krait_v3;
-		}
-	}
-}
-
 static void __init apq8064_init_buses(void)
 {
 	msm_bus_rpm_set_mt_mask();
@@ -3934,14 +3779,13 @@
 static struct platform_device *common_not_mpq_devices[] __initdata = {
 	&apq8064_device_qup_i2c_gsbi1,
 	&apq8064_device_qup_i2c_gsbi3,
+	&apq8064_device_qup_i2c_gsbi4,
 };
 
 static struct platform_device *early_common_devices[] __initdata = {
 	&apq8064_device_acpuclk,
 	&apq8064_device_dmov,
-#if !defined(CONFIG_MACH_JACTIVE_ATT) && !defined(CONFIG_MACH_JACTIVE_EUR)
 	&apq8064_device_qup_spi_gsbi5,
-#endif	
 };
 
 static struct platform_device *pm8921_common_devices[] __initdata = {
@@ -3950,6 +3794,7 @@
 	&apq8064_device_ext_3p3v_vreg,
 	&apq8064_device_ssbi_pmic1,
 	&apq8064_device_ssbi_pmic2,
+	&apq8064_device_ext_ts_sw_vreg,
 };
 
 static struct platform_device *pm8917_common_devices[] __initdata = {
@@ -3957,6 +3802,7 @@
 	&apq8064_device_ext_3p3v_vreg,
 	&apq8064_device_ssbi_pmic1,
 	&apq8064_device_ssbi_pmic2,
+	&apq8064_device_ext_ts_sw_vreg,
 };
 
 static struct platform_device *common_devices[] __initdata = {
@@ -3969,9 +3815,6 @@
 	&apq8064_device_hsusb_host,
 	&android_usb_device,
 	&msm_device_wcnss_wlan,
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
-	&apq8064_device_qup_spi_gsbi5,
-#endif	
 	&msm_device_iris_fm,
 	&apq8064_fmem_device,
 #ifdef CONFIG_ANDROID_PMEM
@@ -4213,20 +4056,6 @@
 }
 late_initcall(rf4ce_gpio_init);
 
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data mpq8064_gsbi6_uartdm_pdata = {
-	.config_gpio		= 4,
-	.uart_tx_gpio		= 14,
-	.uart_rx_gpio		= 15,
-	.uart_cts_gpio		= 16,
-	.uart_rfr_gpio		= 17,
-	.inject_rx_on_wakeup	= 1,
-	.rx_to_inject		= 0xFD,
-};
-#else
-static struct msm_serial_hs_platform_data msm_uart_dm9_pdata;
-#endif
-
 static struct platform_device *mpq_devices[] __initdata = {
 	&msm_device_sps_apq8064,
 	&mpq8064_device_qup_i2c_gsbi5,
@@ -4465,13 +4294,8 @@
 					&apq8064_i2c_qup_gsbi3_pdata;
 	apq8064_device_qup_i2c_gsbi1.dev.platform_data =
 					&apq8064_i2c_qup_gsbi1_pdata;
-
-	/* Add GSBI4 I2C pdata for non-fusion3 SGLTE2 */
-	if (socinfo_get_platform_subtype() !=
-				PLATFORM_SUBTYPE_SGLTE2) {
-		apq8064_device_qup_i2c_gsbi4.dev.platform_data =
+	apq8064_device_qup_i2c_gsbi4.dev.platform_data =
 					&apq8064_i2c_qup_gsbi4_pdata;
-	}
 	mpq8064_device_qup_i2c_gsbi5.dev.platform_data =
 					&mpq8064_i2c_qup_gsbi5_pdata;
 	apq8064_device_qup_i2c_gsbi2.dev.platform_data =
@@ -5008,7 +4832,6 @@
 		apq8064_camera_board_info.board_info,
 		apq8064_camera_board_info.num_i2c_board_info,
 	};
-
 	struct i2c_registry apq8064_front_camera_i2c_devices = {
 		I2C_SURF | I2C_FFA | I2C_LIQUID | I2C_RUMI,
 		APQ_8064_GSBI7_QUP_I2C_BUS_ID,
@@ -5056,6 +4879,20 @@
 	}
 }
 
+static void enable_ddr3_regulator(void)
+{
+	static struct regulator *ext_ddr3;
+
+	/* Use MPP7 output state as a flag for PCDDR3 presence. */
+	if (gpio_get_value_cansleep(PM8921_MPP_PM_TO_SYS(7)) > 0) {
+		ext_ddr3 = regulator_get(NULL, "ext_ddr3");
+		if (IS_ERR(ext_ddr3) || ext_ddr3 == NULL)
+			pr_err("Could not get MPP7 regulator\n");
+		else
+			regulator_enable(ext_ddr3);
+	}
+}
+
 static void enable_avc_i2c_bus(void)
 {
 	int avc_i2c_en_mpp = PM8921_MPP_PM_TO_SYS(8);
@@ -5215,18 +5052,6 @@
 }
 #endif
 
-#ifdef CONFIG_SERIAL_MSM_HS
-static struct msm_serial_hs_platform_data apq8064_uartdm_gsbi4_pdata = {
-	.config_gpio	= 4,
-	.uart_tx_gpio	= 10,
-	.uart_rx_gpio	= 11,
-	.uart_cts_gpio	= 12,
-	.uart_rfr_gpio	= 13,
-};
-#else
-static struct msm_serial_hs_platform_data apq8064_uartdm_gsbi4_pdata;
-#endif
-
 static void __init apq8064ab_update_retention_spm(void)
 {
 	int i;
@@ -5246,7 +5071,7 @@
 
 static void __init apq8064_common_init(void)
 {
-	u32 platform_version = socinfo_get_platform_version();
+	u32 platform_version;
 
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 	int ret;
@@ -5257,16 +5082,6 @@
 		apq8064_pm8917_pdata_fixup();
 #endif
 	platform_device_register(&msm_gpio_device);
-	if (cpu_is_apq8064ab())
-		apq8064ab_update_krait_spm();
-	if (cpu_is_krait_v3()) {
-		msm_pm_set_tz_retention_flag(0);
-		apq8064ab_update_retention_spm();
-	} else {
-		msm_pm_set_tz_retention_flag(1);
-	}
-	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
-	msm_spm_l2_init(msm_spm_l2_data);
 	msm_tsens_early_init(&apq_tsens_pdata);
 	msm_thermal_init(&msm_thermal_pdata);
 	if (socinfo_init() < 0)
@@ -5308,22 +5123,12 @@
 	else
 		platform_add_devices(pm8917_common_devices,
 					ARRAY_SIZE(pm8917_common_devices));
-
-	if (!machine_is_apq8064_mtp())
-		platform_device_register(&apq8064_device_ext_ts_sw_vreg);
-
 	platform_add_devices(common_devices, ARRAY_SIZE(common_devices));
 	if (!(machine_is_mpq8064_cdp() || machine_is_mpq8064_hrd() ||
-			machine_is_mpq8064_dtv())) {
+			machine_is_mpq8064_dtv()))
 		platform_add_devices(common_not_mpq_devices,
 			ARRAY_SIZE(common_not_mpq_devices));
 
-		/* Add GSBI4 I2C Device for non-fusion3 platform */
-		if (socinfo_get_platform_subtype() !=
-					PLATFORM_SUBTYPE_SGLTE2) {
-			platform_device_register(&apq8064_device_qup_i2c_gsbi4);
-		}
-	}
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 		if (system_rev < 9)
 			platform_device_register(&touchkey_i2c_gpio_device);
@@ -5331,44 +5136,21 @@
 			platform_device_register(&touchkey_i2c_gpio_device_2);
 #endif
 
+	enable_ddr3_regulator();
 	msm_hsic_pdata.swfi_latency =
 		msm_rpmrs_levels[0].latency_us;
 	if (machine_is_apq8064_mtp() || machine_is_JF()) {
 		msm_hsic_pdata.log2_irq_thresh = 5,
 		apq8064_device_hsic_host.dev.platform_data = &msm_hsic_pdata;
 		device_initialize(&apq8064_device_hsic_host.dev);
-		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_DSDA2) {
-			apq8064_device_ehci_host3.dev.platform_data =
-				&msm_ehci_host_pdata3;
-			device_initialize(&apq8064_device_ehci_host3.dev);
-		}
 	}
 	apq8064_pm8xxx_gpio_mpp_init();
 	apq8064_init_mmc();
 
 	if (machine_is_apq8064_mtp()|| machine_is_JF()) {
-		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_DSDA2) {
-			amdm_8064_device.dev.platform_data =
-				&amdm_platform_data;
-			platform_device_register(&amdm_8064_device);
-			bmdm_8064_device.dev.platform_data =
-				&bmdm_platform_data;
-			platform_device_register(&bmdm_8064_device);
-		} else if (socinfo_get_platform_subtype() ==
-				   PLATFORM_SUBTYPE_SGLTE2) {
-			sglte_mdm_8064_device.dev.platform_data =
-				&sglte2_mdm_platform_data;
-			platform_device_register(&sglte_mdm_8064_device);
-			sglte2_qsc_8064_device.dev.platform_data =
-				&sglte2_qsc_platform_data;
-			platform_device_register(&sglte2_qsc_8064_device);
-
-			/* GSBI4 UART device for Primay IPC */
-			apq8064_uartdm_gsbi4_pdata.wakeup_irq = gpio_to_irq(11);
-			apq8064_device_uartdm_gsbi4.dev.platform_data =
-						&apq8064_uartdm_gsbi4_pdata;
-			platform_device_register(&apq8064_device_uartdm_gsbi4);
-		} else if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
+		mdm_8064_device.dev.platform_data = &mdm_platform_data;
+		platform_version = socinfo_get_platform_version();
+		if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
 			i2s_mdm_8064_device.dev.platform_data =
 				&mdm_platform_data;
 			platform_device_register(&i2s_mdm_8064_device);
@@ -5390,6 +5172,14 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
+	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
+	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
 	samsung_sys_class_init();
@@ -5502,17 +5292,6 @@
 #ifdef CONFIG_MSM_CAMERA
 	apq8064_init_cam();
 #endif
-
-	if (machine_is_mpq8064_hrd() || machine_is_mpq8064_dtv()) {
-#ifdef CONFIG_SERIAL_MSM_HS
-		/* GSBI6(2) - UARTDM_RX */
-		mpq8064_gsbi6_uartdm_pdata.wakeup_irq = gpio_to_irq(15);
-		mpq8064_device_uartdm_gsbi6.dev.platform_data =
-					&mpq8064_gsbi6_uartdm_pdata;
-#endif
-		platform_device_register(&mpq8064_device_uartdm_gsbi6);
-	}
-
 #ifdef CONFIG_SENSORS_SSP
 	clear_ssp_gpio();
 	sensor_power_on_vdd(SNS_PWR_ON, SNS_PWR_ON);
@@ -5531,6 +5310,7 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
+
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
 		platform_device_register(&mpq_gpio_keys_pdev);
diff --unified -r mach-msm/board-jf_tmo-gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_tmo-gpiomux.c
--- mach-msm/board-jf_tmo-gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_tmo-gpiomux.c	2013-12-17 17:08:05.618151151 -0800
@@ -704,6 +704,13 @@
 			[GPIOMUX_ACTIVE] = &mcu_chg_cfg,
 		},
 	},
+	{
+		.gpio = 70,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &mcu_chg_cfg,
+			[GPIOMUX_SUSPENDED] = &mcu_chg_cfg,
+		},
+	},
 };
 
 static struct msm_gpiomux_config apq8064_gsbi_configs[] __initdata = {
@@ -806,13 +813,6 @@
 			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
 		},
 	},
-	{
-		.gpio = 70,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gpio_nc_config,
-			[GPIOMUX_SUSPENDED] = &gpio_nc_config,
-		},
-	},	
 };
 
 static struct msm_gpiomux_config apq8064_slimbus_config[] __initdata = {
@@ -880,38 +880,38 @@
 
 static struct gpiomux_setting ap2mdm_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 static struct gpiomux_setting mdm2ap_status_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 static struct gpiomux_setting mdm2ap_errfatal_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_16MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 static struct gpiomux_setting mdm2ap_pblrdy = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
+	.drv = GPIOMUX_DRV_16MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 
 static struct gpiomux_setting ap2mdm_soft_reset_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
 static struct gpiomux_setting ap2mdm_wakeup = {
 	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_4MA,
+	.drv = GPIOMUX_DRV_8MA,
 	.pull = GPIOMUX_PULL_NONE,
 };
 
@@ -1057,105 +1057,6 @@
 };
 #endif
 
-static struct msm_gpiomux_config amdm_configs[] __initdata = {
-	/* AP2MDM_STATUS */
-	{
-		.gpio = 48,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 49,
-		.settings = {
-			[GPIOMUX_ACTIVE] = &mdm2ap_status_cfg,
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 19,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-	/* AP2MDM_ERRFATAL */
-	{
-		.gpio = 18,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* AP2MDM_SOFT_RESET, aka AP2MDM_PON_RESET_N */
-	{
-		.gpio = 27,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_soft_reset_cfg,
-		}
-	},
-	/* AP2MDM_WAKEUP */
-	{
-		.gpio = 35,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_wakeup,
-		}
-	},
-	/* MDM2AP_PBL_READY*/
-	{
-		.gpio = 31,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_pblrdy,
-		}
-	},
-};
-
-static struct msm_gpiomux_config bmdm_configs[] __initdata = {
-	/* AP2MDM_STATUS */
-	{
-		.gpio = 56,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 32,
-		.settings = {
-			[GPIOMUX_ACTIVE] = &mdm2ap_status_cfg,
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 81,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-	/* AP2MDM_ERRFATAL */
-	{
-		.gpio = 18,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_cfg,
-		}
-	},
-	/* AP2MDM_SOFT_RESET, aka AP2MDM_PON_RESET_N */
-	{
-		.gpio = 3,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_soft_reset_cfg,
-		}
-	},
-	/* AP2MDM_WAKEUP */
-	{
-		.gpio = 29,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &ap2mdm_wakeup,
-		}
-	},
-};
-
 static struct msm_gpiomux_config mdm_i2s_configs[] __initdata = {
 	/* AP2MDM_STATUS */
 	{
@@ -1678,109 +1579,6 @@
 	},
 };
 
-static struct msm_gpiomux_config sglte2_qsc_configs[] __initdata = {
-	/* MDM2AP_STATUS */
-	{
-		.gpio = 51,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_status_cfg,
-		}
-	},
-	/* MDM2AP_ERRFATAL */
-	{
-		.gpio = 52,
-		.settings = {
-			[GPIOMUX_SUSPENDED] = &mdm2ap_errfatal_cfg,
-		}
-	},
-};
-
-static struct gpiomux_setting gsbi4_uartdm_active = {
-	.func = GPIOMUX_FUNC_1,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct gpiomux_setting gsbi4_uartdm_suspended = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct gpiomux_setting gsbi6_uartdm_active = {
-	.func = GPIOMUX_FUNC_2,
-	.drv = GPIOMUX_DRV_8MA,
-	.pull = GPIOMUX_PULL_NONE,
-};
-
-static struct gpiomux_setting gsbi6_uartdm_suspended = {
-	.func = GPIOMUX_FUNC_GPIO,
-	.drv = GPIOMUX_DRV_2MA,
-	.pull = GPIOMUX_PULL_DOWN,
-};
-
-static struct msm_gpiomux_config apq8064_uartdm_gsbi4_configs[] __initdata = {
-	{
-		.gpio      = 11,        /* GSBI4 UARTDM RX */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-	{
-		.gpio      = 10,       /* GSBI4 UARTDM TX */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-	{
-		.gpio      = 13,        /* GSBI4 UARTDM RFR */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-	{
-		.gpio      = 12,        /* GSBI4 UARTDM CTS */
-		.settings = {
-			[GPIOMUX_ACTIVE] = &gsbi4_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi4_uartdm_suspended,
-		},
-	},
-};
-
-static struct msm_gpiomux_config mpq8064_uartdm_configs[] __initdata = {
-	{ /* UARTDM_TX */
-		.gpio      = 14,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-	{ /* UARTDM_RX */
-		.gpio      = 15,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-	{ /* UARTDM_CTS */
-		.gpio      = 16,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-	{ /* UARTDM_RFR */
-		.gpio      = 17,
-		.settings = {
-			[GPIOMUX_ACTIVE]    = &gsbi6_uartdm_active,
-			[GPIOMUX_SUSPENDED] = &gsbi6_uartdm_suspended,
-		},
-	},
-};
-
 void __init apq8064_init_gpiomux(void)
 {
 	int rc;
@@ -1859,28 +1657,12 @@
 			ARRAY_SIZE(mpq8064_mi2s_configs));
 
 	if (machine_is_apq8064_mtp()|| machine_is_JF()) {
-		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_DSDA2) {
-			msm_gpiomux_install(amdm_configs,
-					ARRAY_SIZE(amdm_configs));
-			msm_gpiomux_install(bmdm_configs,
-				ARRAY_SIZE(bmdm_configs));
-		} else if (socinfo_get_platform_subtype() ==
-					PLATFORM_SUBTYPE_SGLTE2) {
-			msm_gpiomux_install(mdm_configs,
-					ARRAY_SIZE(mdm_configs));
-			msm_gpiomux_install(sglte2_qsc_configs,
-					ARRAY_SIZE(sglte2_qsc_configs));
-
-			/* GSBI4 UART GPIOs for Primary IPC */
-			msm_gpiomux_install(apq8064_uartdm_gsbi4_configs,
-				ARRAY_SIZE(apq8064_uartdm_gsbi4_configs));
-		} else if (SOCINFO_VERSION_MINOR(platform_version) == 1) {
+		if (SOCINFO_VERSION_MINOR(platform_version) == 1)
 			msm_gpiomux_install(mdm_i2s_configs,
 					ARRAY_SIZE(mdm_i2s_configs));
-		} else {
+		else
 			msm_gpiomux_install(mdm_configs,
 					ARRAY_SIZE(mdm_configs));
-		}
 	}
 
 	if (machine_is_apq8064_mtp()|| machine_is_JF()) {
@@ -1944,7 +1726,4 @@
 #endif
 	msm_gpiomux_install(apq8064_sec_jack_configs,
 			ARRAY_SIZE(apq8064_sec_jack_configs));
-	if (machine_is_mpq8064_hrd() || machine_is_mpq8064_dtv())
-		msm_gpiomux_install(mpq8064_uartdm_configs,
-			ARRAY_SIZE(mpq8064_uartdm_configs));
 }
diff --unified -r mach-msm/board-jf_usc.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_usc.c
--- mach-msm/board-jf_usc.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_usc.c	2013-12-17 17:08:05.618151151 -0800
@@ -144,6 +144,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -962,7 +966,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1013,47 +1025,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1184,12 +1155,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1229,21 +1194,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3313,6 +3266,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3349,11 +3309,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3433,9 +3398,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3448,9 +3413,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3463,9 +3428,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -5082,6 +5047,23 @@
 }
 #endif
 
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5185,11 +5167,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 
 #ifdef CONFIG_MFD_MAX77693
@@ -5318,7 +5305,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-jf_vzw.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_vzw.c
--- mach-msm/board-jf_vzw.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-jf_vzw.c	2013-12-17 17:08:05.618151151 -0800
@@ -144,6 +144,10 @@
 #include <mach/fusion3-thermistor.h>
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #if defined(CONFIG_SENSORS_SSP)
 enum {
 	SNS_PWR_OFF,
@@ -960,7 +964,15 @@
 static struct persistent_ram_descriptor per_ram_descs[] __initdata = {
        {
                .name = "ram_console",
+#ifdef CONFIG_KEXEC_HARDBOOT
+               .size = KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR,
+       },
+       {
+               .name = "kexec_hb_page",
+               .size = SZ_1M - (KEXEC_HB_PAGE_ADDR - RAMCONSOLE_PHYS_ADDR),
+#else
                .size = SZ_1M,
+#endif
        }
 };
 
@@ -1011,47 +1023,6 @@
 	.paddr_to_memtype = apq8064_paddr_to_memtype,
 };
 
-static int apq8064_memory_bank_size(void)
-{
-	return 1<<29;
-}
-
-static void __init locate_unstable_memory(void)
-{
-	struct membank *mb = &meminfo.bank[meminfo.nr_banks - 1];
-	unsigned long bank_size;
-	unsigned long low, high;
-
-	bank_size = apq8064_memory_bank_size();
-	low = meminfo.bank[0].start;
-	high = mb->start + mb->size;
-
-	/* Check if 32 bit overflow occured */
-	if (high < mb->start)
-		high = -PAGE_SIZE;
-
-	low &= ~(bank_size - 1);
-
-	if (high - low <= bank_size)
-		goto no_dmm;
-
-#ifdef CONFIG_ENABLE_DMM
-	apq8064_reserve_info.low_unstable_address = mb->start -
-					MIN_MEMORY_BLOCK_SIZE + mb->size;
-	apq8064_reserve_info.max_unstable_size = MIN_MEMORY_BLOCK_SIZE;
-
-	apq8064_reserve_info.bank_size = bank_size;
-	pr_info("low unstable address %lx max size %lx bank size %lx\n",
-		apq8064_reserve_info.low_unstable_address,
-		apq8064_reserve_info.max_unstable_size,
-		apq8064_reserve_info.bank_size);
-	return;
-#endif
-no_dmm:
-	apq8064_reserve_info.low_unstable_address = high;
-	apq8064_reserve_info.max_unstable_size = 0;
-}
-
 #ifdef CONFIG_KEYBOARD_CYPRESS_TOUCH_236
 
 static struct touchkey_callbacks *tk_charger_callbacks;
@@ -1182,12 +1153,6 @@
 
 #endif
 
-static int apq8064_change_memory_power(u64 start, u64 size,
-	int change_type)
-{
-	return soc_change_memory_power(start, size, change_type);
-}
-
 static char prim_panel_name[PANEL_NAME_MAX_LEN];
 static char ext_panel_name[PANEL_NAME_MAX_LEN];
 
@@ -1227,21 +1192,9 @@
 #endif
 }
 
-static void __init place_movable_zone(void)
-{
-#ifdef CONFIG_ENABLE_DMM
-	movable_reserved_start = apq8064_reserve_info.low_unstable_address;
-	movable_reserved_size = apq8064_reserve_info.max_unstable_size;
-	pr_info("movable zone start %lx size %lx\n",
-		movable_reserved_start, movable_reserved_size);
-#endif
-}
-
 static void __init apq8064_early_reserve(void)
 {
 	reserve_info = &apq8064_reserve_info;
-	locate_unstable_memory();
-	place_movable_zone();
 
 }
 #ifdef CONFIG_USB_EHCI_MSM_HSIC
@@ -3315,6 +3268,13 @@
 	0x0B, 0x00, 0x0f,
 };
 
+static uint8_t spm_retention_with_krait_v3_cmd_sequence[] __initdata = {
+	0x42, 0x1B, 0x00,
+	0x05, 0x03, 0x0D, 0x0B,
+	0x00, 0x42, 0x1B,
+	0x0f,
+};
+
 static uint8_t spm_power_collapse_with_rpm[] __initdata = {
 	0x00, 0x24, 0x54, 0x10,
 	0x09, 0x07, 0x01, 0x0B,
@@ -3351,11 +3311,16 @@
 		.cmd = spm_wfi_cmd_sequence,
 	},
 	[1] = {
+		.mode = MSM_SPM_MODE_POWER_RETENTION,
+		.notify_rpm = false,
+		.cmd = spm_retention_cmd_sequence,
+	},
+	[2] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = false,
 		.cmd = spm_power_collapse_without_rpm,
 	},
-	[2] = {
+	[3] = {
 		.mode = MSM_SPM_MODE_POWER_COLLAPSE,
 		.notify_rpm = true,
 		.cmd = spm_power_collapse_with_rpm,
@@ -3435,9 +3400,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3450,9 +3415,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -3465,9 +3430,9 @@
 		.reg_init_values[MSM_SPM_REG_SAW2_AVS_HYSTERESIS] = 0x00,
 #endif
 		.reg_init_values[MSM_SPM_REG_SAW2_SPM_CTL] = 0x01,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x02020204,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0060009C,
-		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x0000001C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DLY] = 0x03020004,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_0] = 0x0084009C,
+		.reg_init_values[MSM_SPM_REG_SAW2_PMIC_DATA_1] = 0x00A4001C,
 		.vctl_timeout_us = 50,
 		.num_modes = ARRAY_SIZE(msm_spm_nonboot_cpu_seq_list),
 		.modes = msm_spm_nonboot_cpu_seq_list,
@@ -5084,6 +5049,23 @@
 }
 #endif
 
+static void __init apq8064ab_update_retention_spm(void)
+{
+	int i;
+
+	/* Update the SPM sequences for krait retention on all cores */
+	for (i = 0; i < ARRAY_SIZE(msm_spm_data); i++) {
+		int j;
+		struct msm_spm_platform_data *pdata = &msm_spm_data[i];
+		for (j = 0; j < pdata->num_modes; j++) {
+			if (pdata->modes[j].cmd ==
+					spm_retention_cmd_sequence)
+				pdata->modes[j].cmd =
+				spm_retention_with_krait_v3_cmd_sequence;
+		}
+	}
+}
+
 static void __init apq8064_common_init(void)
 {
 	u32 platform_version;
@@ -5187,11 +5169,16 @@
 		apq8064_init_dsps();
 		platform_device_register(&msm_8960_riva);
 	}
+	if (cpu_is_krait_v3()) {
+		msm_pm_set_tz_retention_flag(0);
+		apq8064ab_update_retention_spm();
+	} else {
+		msm_pm_set_tz_retention_flag(1);
+	}
 	msm_spm_init(msm_spm_data, ARRAY_SIZE(msm_spm_data));
 	msm_spm_l2_init(msm_spm_l2_data);
 	BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	apq8064_epm_adc_init();
-	msm_pm_set_tz_retention_flag(1);
 	samsung_sys_class_init();
 
 #ifdef CONFIG_MFD_MAX77693
@@ -5320,7 +5307,6 @@
 	bcm2079x_init();
 	nfc_gpio_rev_init();
 #endif
-	change_memory_power = &apq8064_change_memory_power;
 
 #ifndef CONFIG_MACH_JF
 	if (machine_is_mpq8064_cdp()) {
diff --unified -r mach-msm/board-msm7x27.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm7x27.c
--- mach-msm/board-msm7x27.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm7x27.c	2013-12-17 17:08:05.622151144 -0800
@@ -54,7 +54,6 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 #include <linux/i2c.h>
-#include <linux/android_pmem.h>
 #include <mach/camera.h>
 
 #ifdef CONFIG_USB_G_ANDROID
diff --unified -r mach-msm/board-msm7x30.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm7x30.c
--- mach-msm/board-msm7x30.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm7x30.c	2013-12-17 17:08:05.622151144 -0800
@@ -38,7 +38,6 @@
 #include <linux/msm_adc.h>
 #include <linux/dma-mapping.h>
 #include <linux/regulator/consumer.h>
-
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/setup.h>
@@ -53,7 +52,6 @@
 #include <mach/msm_spi.h>
 #include <mach/qdsp5v2/msm_lpa.h>
 #include <mach/dma.h>
-#include <linux/android_pmem.h>
 #include <linux/input/msm_ts.h>
 #include <mach/pmic.h>
 #include <mach/rpc_pmapp.h>
diff --unified -r mach-msm/board-msm8x60.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm8x60.c
--- mach-msm/board-msm8x60.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm8x60.c	2013-12-17 17:08:05.622151144 -0800
@@ -40,10 +40,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/i2c/bq27520.h>
 
-#ifdef CONFIG_ANDROID_PMEM
-#include <linux/android_pmem.h>
-#endif
-
 #if defined(CONFIG_SMB137B_CHARGER) || defined(CONFIG_SMB137B_CHARGER_MODULE)
 #include <linux/i2c/smb137b.h>
 #endif
diff --unified -r mach-msm/board-msm8x60-camera.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm8x60-camera.c
--- mach-msm/board-msm8x60-camera.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-msm8x60-camera.c	2013-12-17 17:08:05.622151144 -0800
@@ -324,15 +324,15 @@
 static struct msm_bus_paths cam_bus_client_config[] = {
 	{
 		ARRAY_SIZE(cam_init_vectors),
-		cam_init_vectors,
+		cam_zsl_vectors,
 	},
 	{
 		ARRAY_SIZE(cam_preview_vectors),
-		cam_preview_vectors,
+		cam_zsl_vectors,
 	},
 	{
 		ARRAY_SIZE(cam_video_vectors),
-		cam_video_vectors,
+		cam_zsl_vectors,
 	},
 	{
 		ARRAY_SIZE(cam_snapshot_vectors),
diff --unified -r mach-msm/board-s5000-tsp.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-s5000-tsp.c
--- mach-msm/board-s5000-tsp.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/board-s5000-tsp.c	2013-12-17 17:08:05.622151144 -0800
@@ -165,13 +165,8 @@
 #define SYNAPTICS_MAX_X_SIZE	1079
 #define SYNAPTICS_MAX_Y_SIZE	1919
 #define SYNAPTICS_MAX_WIDTH	SYNAPTICS_MAX_Y_SIZE
-#if defined(CONFIG_MACH_JACTIVE_EUR)
-#define NUM_RX	16
-#define NUM_TX	28
-#else
 #define NUM_RX	28
 #define NUM_TX	16
-#endif
 
 static struct synaptics_rmi4_platform_data rmi4_platformdata = {
 	/*.irq_type = IRQF_TRIGGER_FALLING,*/
@@ -195,6 +190,9 @@
 #ifdef CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_VIDEO_FULL_HD_PT_PANEL
 	.tout1_on = touch_tout1_on,
 #endif
+#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
+	.hsync_onoff = lcd_hsync_onoff,
+#endif
 };
 
 static struct i2c_board_info bus2_i2c_devices[] = {
@@ -247,6 +245,10 @@
 	touch_type = (version >> 12) & 0xF;
 	el_type = (version >> 8) & 0x1;
 
+#if defined(CONFIG_MACH_JACTIVE_EUR) || defined(CONFIG_MACH_JACTIVE_ATT)
+	/* JACITVE USE ONLY B Type */
+	touch_sleep_time = SYNAPTICS_HW_RESET_TIME_B0;
+#else
 	/* IF TSP IS is A1, B0 version : ID2 value is 40
 	 * IF TSP IS is B0 version : ID2 value is more than 40
 	 */
@@ -254,7 +256,7 @@
 		touch_sleep_time = SYNAPTICS_HW_RESET_TIME_B0;
 	else
 		touch_sleep_time = SYNAPTICS_HW_RESET_TIME;
-
+#endif
 	if (touch_type < 5) {
 		if (el_type)
 			rmi4_platformdata.panel_revision = OCTA_PANEL_REVISION_40;
diff --unified -r mach-msm/clock-8960.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/clock-8960.c
--- mach-msm/clock-8960.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/clock-8960.c	2013-12-17 17:08:05.626151138 -0800
@@ -3514,6 +3514,7 @@
 /*Shared by 8064, 8930, and 8960ab*/
 static struct clk_freq_tbl clk_tbl_gfx3d[] = {
 	F_GFX3D(        0, gnd,   0,  0),
+	F_GFX3D(  1800000, pxo,   1, 15),
 	F_GFX3D( 27000000, pxo,   0,  0),
 	F_GFX3D( 48000000, pll8,  1,  8),
 	F_GFX3D( 54857000, pll8,  1,  7),
@@ -4106,13 +4107,11 @@
 	F_TV( 27000000, hdmi_pll,  27000000, 1, 0, 0),
 	F_TV( 27030000, hdmi_pll,  27030000, 1, 0, 0),
 	F_TV( 74250000, hdmi_pll,  74250000, 1, 0, 0),
-	F_TV(108000000, hdmi_pll, 108000000, 1, 0, 0),
 	F_TV(148500000, hdmi_pll, 148500000, 1, 0, 0),
 	F_END
 };
 #else
 static struct clk_freq_tbl clk_tbl_tv[] = {
-	F_END
 };
 #endif
 
@@ -5113,8 +5112,6 @@
 		writel_relaxed(0x80|BVAL(5, 3, clk_sel), GCC_APCS_CLK_DIAG);
 		measure->sample_ticks = 0x4000;
 		measure->multiplier = 2;
-		if (cpu_is_krait_v3())
-			measure->multiplier = 8;
 		break;
 	default:
 		ret = -EPERM;
@@ -5315,7 +5312,7 @@
 #ifdef CONFIG_MACH_LGE
 	CLK_LOOKUP("core_clk",		gsbi4_uart_clk.c,	"msm_serial_hsl.0"),
 #else
-	CLK_LOOKUP("core_clk",		gsbi4_uart_clk.c, "msm_serial_hs.1"),
+	CLK_LOOKUP("core_clk",		gsbi4_uart_clk.c,	""),
 #endif
 	CLK_LOOKUP("core_clk",		gsbi5_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi6_uart_clk.c, "msm_serial_hs.0"),
@@ -5397,7 +5394,6 @@
 	CLK_LOOKUP("iface_clk",		gsbi4_p_clk.c,		"qup_i2c.4"),
 #endif
 #endif
-	CLK_LOOKUP("iface_clk",		gsbi4_p_clk.c,	"msm_serial_hs.1"),
 	CLK_LOOKUP("iface_clk",		gsbi5_p_clk.c,		"spi_qsd.0"),
 	CLK_LOOKUP("iface_clk",		gsbi5_p_clk.c,		"qup_i2c.5"),
 	CLK_LOOKUP("iface_clk",		gsbi6_p_clk.c,	"msm_serial_hs.0"),
@@ -5435,7 +5431,6 @@
 #else
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-002d"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-001a"),
-	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0010"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0034"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0020"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-003e"),
@@ -5478,9 +5473,9 @@
 	CLK_LOOKUP("npl_clk",		npl_tv_clk.c,		""),
 
 	CLK_LOOKUP("core_clk",		gfx3d_clk.c,	"kgsl-3d0.0"),
-	CLK_LOOKUP("core_clk",		gfx3d_clk.c,	"footswitch-8x60.2"),
+	CLK_LOOKUP("core_clk",		gfx3d_clk.c,	"footswitch-8x60.11"),
 	CLK_LOOKUP("bus_clk",
-			    gfx3d_axi_clk.c, "footswitch-8x60.2"),
+			    gfx3d_axi_clk.c, "footswitch-8x60.11"),
 	CLK_LOOKUP("iface_clk",         vcap_p_clk.c,           ""),
 	CLK_LOOKUP("iface_clk",         vcap_p_clk.c,           "msm_vcap.0"),
 	CLK_LOOKUP("iface_clk",         vcap_p_clk.c,	"footswitch-8x60.10"),
@@ -5534,7 +5529,7 @@
 	CLK_LOOKUP("master_iface_clk",	dsi2_m_p_clk.c,		"mipi_dsi.2"),
 	CLK_LOOKUP("slave_iface_clk",	dsi2_s_p_clk.c,		"mipi_dsi.2"),
 	CLK_LOOKUP("iface_clk",		gfx3d_p_clk.c,	"kgsl-3d0.0"),
-	CLK_LOOKUP("iface_clk",		gfx3d_p_clk.c,	"footswitch-8x60.2"),
+	CLK_LOOKUP("iface_clk",		gfx3d_p_clk.c,	"footswitch-8x60.11"),
 	CLK_LOOKUP("master_iface_clk",	hdmi_m_p_clk.c,		"hdmi_msm.1"),
 	CLK_LOOKUP("slave_iface_clk",	hdmi_s_p_clk.c,		"hdmi_msm.1"),
 	CLK_LOOKUP("iface_clk",		ijpeg_p_clk.c,		"msm_gemini.0"),
@@ -5640,6 +5635,9 @@
 	CLK_LOOKUP("krait1_mclk",	krait1_m_clk, ""),
 	CLK_LOOKUP("krait2_mclk",	krait2_m_clk, ""),
 	CLK_LOOKUP("krait3_mclk",	krait3_m_clk, ""),
+#ifdef CONFIG_SND_SOC_ES325
+	CLK_LOOKUP("osr_clk",	codec_i2s_spkr_osr_clk.c, "es325_mclk_dev"),
+#endif
 	CLK_LOOKUP("rot_iommu_clk",	rot_axi_clk.c,	"msm_rotator.0"),
 	CLK_LOOKUP("mdp_iommu_clk", mdp_axi_clk.c,	"msm_rotator.0"),
 	CLK_LOOKUP("vcodec_iommu0_clk", vcodec_axi_a_clk.c, "msm_rotator.0"),
@@ -5650,9 +5648,6 @@
 	CLK_LOOKUP("vcodec_iommu0_clk", vcodec_axi_a_clk.c, "mdp.0"),
 	CLK_LOOKUP("vcodec_iommu1_clk", vcodec_axi_b_clk.c, "mdp.0"),
 	CLK_LOOKUP("smmu_iface_clk", smmu_p_clk.c,	"mdp.0"),
-#ifdef CONFIG_SND_SOC_ES325
-	CLK_LOOKUP("osr_clk",	codec_i2s_spkr_osr_clk.c, "es325_mclk_dev"),
-#endif
 };
 
 static struct clk_lookup msm_clocks_8960_common[] __initdata = {
@@ -5734,7 +5729,7 @@
 	CLK_LOOKUP("core_clk",		gsbi10_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi11_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi12_uart_clk.c,	""),
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)	
 	CLK_LOOKUP("core_clk",		gsbi1_qup_clk.c,	"spi_qsd.1"),
 #else
 	CLK_LOOKUP("core_clk",		gsbi1_qup_clk.c,	"spi_qsd.0"),
@@ -5778,7 +5773,7 @@
 	CLK_LOOKUP("core_clk",		ce1_core_clk.c,		"qce.0"),
 	CLK_LOOKUP("core_clk",		ce1_core_clk.c,		"qcrypto.0"),
 	CLK_LOOKUP("dma_bam_pclk",	dma_bam_p_clk.c,	NULL),
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)	
 	CLK_LOOKUP("iface_clk",		gsbi1_p_clk.c,		"spi_qsd.1"),
 #else
 	CLK_LOOKUP("iface_clk",		gsbi1_p_clk.c,		"spi_qsd.0"),
@@ -5816,7 +5811,6 @@
 	CLK_LOOKUP("mem_clk",		rpm_msg_ram_p_clk.c,	""),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-002d"),	
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-001a"),
-	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0010"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-006c"),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0048"),
 	CLK_LOOKUP("cam_clk",		cam2_clk.c,		NULL),
@@ -6095,11 +6089,9 @@
 	CLK_LOOKUP("core_clk",		gsbi6_uart_clk.c, "msm_serial_hs.0"),
 	CLK_LOOKUP("core_clk",		gsbi7_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi8_uart_clk.c,	""),
-	/* used on 8930 SGLTE for Primary IPC */
-	CLK_LOOKUP("core_clk",		gsbi9_uart_clk.c, "msm_serial_hs.1"),
-	 /* used on 8930 SGLTE for serial console */
-	CLK_LOOKUP("core_clk",		gsbi10_uart_clk.c, "msm_serial_hsl.1"),
-	CLK_LOOKUP("core_clk",		gsbi11_uart_clk.c, "msm_serial_hsl.2"),
+	CLK_LOOKUP("core_clk",		gsbi9_uart_clk.c,	""),
+	CLK_LOOKUP("core_clk",		gsbi10_uart_clk.c,	""),
+	CLK_LOOKUP("core_clk",		gsbi11_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi12_uart_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi1_qup_clk.c,	"spi_qsd.0"),
 	CLK_LOOKUP("core_clk",		gsbi2_qup_clk.c,	""),
@@ -6108,7 +6100,7 @@
 	CLK_LOOKUP("core_clk",		gsbi5_qup_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi6_qup_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi7_qup_clk.c,	""),
-	CLK_LOOKUP("core_clk",		gsbi8_qup_clk.c,	"qup_i2c.8"),
+	CLK_LOOKUP("core_clk",		gsbi8_qup_clk.c,	""),
 	CLK_LOOKUP("core_clk",		gsbi9_qup_clk.c,	"qup_i2c.0"),
 	CLK_LOOKUP("core_clk",		gsbi10_qup_clk.c,	"qup_i2c.10"),
 	CLK_LOOKUP("core_clk",		gsbi11_qup_clk.c,	""),
@@ -6148,15 +6140,10 @@
 	CLK_LOOKUP("iface_clk",		gsbi5_p_clk.c,	"msm_serial_hsl.0"),
 	CLK_LOOKUP("iface_clk",		gsbi6_p_clk.c,  "msm_serial_hs.0"),
 	CLK_LOOKUP("iface_clk",		gsbi7_p_clk.c,		""),
-	/* used on 8930 SGLTE for Camera */
-	CLK_LOOKUP("iface_clk",		gsbi8_p_clk.c,		"qup_i2c.8"),
-	/* used on 8930 SGLTE for Primary IPC */
-	CLK_LOOKUP("iface_clk",         gsbi9_p_clk.c,	"msm_serial_hs.1"),
+	CLK_LOOKUP("iface_clk",		gsbi8_p_clk.c,		""),
 	CLK_LOOKUP("iface_clk",		gsbi9_p_clk.c,		"qup_i2c.0"),
 	CLK_LOOKUP("iface_clk",		gsbi10_p_clk.c,		"qup_i2c.10"),
-	/* used on 8930 SGLTE for serial console */
-	CLK_LOOKUP("iface_clk",         gsbi10_p_clk.c, "msm_serial_hsl.1"),
-	CLK_LOOKUP("iface_clk",		gsbi11_p_clk.c,	"msm_serial_hsl.2"),
+	CLK_LOOKUP("iface_clk",		gsbi11_p_clk.c,		""),
 	CLK_LOOKUP("iface_clk",		gsbi12_p_clk.c,		"qup_i2c.12"),
 	CLK_LOOKUP("iface_clk",		tsif_p_clk.c,		""),
 	CLK_LOOKUP("iface_clk",		usb_fs1_p_clk.c,	""),
@@ -6179,13 +6166,6 @@
 	CLK_LOOKUP("cam_clk",		cam1_clk.c,	"4-0048"),
 	CLK_LOOKUP("cam_clk",		cam2_clk.c,		NULL),
 	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"4-0020"),
-	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"8-001a"),
-	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"8-0036"),
-	CLK_LOOKUP("cam_clk",		cam1_clk.c,	"8-006c"),
-	CLK_LOOKUP("cam_clk",		cam1_clk.c,	"8-0010"),
-	CLK_LOOKUP("cam_clk",		cam1_clk.c,	"8-0048"),
-	CLK_LOOKUP("cam_clk",		cam2_clk.c,		NULL),
-	CLK_LOOKUP("cam_clk",		cam0_clk.c,	"8-0020"),
 	CLK_LOOKUP("csi_src_clk",	csi0_src_clk.c,		"msm_csid.0"),
 	CLK_LOOKUP("csi_src_clk",	csi1_src_clk.c,		"msm_csid.1"),
 	CLK_LOOKUP("csi_src_clk",	csi2_src_clk.c,		"msm_csid.2"),
@@ -6452,12 +6432,12 @@
 	 */
 	/*
 	 * Initialize MM AHB registers: Enable the FPB clock and disable HW
-	 * gating on 8627 and 8930ab for all clocks. Also set VFE_AHB's
+	 * gating on 8627, 8960 and 8930ab for all clocks. Also set VFE_AHB's
 	 * FORCE_CORE_ON bit to prevent its memory from being collapsed when
 	 * the clock is halted. The sleep and wake-up delays are set to safe
 	 * values.
 	 */
-	if (cpu_is_msm8627() || cpu_is_msm8930ab()) {
+	if (cpu_is_msm8627() || cpu_is_msm8960ab() || cpu_is_msm8930ab()) {
 		rmwreg(0x00000003, AHB_EN_REG,  0x6C000103);
 		writel_relaxed(0x000007F9, AHB_EN2_REG);
 	} else {
@@ -6475,7 +6455,7 @@
 	/* Initialize MM AXI registers: Enable HW gating for all clocks that
 	 * support it. Also set FORCE_CORE_ON bits, and any sleep and wake-up
 	 * delays to safe values. */
-	if ((cpu_is_msm8960() &&
+	if (cpu_is_msm8960ab() || (cpu_is_msm8960() &&
 			SOCINFO_VERSION_MAJOR(socinfo_get_version()) < 3) ||
 			cpu_is_msm8627() || cpu_is_msm8930ab()) {
 		rmwreg(0x000007F9, MAXI_EN_REG,  0x0803FFFF);
@@ -6498,6 +6478,8 @@
 
 	if (cpu_is_msm8627() || cpu_is_msm8930ab())
 		rmwreg(0x000003C7, SAXI_EN_REG,  0x00003FFF);
+	else if (cpu_is_msm8960ab())
+		rmwreg(0x000001C6, SAXI_EN_REG,  0x00001DF6);
 	else
 		rmwreg(0x00003C38, SAXI_EN_REG,  0x00003FFF);
 
diff --unified -r mach-msm/clock-8974.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/clock-8974.c
--- mach-msm/clock-8974.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/clock-8974.c	2013-12-17 17:08:05.626151138 -0800
@@ -795,6 +795,7 @@
 static DEFINE_CLK_VOTER(pnoc_sdcc4_clk, &pnoc_clk.c, 0);
 
 static DEFINE_CLK_VOTER(pnoc_sps_clk, &pnoc_clk.c, 0);
+static DEFINE_CLK_VOTER(pnoc_qseecom_clk, &pnoc_clk.c, 0);
 
 static struct clk_freq_tbl ftbl_gcc_usb30_master_clk[] = {
 	F(125000000,  gpll0,   1,   5,  24),
@@ -5045,11 +5046,6 @@
 	CLK_LOOKUP("bus_clk",      gcc_ce2_axi_clk.c, "qcrypto.0"),
 	CLK_LOOKUP("core_clk_src", ce2_clk_src.c,     "qcrypto.0"),
 
-	CLK_LOOKUP("core_clk",     gcc_ce1_clk.c,         "qseecom"),
-	CLK_LOOKUP("iface_clk",    gcc_ce1_ahb_clk.c,     "qseecom"),
-	CLK_LOOKUP("bus_clk",      gcc_ce1_axi_clk.c,     "qseecom"),
-	CLK_LOOKUP("core_clk_src", ce1_clk_src.c,         "qseecom"),
-
 	CLK_LOOKUP("core_clk", gcc_gp1_clk.c, ""),
 	CLK_LOOKUP("core_clk", gcc_gp2_clk.c, ""),
 	CLK_LOOKUP("core_clk", gcc_gp3_clk.c, ""),
@@ -5071,8 +5067,8 @@
 	CLK_LOOKUP("core_clk", gcc_sdcc4_apps_clk.c, "msm_sdcc.4"),
 	CLK_LOOKUP("bus_clk", pnoc_sdcc4_clk.c, "msm_sdcc.4"),
 
-	CLK_LOOKUP("iface_clk", gcc_tsif_ahb_clk.c, "f99d8000.msm_tspp"),
-	CLK_LOOKUP("ref_clk", gcc_tsif_ref_clk.c, "f99d8000.msm_tspp"),
+	CLK_LOOKUP("iface_clk", gcc_tsif_ahb_clk.c, ""),
+	CLK_LOOKUP("ref_clk", gcc_tsif_ref_clk.c, ""),
 
 	CLK_LOOKUP("core_clk", gcc_usb30_master_clk.c,    "msm_dwc3"),
 	CLK_LOOKUP("utmi_clk", gcc_usb30_mock_utmi_clk.c, "msm_dwc3"),
@@ -5236,6 +5232,7 @@
 	CLK_LOOKUP("core_clk", gcc_prng_ahb_clk.c, "msm_rng"),
 
 	CLK_LOOKUP("dfab_clk", pnoc_sps_clk.c, "msm_sps"),
+	CLK_LOOKUP("bus_clk",  pnoc_qseecom_clk.c, "qseecom"),
 
 	CLK_LOOKUP("bus_clk", snoc_clk.c, ""),
 	CLK_LOOKUP("bus_clk", pnoc_clk.c, ""),
diff --unified -r mach-msm/clock-dss-8960.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/clock-dss-8960.c
--- mach-msm/clock-dss-8960.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/clock-dss-8960.c	2013-12-17 17:08:05.626151138 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -335,22 +335,6 @@
 		writel_relaxed(0x3B, HDMI_PHY_PLL_VCOCAL_CFG2);
 	break;
 
-	case 108000000:
-		writel_relaxed(0x08, HDMI_PHY_PLL_REFCLK_CFG);
-		writel_relaxed(0x21, HDMI_PHY_PLL_LOOP_FLT_CFG0);
-		writel_relaxed(0xF9, HDMI_PHY_PLL_LOOP_FLT_CFG1);
-		writel_relaxed(0x1C, HDMI_PHY_PLL_VCOCAL_CFG0);
-		writel_relaxed(0x02, HDMI_PHY_PLL_VCOCAL_CFG1);
-		writel_relaxed(0x3B, HDMI_PHY_PLL_VCOCAL_CFG2);
-		writel_relaxed(0x86, HDMI_PHY_PLL_VCOCAL_CFG4);
-		writel_relaxed(0x00, HDMI_PHY_PLL_VCOCAL_CFG5);
-		writel_relaxed(0x49, HDMI_PHY_PLL_SDM_CFG0);
-		writel_relaxed(0x49, HDMI_PHY_PLL_SDM_CFG1);
-		writel_relaxed(0x00, HDMI_PHY_PLL_SDM_CFG2);
-		writel_relaxed(0x00, HDMI_PHY_PLL_SDM_CFG3);
-		writel_relaxed(0x00, HDMI_PHY_PLL_SDM_CFG4);
-	break;
-
 	case 148500000:
 		/* 1080p60/1080p50 case */
 		writel_relaxed(0x2, HDMI_PHY_PLL_REFCLK_CFG);
diff --unified -r mach-msm/cpufreq.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/cpufreq.c
--- mach-msm/cpufreq.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/cpufreq.c	2013-12-17 17:08:05.630151131 -0800
@@ -3,7 +3,7 @@
  * MSM architecture cpufreq driver
  *
  * Copyright (C) 2007 Google, Inc.
- * Copyright (c) 2007-2012, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2007-2013, The Linux Foundation. All rights reserved.
  * Author: Mike A. Chan <mikechan@google.com>
  *
  * This software is licensed under the terms of the GNU General Public
@@ -27,16 +27,37 @@
 #include <linux/cpumask.h>
 #include <linux/sched.h>
 #include <linux/suspend.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
 #include <mach/socinfo.h>
 #include <mach/cpufreq.h>
+#include <mach/msm_bus.h>
 
 #include "acpuclock.h"
 
+static DEFINE_MUTEX(l2bw_lock);
+
+static struct clk *cpu_clk[NR_CPUS];
+static struct clk *l2_clk;
+static unsigned int freq_index[NR_CPUS];
+static struct cpufreq_frequency_table *freq_table;
+static unsigned int *l2_khz;
+static bool is_clk;
+static bool is_sync;
+static struct msm_bus_vectors *bus_vec_lst;
+static struct msm_bus_scale_pdata bus_bw = {
+	.name = "msm-cpufreq",
+	.active_only = 1,
+};
+static u32 bus_client;
+
 struct cpufreq_work_struct {
 	struct work_struct work;
 	struct cpufreq_policy *policy;
 	struct completion complete;
 	int frequency;
+	unsigned int index;
 	int status;
 };
 
@@ -60,9 +81,12 @@
 
 static DEFINE_PER_CPU(struct cpu_freq, cpu_freq_info);
 
-
 #ifdef CONFIG_SEC_DVFS
+#ifdef CONFIG_SEC_DVFS_BOOSTER
 static unsigned int upper_limit_freq = 1566000;
+#else
+static unsigned int upper_limit_freq = 1890000;
+#endif
 static unsigned int lower_limit_freq;
 static unsigned int cpuinfo_max_freq;
 static unsigned int cpuinfo_min_freq;
@@ -108,7 +132,38 @@
 }
 #endif
 
-static int set_cpu_freq(struct cpufreq_policy *policy, unsigned int new_freq)
+static void update_l2_bw(int *also_cpu)
+{
+	int rc = 0, cpu;
+	unsigned int index = 0;
+
+	mutex_lock(&l2bw_lock);
+
+	if (also_cpu)
+		index = freq_index[*also_cpu];
+
+	for_each_online_cpu(cpu) {
+		index = max(index, freq_index[cpu]);
+	}
+
+	if (l2_clk)
+		rc = clk_set_rate(l2_clk, l2_khz[index] * 1000);
+	if (rc) {
+		pr_err("Error setting L2 clock rate!\n");
+		goto out;
+	}
+
+	if (bus_client)
+		rc = msm_bus_scale_client_update_request(bus_client, index);
+	if (rc)
+		pr_err("Bandwidth req failed (%d)\n", rc);
+
+out:
+	mutex_unlock(&l2bw_lock);
+}
+
+static int set_cpu_freq(struct cpufreq_policy *policy, unsigned int new_freq,
+			unsigned int index)
 {
 	int ret = 0;
 	int saved_sched_policy = -EINVAL;
@@ -116,6 +171,7 @@
 	struct cpufreq_freqs freqs;
 	struct cpu_freq *limit = &per_cpu(cpu_freq_info, policy->cpu);
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
+	struct cpufreq_frequency_table *table;
 
 	if (limit->limits_init) {
 		if (new_freq > limit->allowed_max) {
@@ -151,6 +207,12 @@
 	}
 #endif
 
+	/* limits applied above must be in cpufreq table */
+	table = cpufreq_frequency_get_table(policy->cpu);
+	if (cpufreq_frequency_table_target(policy, table, new_freq,
+		CPUFREQ_RELATION_H, &index))
+		return -EINVAL;
+
 	freqs.old = policy->cur;
 	freqs.new = new_freq;
 	freqs.cpu = policy->cpu;
@@ -168,7 +230,18 @@
 
 	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
 
-	ret = acpuclk_set_rate(policy->cpu, new_freq, SETRATE_CPUFREQ);
+	if (is_clk) {
+		unsigned long rate = new_freq * 1000;
+		rate = clk_round_rate(cpu_clk[policy->cpu], rate);
+		ret = clk_set_rate(cpu_clk[policy->cpu], rate);
+		if (!ret) {
+			freq_index[policy->cpu] = index;
+			update_l2_bw(NULL);
+		}
+	} else {
+		ret = acpuclk_set_rate(policy->cpu, new_freq, SETRATE_CPUFREQ);
+	}
+
 	if (!ret)
 		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
 
@@ -185,7 +258,8 @@
 	struct cpufreq_work_struct *cpu_work =
 		container_of(work, struct cpufreq_work_struct, work);
 
-	cpu_work->status = set_cpu_freq(cpu_work->policy, cpu_work->frequency);
+	cpu_work->status = set_cpu_freq(cpu_work->policy, cpu_work->frequency,
+					cpu_work->index);
 	complete(&cpu_work->complete);
 }
 
@@ -198,15 +272,6 @@
 	struct cpufreq_frequency_table *table;
 
 	struct cpufreq_work_struct *cpu_work = NULL;
-	cpumask_var_t mask;
-
-	if (!cpu_active(policy->cpu)) {
-		pr_info("cpufreq: cpu %d is not active.\n", policy->cpu);
-		return -ENODEV;
-	}
-
-	if (!alloc_cpumask_var(&mask, GFP_KERNEL))
-		return -ENOMEM;
 
 	mutex_lock(&per_cpu(cpufreq_suspend, policy->cpu).suspend_mutex);
 
@@ -232,24 +297,17 @@
 	cpu_work = &per_cpu(cpufreq_work, policy->cpu);
 	cpu_work->policy = policy;
 	cpu_work->frequency = table[index].frequency;
+	cpu_work->index = table[index].index;
 	cpu_work->status = -ENODEV;
 
-	cpumask_clear(mask);
-	cpumask_set_cpu(policy->cpu, mask);
-	if (cpumask_equal(mask, &current->cpus_allowed)) {
-		ret = set_cpu_freq(cpu_work->policy, cpu_work->frequency);
-		goto done;
-	} else {
-		cancel_work_sync(&cpu_work->work);
-		INIT_COMPLETION(cpu_work->complete);
-		queue_work_on(policy->cpu, msm_cpufreq_wq, &cpu_work->work);
-		wait_for_completion(&cpu_work->complete);
-	}
+	cancel_work_sync(&cpu_work->work);
+	INIT_COMPLETION(cpu_work->complete);
+	queue_work_on(policy->cpu, msm_cpufreq_wq, &cpu_work->work);
+	wait_for_completion(&cpu_work->complete);
 
 	ret = cpu_work->status;
 
 done:
-	free_cpumask_var(mask);
 	mutex_unlock(&per_cpu(cpufreq_suspend, policy->cpu).suspend_mutex);
 	return ret;
 }
@@ -263,6 +321,9 @@
 
 static unsigned int msm_cpufreq_get_freq(unsigned int cpu)
 {
+	if (is_clk)
+		return clk_get_rate(cpu_clk[cpu]) / 1000;
+
 	return acpuclk_get_rate(cpu);
 }
 
@@ -331,6 +392,7 @@
 {
 	int cur_freq;
 	int index;
+	int ret = 0;
 	struct cpufreq_frequency_table *table;
 	struct cpufreq_work_struct *cpu_work = NULL;
 
@@ -342,7 +404,7 @@
 	 * be changed independently. Each cpu is bound to
 	 * same frequency. Hence set the cpumask to all cpu.
 	 */
-	if (cpu_is_msm8625())
+	if (cpu_is_msm8625() || (is_clk && is_sync))
 		cpumask_setall(policy->cpus);
 
 	if (cpufreq_frequency_table_cpuinfo(policy, table)) {
@@ -361,7 +423,11 @@
 	cpuinfo_min_freq = policy->cpuinfo.min_freq;
 #endif
 
-	cur_freq = acpuclk_get_rate(policy->cpu);
+	if (is_clk)
+		cur_freq = clk_get_rate(cpu_clk[policy->cpu])/1000;
+	else
+		cur_freq = acpuclk_get_rate(policy->cpu);
+
 	if (cpufreq_frequency_table_target(policy, table, cur_freq,
 	    CPUFREQ_RELATION_H, &index) &&
 	    cpufreq_frequency_table_target(policy, table, cur_freq,
@@ -370,19 +436,16 @@
 				policy->cpu, cur_freq);
 		return -EINVAL;
 	}
-
-	if (cur_freq != table[index].frequency) {
-		int ret = 0;
-		ret = acpuclk_set_rate(policy->cpu, table[index].frequency,
-				SETRATE_CPUFREQ);
-		if (ret)
-			return ret;
-		pr_info("cpufreq: cpu%d init at %d switching to %d\n",
-				policy->cpu, cur_freq, table[index].frequency);
-		cur_freq = table[index].frequency;
-	}
-
-	policy->cur = cur_freq;
+	/*
+	 * Call set_cpu_freq unconditionally so that when cpu is set to
+	 * online, frequency limit will always be updated.
+	 */
+	ret = set_cpu_freq(policy, table[index].frequency, table[index].index);
+	if (ret)
+		return ret;
+	pr_debug("cpufreq: cpu%d init at %d switching to %d\n",
+			policy->cpu, cur_freq, table[index].frequency);
+	policy->cur = table[index].frequency;
 
 	policy->cpuinfo.transition_latency =
 		acpuclk_get_switch_time() * NSEC_PER_USEC;
@@ -398,22 +461,41 @@
 		unsigned long action, void *hcpu)
 {
 	unsigned int cpu = (unsigned long)hcpu;
+	int rc;
 
-	switch (action) {
+	switch (action & ~CPU_TASKS_FROZEN) {
 	case CPU_ONLINE:
-	case CPU_ONLINE_FROZEN:
 		per_cpu(cpufreq_suspend, cpu).device_suspended = 0;
 		break;
 	case CPU_DOWN_PREPARE:
-	case CPU_DOWN_PREPARE_FROZEN:
 		mutex_lock(&per_cpu(cpufreq_suspend, cpu).suspend_mutex);
 		per_cpu(cpufreq_suspend, cpu).device_suspended = 1;
 		mutex_unlock(&per_cpu(cpufreq_suspend, cpu).suspend_mutex);
 		break;
 	case CPU_DOWN_FAILED:
-	case CPU_DOWN_FAILED_FROZEN:
 		per_cpu(cpufreq_suspend, cpu).device_suspended = 0;
 		break;
+	/*
+	 * Scale down clock/power of CPU that is dead and scale it back up
+	 * before the CPU is brought up.
+	 */
+	case CPU_DEAD:
+	case CPU_UP_CANCELED:
+		if (is_clk) {
+			clk_disable_unprepare(cpu_clk[cpu]);
+			update_l2_bw(NULL);
+		}
+		break;
+	case CPU_UP_PREPARE:
+		if (is_clk) {
+			rc = clk_prepare_enable(cpu_clk[cpu]);
+			if (rc < 0)
+				return NOTIFY_BAD;
+			update_l2_bw(&cpu);
+		}
+		break;
+	default:
+		break;
 	}
 
 	return NOTIFY_OK;
@@ -469,6 +551,192 @@
 	.attr		= msm_freq_attr,
 };
 
+#define PROP_TBL "qcom,cpufreq-table"
+#define PROP_PORTS "qcom,cpu-mem-ports"
+static int cpufreq_parse_dt(struct device *dev)
+{
+	int ret, len, nf, num_cols = 1, num_paths = 0, i, j, k;
+	u32 *data, *ports = NULL;
+	struct msm_bus_vectors *v = NULL;
+
+	if (l2_clk)
+		num_cols++;
+
+	/* Parse optional bus ports parameter */
+	if (of_find_property(dev->of_node, PROP_PORTS, &len)) {
+		len /= sizeof(*ports);
+		if (len % 2)
+			return -EINVAL;
+
+		ports = devm_kzalloc(dev, len * sizeof(*ports), GFP_KERNEL);
+		if (!ports)
+			return -ENOMEM;
+		ret = of_property_read_u32_array(dev->of_node, PROP_PORTS,
+						 ports, len);
+		if (ret)
+			return ret;
+		num_paths = len / 2;
+		num_cols++;
+	}
+
+	/* Parse CPU freq -> L2/Mem BW map table. */
+	if (!of_find_property(dev->of_node, PROP_TBL, &len))
+		return -EINVAL;
+	len /= sizeof(*data);
+
+	if (len % num_cols || len == 0)
+		return -EINVAL;
+	nf = len / num_cols;
+
+	data = devm_kzalloc(dev, len * sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(dev->of_node, PROP_TBL, data, len);
+	if (ret)
+		return ret;
+
+	/* Allocate all data structures. */
+	freq_table = devm_kzalloc(dev, (nf + 1) * sizeof(*freq_table),
+				  GFP_KERNEL);
+	if (!freq_table)
+		return -ENOMEM;
+
+	if (l2_clk) {
+		l2_khz = devm_kzalloc(dev, nf * sizeof(*l2_khz), GFP_KERNEL);
+		if (!l2_khz)
+			return -ENOMEM;
+	}
+
+	if (num_paths) {
+		int sz_u = nf * sizeof(*bus_bw.usecase);
+		int sz_v = nf * num_paths * sizeof(*bus_vec_lst);
+		bus_bw.usecase = devm_kzalloc(dev, sz_u, GFP_KERNEL);
+		v = bus_vec_lst = devm_kzalloc(dev, sz_v, GFP_KERNEL);
+		if (!bus_bw.usecase || !bus_vec_lst)
+			return -ENOMEM;
+	}
+
+	j = 0;
+	for (i = 0; i < nf; i++) {
+		unsigned long f;
+
+		f = clk_round_rate(cpu_clk[0], data[j++] * 1000);
+		if (IS_ERR_VALUE(f))
+			break;
+		f /= 1000;
+
+		/*
+		 * Check if this is the last feasible frequency in the table.
+		 *
+		 * The table listing frequencies higher than what the HW can
+		 * support is not an error since the table might be shared
+		 * across CPUs in different speed bins. It's also not
+		 * sufficient to check if the rounded rate is lower than the
+		 * requested rate as it doesn't cover the following example:
+		 *
+		 * Table lists: 2.2 GHz and 2.5 GHz.
+		 * Rounded rate returns: 2.2 GHz and 2.3 GHz.
+		 *
+		 * In this case, we can CPUfreq to use 2.2 GHz and 2.3 GHz
+		 * instead of rejecting the 2.5 GHz table entry.
+		 */
+		if (i > 0 && f <= freq_table[i-1].frequency)
+			break;
+
+		freq_table[i].index = i;
+		freq_table[i].frequency = f;
+
+		if (l2_clk) {
+			f = clk_round_rate(l2_clk, data[j++] * 1000);
+			if (IS_ERR_VALUE(f)) {
+				pr_err("Error finding L2 rate for CPU %d KHz\n",
+					freq_table[i].frequency);
+				freq_table[i].frequency = CPUFREQ_ENTRY_INVALID;
+			} else {
+				f /= 1000;
+				l2_khz[i] = f;
+			}
+		}
+
+		if (num_paths) {
+			unsigned int bw_mbps = data[j++];
+			bus_bw.usecase[i].num_paths = num_paths;
+			bus_bw.usecase[i].vectors = v;
+			for (k = 0; k < num_paths; k++) {
+				v->src = ports[k * 2];
+				v->dst = ports[k * 2 + 1];
+				v->ib = bw_mbps * 1000000ULL;
+				v++;
+			}
+		}
+	}
+
+	bus_bw.num_usecases = i;
+	freq_table[i].index = i;
+	freq_table[i].frequency = CPUFREQ_TABLE_END;
+
+	if (ports)
+		devm_kfree(dev, ports);
+	devm_kfree(dev, data);
+
+	return 0;
+}
+
+static int __init msm_cpufreq_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	char clk_name[] = "cpu??_clk";
+	struct clk *c;
+	int cpu, ret;
+
+	l2_clk = devm_clk_get(dev, "l2_clk");
+	if (IS_ERR(l2_clk))
+		l2_clk = NULL;
+
+	for_each_possible_cpu(cpu) {
+		snprintf(clk_name, sizeof(clk_name), "cpu%d_clk", cpu);
+		c = devm_clk_get(dev, clk_name);
+		if (!IS_ERR(c))
+			cpu_clk[cpu] = c;
+		else
+			is_sync = true;
+	}
+
+	if (!cpu_clk[0])
+		return -ENODEV;
+
+	ret = cpufreq_parse_dt(dev);
+	if (ret)
+		return ret;
+
+	for_each_possible_cpu(cpu) {
+		cpufreq_frequency_table_get_attr(freq_table, cpu);
+	}
+
+	if (bus_bw.usecase) {
+		bus_client = msm_bus_scale_register_client(&bus_bw);
+		if (!bus_client)
+			dev_warn(dev, "Unable to register bus client\n");
+	}
+
+	is_clk = true;
+	return 0;
+}
+
+static struct of_device_id match_table[] = {
+	{ .compatible = "qcom,msm-cpufreq" },
+	{}
+};
+
+static struct platform_driver msm_cpufreq_plat_driver = {
+	.driver = {
+		.name = "msm-cpufreq",
+		.of_match_table = match_table,
+		.owner = THIS_MODULE,
+	},
+};
+
 static int __init msm_cpufreq_register(void)
 {
 	int cpu;
@@ -478,10 +746,10 @@
 		per_cpu(cpufreq_suspend, cpu).device_suspended = 0;
 	}
 
-	msm_cpufreq_wq = create_workqueue("msm-cpufreq");
+	platform_driver_probe(&msm_cpufreq_plat_driver, msm_cpufreq_probe);
+	msm_cpufreq_wq = alloc_workqueue("msm-cpufreq", WQ_HIGHPRI, 0);
 	register_hotcpu_notifier(&msm_cpufreq_cpu_notifier);
-
 	return cpufreq_register_driver(&msm_cpufreq_driver);
 }
 
-late_initcall(msm_cpufreq_register);
+device_initcall(msm_cpufreq_register);
diff --unified -r mach-msm/devices-8064.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-8064.c
--- mach-msm/devices-8064.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-8064.c	2013-12-17 17:08:05.630151131 -0800
@@ -45,7 +45,6 @@
 #include "msm_watchdog.h"
 #include "rpm_stats.h"
 #include "rpm_log.h"
-#include "board-8064.h"
 #include <mach/mpm.h>
 #include <mach/iommu_domains.h>
 #include <mach/msm_cache_dump.h>
@@ -375,50 +374,6 @@
 	.resource = resources_uart_gsbi4,
 };
 
-/* GSBI 4 used into UARTDM Mode for 8064 SGLTE */
-static struct resource msm_uart_dm4_resources[] = {
-	{
-		.start  = MSM_UART4DM_PHYS,
-		.end    = MSM_UART4DM_PHYS + PAGE_SIZE - 1,
-		.name   = "uartdm_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = GSBI4_UARTDM_IRQ,
-		.end    = GSBI4_UARTDM_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.start  = MSM_GSBI4_PHYS,
-		.end    = MSM_GSBI4_PHYS + 4 - 1,
-		.name   = "gsbi_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = DMOV_APQ8064_HSUART_GSBI4_TX_CHAN,
-		.end    = DMOV_APQ8064_HSUART_GSBI4_RX_CHAN,
-		.name   = "uartdm_channels",
-		.flags  = IORESOURCE_DMA,
-	},
-	{
-		.start  = DMOV_APQ8064_HSUART_GSBI4_TX_CRCI,
-		.end    = DMOV_APQ8064_HSUART_GSBI4_RX_CRCI,
-		.name   = "uartdm_crci",
-		.flags  = IORESOURCE_DMA,
-	},
-};
-static u64 msm_uart_dm4_dma_mask = DMA_BIT_MASK(32);
-struct platform_device apq8064_device_uartdm_gsbi4 = {
-	.name   = "msm_serial_hs",
-	.id     = 1,
-	.num_resources  = ARRAY_SIZE(msm_uart_dm4_resources),
-	.resource       = msm_uart_dm4_resources,
-	.dev    = {
-		.dma_mask		= &msm_uart_dm4_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-};
-
 static struct resource resources_qup_i2c_gsbi4[] = {
 	{
 		.name	= "gsbi_qup_i2c_addr",
@@ -687,50 +642,6 @@
 	.resource	= resources_qup_i2c_gsbi5,
 };
 
-/* GSBI 6 used into UARTDM Mode */
-static struct resource msm_uart_dm6_resources[] = {
-	{
-		.start  = MSM_UART6DM_PHYS,
-		.end    = MSM_UART6DM_PHYS + PAGE_SIZE - 1,
-		.name   = "uartdm_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = GSBI6_UARTDM_IRQ,
-		.end    = GSBI6_UARTDM_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.start  = MSM_GSBI6_PHYS,
-		.end    = MSM_GSBI6_PHYS + 4 - 1,
-		.name   = "gsbi_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = DMOV_MPQ8064_HSUART_GSBI6_TX_CHAN,
-		.end    = DMOV_MPQ8064_HSUART_GSBI6_RX_CHAN,
-		.name   = "uartdm_channels",
-		.flags  = IORESOURCE_DMA,
-	},
-	{
-		.start  = DMOV_MPQ8064_HSUART_GSBI6_TX_CRCI,
-		.end    = DMOV_MPQ8064_HSUART_GSBI6_RX_CRCI,
-		.name   = "uartdm_crci",
-		.flags  = IORESOURCE_DMA,
-	},
-};
-static u64 msm_uart_dm6_dma_mask = DMA_BIT_MASK(32);
-struct platform_device mpq8064_device_uartdm_gsbi6 = {
-	.name   = "msm_serial_hs",
-	.id     = 0,
-	.num_resources  = ARRAY_SIZE(msm_uart_dm6_resources),
-	.resource       = msm_uart_dm6_resources,
-	.dev    = {
-		.dma_mask		= &msm_uart_dm6_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-};
-
 /* BT HS UART Configuration for BRCM BT*/
 #ifdef CONFIG_SERIAL_MSM_HS
 static struct resource msm_uart1_dm_resources[] = {
@@ -781,6 +692,7 @@
 };
 #endif
 
+
 static struct resource resources_uart_gsbi7[] = {
 	{
 		.start	= GSBI7_UARTDM_IRQ,
@@ -1036,49 +948,26 @@
 
 static struct resource tspp_resources[] = {
 	[0] = {
-		.name = "TSIF_TSPP_IRQ",
 		.flags = IORESOURCE_IRQ,
 		.start = TSIF_TSPP_IRQ,
-		.end   = TSIF_TSPP_IRQ,
-	},
-	[1] = {
-		.name = "TSIF0_IRQ",
-		.flags = IORESOURCE_IRQ,
-		.start = TSIF1_IRQ,
 		.end   = TSIF1_IRQ,
 	},
-	[2] = {
-		.name = "TSIF1_IRQ",
-		.flags = IORESOURCE_IRQ,
-		.start = TSIF2_IRQ,
-		.end   = TSIF2_IRQ,
-	},
-	[3] = {
-		.name = "TSIF_BAM_IRQ",
-		.flags = IORESOURCE_IRQ,
-		.start = TSIF_BAM_IRQ,
-		.end   = TSIF_BAM_IRQ,
-	},
-	[4] = {
-		.name = "MSM_TSIF0_PHYS",
+	[1] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSIF0_PHYS,
 		.end   = MSM_TSIF0_PHYS + MSM_TSIF_SIZE - 1,
 	},
-	[5] = {
-		.name = "MSM_TSIF1_PHYS",
+	[2] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSIF1_PHYS,
 		.end   = MSM_TSIF1_PHYS + MSM_TSIF_SIZE - 1,
 	},
-	[6] = {
-		.name = "MSM_TSPP_PHYS",
+	[3] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSPP_PHYS,
 		.end   = MSM_TSPP_PHYS + MSM_TSPP_SIZE - 1,
 	},
-	[7] = {
-		.name = "MSM_TSPP_BAM_PHYS",
+	[4] = {
 		.flags = IORESOURCE_MEM,
 		.start = MSM_TSPP_BAM_PHYS,
 		.end   = MSM_TSPP_BAM_PHYS + MSM_TSPP_BAM_SIZE - 1,
@@ -2345,11 +2234,12 @@
 
 static struct fs_driver_data gfx3d_fs_data = {
 	.clks = (struct fs_clk_data[]){
-		{ .name = "core_clk", .reset_rate = 27000000 },
+		{ .name = "core_clk", .reset_rate = 1800000 },
 		{ .name = "iface_clk" },
 		{ .name = "bus_clk" },
 		{ 0 }
 	},
+	.reset_delay_us = 10,
 	.bus_port0 = MSM_BUS_MASTER_GRAPHICS_3D,
 	.bus_port1 = MSM_BUS_MASTER_GRAPHICS_3D_PORT1,
 };
@@ -2438,7 +2328,7 @@
 	FS_8X60(FS_IJPEG,  "vdd",	"msm_gemini.0",	&ijpeg_fs_data),
 	FS_8X60(FS_VFE,    "vdd",	"msm_vfe.0",	&vfe_fs_data),
 	FS_8X60(FS_VPE,    "vdd",	"msm_vpe.0",	&vpe_fs_data),
-	FS_8X60(FS_GFX3D,  "vdd",	"kgsl-3d0.0",	&gfx3d_fs_data),
+	FS_8X60(FS_GFX3D_8064, "vdd",	"kgsl-3d0.0",	&gfx3d_fs_data),
 	FS_8X60(FS_VED,    "vdd",	"msm_vidc.0",	&ved_fs_data),
 	FS_8X60(FS_VCAP,   "vdd",	"msm_vcap.0",	&vcap_fs_data),
 };
@@ -2756,8 +2646,8 @@
 		[MSM_RPM_LOG_PAGE_BUFFER]  = 0x000000A0,
 	},
 	.phys_size = SZ_8K,
-	.log_len = 6144,		  /* log's buffer length in bytes */
-	.log_len_mask = (6144 >> 2) - 1,  /* length mask in units of u32 */
+	.log_len = 4096,		  /* log's buffer length in bytes */
+	.log_len_mask = (4096 >> 2) - 1,  /* length mask in units of u32 */
 };
 
 struct platform_device apq8064_rpm_log_device = {
@@ -2939,7 +2829,7 @@
 #define MDM2AP_STATUS			49
 #define AP2MDM_STATUS			48
 #define AP2MDM_SOFT_RESET		27
-#define I2S_AP2MDM_SOFT_RESET	0
+#define I2S_AP2MDM_SOFT_RESET		0
 #define AP2MDM_WAKEUP			35
 #define I2S_AP2MDM_WAKEUP		44
 #ifdef CONFIG_MSM_HSIC_GPIO_REV06
@@ -2947,22 +2837,8 @@
 #else
 #define MDM2AP_PBLRDY			46
 #endif
-#define AMDM2AP_PBLRDY_DSDA2	31
 #define I2S_MDM2AP_PBLRDY		81
 
-/* Gpios for second MDM */
-#define BMDM2AP_ERRFATAL		81
-#define AP2BMDM_ERRFATAL		18
-#define BMDM2AP_STATUS			32
-#define AP2BMDM_STATUS			56
-#define AP2BMDM_SOFT_RESET		3
-#define AP2BMDM_WAKEUP			29
-
-#define SGLTE2_QSC2AP_STATUS	51
-#define SGLTE2_QSC2AP_ERRFATAL	52
-#define SGLTE2_PM2QSC_SOFT_RESET	PM8921_GPIO_PM_TO_SYS(23)
-#define SGLTE2_PM2QSC_KEYPADPWR		PM8921_GPIO_PM_TO_SYS(21)
-
 static struct resource mdm_resources[] = {
 	{
 		.start	= MDM2AP_ERRFATAL,
@@ -3008,90 +2884,6 @@
 	},
 };
 
-static struct resource mdm_dsda2_amdm_resources[] = {
-	{
-		.start	= MDM2AP_ERRFATAL,
-		.end	= MDM2AP_ERRFATAL,
-		.name	= "MDM2AP_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2MDM_ERRFATAL,
-		.end	= AP2MDM_ERRFATAL,
-		.name	= "AP2MDM_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= MDM2AP_STATUS,
-		.end	= MDM2AP_STATUS,
-		.name	= "MDM2AP_STATUS",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2MDM_STATUS,
-		.end	= AP2MDM_STATUS,
-		.name	= "AP2MDM_STATUS",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2MDM_SOFT_RESET,
-		.end	= AP2MDM_SOFT_RESET,
-		.name	= "AP2MDM_SOFT_RESET",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2MDM_WAKEUP,
-		.end	= AP2MDM_WAKEUP,
-		.name	= "AP2MDM_WAKEUP",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AMDM2AP_PBLRDY_DSDA2,
-		.end	= AMDM2AP_PBLRDY_DSDA2,
-		.name	= "MDM2AP_PBLRDY",
-		.flags	= IORESOURCE_IO,
-	},
-};
-
-static struct resource mdm_dsda2_bmdm_resources[] = {
-	{
-		.start	= BMDM2AP_ERRFATAL,
-		.end	= BMDM2AP_ERRFATAL,
-		.name	= "MDM2AP_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2BMDM_ERRFATAL,
-		.end	= AP2BMDM_ERRFATAL,
-		.name	= "AP2MDM_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= BMDM2AP_STATUS,
-		.end	= BMDM2AP_STATUS,
-		.name	= "MDM2AP_STATUS",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2BMDM_STATUS,
-		.end	= AP2BMDM_STATUS,
-		.name	= "AP2MDM_STATUS",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2BMDM_SOFT_RESET,
-		.end	= AP2BMDM_SOFT_RESET,
-		.name	= "AP2MDM_SOFT_RESET",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2BMDM_WAKEUP,
-		.end	= AP2BMDM_WAKEUP,
-		.name	= "AP2MDM_WAKEUP",
-		.flags	= IORESOURCE_IO,
-	},
-};
-
 static struct resource i2s_mdm_resources[] = {
 	{
 		.start	= MDM2AP_ERRFATAL,
@@ -3137,45 +2929,6 @@
 	},
 };
 
-static struct resource sglte2_qsc_resources[] = {
-	{
-		.start	= SGLTE2_QSC2AP_ERRFATAL,
-		.end	= SGLTE2_QSC2AP_ERRFATAL,
-		.name	= "MDM2AP_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2MDM_ERRFATAL,
-		.end	= AP2MDM_ERRFATAL,
-		.name	= "AP2MDM_ERRFATAL",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= SGLTE2_QSC2AP_STATUS,
-		.end	= SGLTE2_QSC2AP_STATUS,
-		.name	= "MDM2AP_STATUS",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= AP2MDM_STATUS,
-		.end	= AP2MDM_STATUS,
-		.name	= "AP2MDM_STATUS",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= SGLTE2_PM2QSC_KEYPADPWR,
-		.end	= SGLTE2_PM2QSC_KEYPADPWR,
-		.name	= "AP2MDM_KPDPWR_N",
-		.flags	= IORESOURCE_IO,
-	},
-	{
-		.start	= SGLTE2_PM2QSC_SOFT_RESET,
-		.end	= SGLTE2_PM2QSC_SOFT_RESET,
-		.name	= "AP2MDM_SOFT_RESET",
-		.flags	= IORESOURCE_IO,
-	},
-};
-
 struct platform_device mdm_8064_device = {
 	.name		= "mdm2_modem",
 	.id		= -1,
@@ -3183,20 +2936,6 @@
 	.resource	= mdm_resources,
 };
 
-struct platform_device amdm_8064_device = {
-	.name		= "mdm2_modem",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(mdm_dsda2_amdm_resources),
-	.resource	= mdm_dsda2_amdm_resources,
-};
-
-struct platform_device bmdm_8064_device = {
-	.name		= "mdm2_modem",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(mdm_dsda2_bmdm_resources),
-	.resource	= mdm_dsda2_bmdm_resources,
-};
-
 struct platform_device i2s_mdm_8064_device = {
 	.name		= "mdm2_modem",
 	.id		= -1,
@@ -3204,20 +2943,6 @@
 	.resource	= i2s_mdm_resources,
 };
 
-struct platform_device sglte_mdm_8064_device = {
-	.name		= "mdm2_modem",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(mdm_resources),
-	.resource	= mdm_resources,
-};
-
-struct platform_device sglte2_qsc_8064_device = {
-	.name		= "mdm2_modem",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(sglte2_qsc_resources),
-	.resource	= sglte2_qsc_resources,
-};
-
 static struct msm_dcvs_sync_rule apq8064_dcvs_sync_rules[] = {
 	{1026000,	400000},
 	{384000,	200000},
@@ -3470,7 +3195,7 @@
 static struct coresight_platform_data coresight_funnel_pdata = {
 	.id		= 2,
 	.name		= "coresight-funnel",
-	.nr_inports	= 8,
+	.nr_inports	= 4,
 	.outports	= coresight_funnel_outports,
 	.child_ids	= coresight_funnel_child_ids,
 	.child_ports	= coresight_funnel_child_ports,
@@ -3502,7 +3227,7 @@
 static struct coresight_platform_data coresight_etm2_pdata = {
 	.id		= 6,
 	.name		= "coresight-etm2",
-	.nr_inports	= 0,
+	.nr_inports	= 1,
 	.outports	= coresight_etm2_outports,
 	.child_ids	= coresight_etm2_child_ids,
 	.child_ports	= coresight_etm2_child_ports,
@@ -3534,7 +3259,7 @@
 static struct coresight_platform_data coresight_etm3_pdata = {
 	.id		= 7,
 	.name		= "coresight-etm3",
-	.nr_inports	= 0,
+	.nr_inports	= 3,
 	.outports	= coresight_etm3_outports,
 	.child_ids	= coresight_etm3_child_ids,
 	.child_ports	= coresight_etm3_child_ports,
diff --unified -r mach-msm/devices-8930.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-8930.c
--- mach-msm/devices-8930.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-8930.c	2013-12-17 17:08:05.630151131 -0800
@@ -557,14 +557,14 @@
 };
 
 static struct msm_rpm_log_platform_data msm_rpm_log_pdata = {
-	.phys_addr_base = 0x10B6A0,
+	.phys_addr_base = 0x0010C000,
 	.reg_offsets = {
 		[MSM_RPM_LOG_PAGE_INDICES] = 0x00000080,
 		[MSM_RPM_LOG_PAGE_BUFFER]  = 0x000000A0,
 	},
 	.phys_size = SZ_8K,
-	.log_len = 8192,		  /* log's buffer length in bytes */
-	.log_len_mask = (8192 >> 2) - 1,  /* length mask in units of u32 */
+	.log_len = 4096,		  /* log's buffer length in bytes */
+	.log_len_mask = (4096 >> 2) - 1,  /* length mask in units of u32 */
 };
 
 struct platform_device msm8930_rpm_log_device = {
@@ -969,20 +969,17 @@
 		.ib  = 7000000,
 	},
 };
-/*This value is modified because internally we use
- * lower value. But OEM has increased it. This is correct value
- * for oem*/
 static struct msm_bus_vectors vidc_venc_1080p_vectors[] = {
 	{
 		.src = MSM_BUS_MASTER_HD_CODEC_PORT0,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 400000000,
+		.ab  = 372244480,
 		.ib  = 2560000000U,
 	},
 	{
 		.src = MSM_BUS_MASTER_HD_CODEC_PORT1,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
-		.ab  = 550000000,
+		.ab  = 501219328,
 		.ib  = 2560000000U,
 	},
 	{
diff --unified -r mach-msm/devices-8960.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-8960.c
--- mach-msm/devices-8960.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-8960.c	2013-12-17 17:08:05.630151131 -0800
@@ -18,10 +18,8 @@
 #include <linux/msm_ion.h>
 #include <linux/gpio.h>
 #include <linux/coresight.h>
-#include <linux/avtimer.h>
 #include <asm/clkdev.h>
 #include <mach/kgsl.h>
-#include <linux/android_pmem.h>
 #include <mach/irqs-8960.h>
 #include <mach/dma.h>
 #include <linux/dma-mapping.h>
@@ -78,14 +76,11 @@
 #define MSM_GSBI11_PHYS		0x12440000
 #define MSM_GSBI12_PHYS		0x12480000
 
-/* GSBI UART devices */
 #define MSM_UART2DM_PHYS	(MSM_GSBI2_PHYS + 0x40000)
 #define MSM_UART5DM_PHYS	(MSM_GSBI5_PHYS + 0x40000)
 #define MSM_UART6DM_PHYS	(MSM_GSBI6_PHYS + 0x40000)
 #define MSM_UART8DM_PHYS	(MSM_GSBI8_PHYS + 0x40000)
 #define MSM_UART9DM_PHYS	(MSM_GSBI9_PHYS + 0x40000)
-#define MSM_UART10DM_PHYS	(MSM_GSBI10_PHYS + 0x40000)
-#define MSM_UART11DM_PHYS	(MSM_GSBI11_PHYS + 0x10000)
 
 /* GSBI QUP devices */
 #define MSM_GSBI1_QUP_PHYS	(MSM_GSBI1_PHYS + 0x80000)
@@ -113,10 +108,6 @@
 #define MSM8960_PC_CNTR_PHYS	(MSM8960_IMEM_PHYS + 0x664)
 #define MSM8960_PC_CNTR_SIZE		0x40
 
-/* avtimer */
-#define AVTIMER_MSW_PHYSICAL_ADDRESS 0x2800900C
-#define AVTIMER_LSW_PHYSICAL_ADDRESS 0x28009008
-
 static struct resource msm8960_resources_pccntr[] = {
 	{
 		.start	= MSM8960_PC_CNTR_PHYS,
@@ -435,67 +426,6 @@
 	},
 };
 
-/* GSBI10 used for serial console on 8930 SGLTE*/
-static struct msm_serial_hslite_platform_data uart_gsbi10_pdata;
-
-static struct resource resources_uart_gsbi10[] = {
-	{
-		.start  = GSBI10_UARTDM_IRQ,
-		.end    = GSBI10_UARTDM_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.start  = MSM_UART10DM_PHYS,
-		.end    = MSM_UART10DM_PHYS + PAGE_SIZE - 1,
-		.name   = "uartdm_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = MSM_GSBI10_PHYS,
-		.end    = MSM_GSBI10_PHYS + PAGE_SIZE - 1,
-		.name   = "gsbi_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-};
-
-struct platform_device msm8930_device_uart_gsbi10 = {
-	.name	= "msm_serial_hsl",
-	.id	= 1,
-	.num_resources	= ARRAY_SIZE(resources_uart_gsbi10),
-	.resource	= resources_uart_gsbi10,
-	.dev.platform_data	= &uart_gsbi10_pdata,
-};
-
-static struct msm_serial_hslite_platform_data uart_gsbi11_pdata;
-
-static struct resource resources_uart_gsbi11[] = {
-	{
-		.start  = GSBI11_UARTDM_IRQ,
-		.end    = GSBI11_UARTDM_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-	{
-		.start  = MSM_UART11DM_PHYS,
-		.end    = MSM_UART11DM_PHYS + PAGE_SIZE - 1,
-		.name   = "uartdm_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = MSM_GSBI11_PHYS,
-		.end    = MSM_GSBI11_PHYS + PAGE_SIZE - 1,
-		.name   = "gsbi_resource",
-		.flags  = IORESOURCE_MEM,
-	},
-};
-
-struct platform_device msm8930_device_uart_gsbi11 = {
-	.name	= "msm_serial_hsl",
-	.id	= 2,
-	.num_resources	= ARRAY_SIZE(resources_uart_gsbi11),
-	.resource	= resources_uart_gsbi11,
-	.dev.platform_data	= &uart_gsbi11_pdata,
-};
-
 static struct resource resources_uart_gsbi5[] = {
 	{
 		.start	= GSBI5_UARTDM_IRQ,
@@ -1719,6 +1649,7 @@
 	.id		= -1,
 };
 
+
 static struct msm_watchdog_pdata msm_watchdog_pdata = {
 	.pet_time = 10000,
 	.bark_time = 11000,
@@ -1819,34 +1750,6 @@
 	.resource	= resources_qup_i2c_gsbi4,
 };
 
-static struct resource resources_qup_i2c_gsbi8[] = {
-	{
-		.name	= "gsbi_qup_i2c_addr",
-		.start	= MSM_GSBI8_PHYS,
-		.end	= MSM_GSBI8_PHYS + 4 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "qup_phys_addr",
-		.start	= MSM_GSBI8_QUP_PHYS,
-		.end	= MSM_GSBI8_QUP_PHYS + MSM_QUP_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "qup_err_intr",
-		.start	= GSBI8_QUP_IRQ,
-		.end	= GSBI8_QUP_IRQ,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device msm8960_device_qup_i2c_gsbi8 = {
-	.name		= "qup_i2c",
-	.id		= 8,
-	.num_resources	= ARRAY_SIZE(resources_qup_i2c_gsbi8),
-	.resource	= resources_qup_i2c_gsbi8,
-};
-
 static struct resource resources_qup_i2c_gsbi3[] = {
 	{
 		.name	= "gsbi_qup_i2c_addr",
@@ -2541,11 +2444,6 @@
 	.id	= -1,
 };
 
-struct platform_device msm_fm_loopback = {
-	.name	= "msm-pcm-loopback",
-	.id	= -1,
-};
-
 static struct fs_driver_data gfx2d0_fs_data = {
 	.clks = (struct fs_clk_data[]){
 		{ .name = "core_clk" },
@@ -3345,7 +3243,30 @@
 };
 #endif
 
-static struct resource kgsl_3d0_resources[] = {
+struct resource kgsl_3d0_resources_8960ab[] = {
+	{
+		.name = KGSL_3D0_REG_MEMORY,
+		.start = 0x04300000, /* GFX3D address */
+		.end = 0x0430ffff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name = KGSL_3D0_SHADER_MEMORY,
+		.start = 0x04310000, /* Shader Mem Address (8960AB) */
+		.end = 0x0431ffff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name = KGSL_3D0_IRQ,
+		.start = GFX3D_IRQ,
+		.end = GFX3D_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+int kgsl_num_resources_8960ab = ARRAY_SIZE(kgsl_3d0_resources_8960ab);
+
+static struct resource kgsl_3d0_resources_8960[] = {
 	{
 		.name = KGSL_3D0_REG_MEMORY,
 		.start = 0x04300000, /* GFX3D address */
@@ -3416,7 +3337,6 @@
 	.num_levels = ARRAY_SIZE(grp3d_freq) + 1,
 	.set_grp_async = NULL,
 	.idle_timeout = HZ/12,
-	.nap_allowed = true,
 	.clk_map = KGSL_CLK_CORE | KGSL_CLK_IFACE | KGSL_CLK_MEM_IFACE,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.bus_scale_table = &grp3d_bus_scale_pdata,
@@ -3429,8 +3349,8 @@
 struct platform_device msm_kgsl_3d0 = {
 	.name = "kgsl-3d0",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(kgsl_3d0_resources),
-	.resource = kgsl_3d0_resources,
+	.num_resources = ARRAY_SIZE(kgsl_3d0_resources_8960),
+	.resource = kgsl_3d0_resources_8960,
 	.dev = {
 		.platform_data = &kgsl_3d0_pdata,
 	},
@@ -3483,7 +3403,6 @@
 	.num_levels = ARRAY_SIZE(grp2d_freq) + 1,
 	.set_grp_async = NULL,
 	.idle_timeout = HZ/5,
-	.nap_allowed = true,
 	.clk_map = KGSL_CLK_CORE | KGSL_CLK_IFACE,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.bus_scale_table = &grp2d0_bus_scale_pdata,
@@ -3550,7 +3469,6 @@
 	.num_levels = ARRAY_SIZE(grp2d_freq) + 1,
 	.set_grp_async = NULL,
 	.idle_timeout = HZ/5,
-	.nap_allowed = true,
 	.clk_map = KGSL_CLK_CORE | KGSL_CLK_IFACE,
 #ifdef CONFIG_MSM_BUS_SCALING
 	.bus_scale_table = &grp2d1_bus_scale_pdata,
@@ -3921,8 +3839,8 @@
 		[MSM_RPM_LOG_PAGE_BUFFER]  = 0x000000A0,
 	},
 	.phys_size = SZ_8K,
-	.log_len = 6144,		  /* log's buffer length in bytes */
-	.log_len_mask = (6144 >> 2) - 1,  /* length mask in units of u32 */
+	.log_len = 4096,		  /* log's buffer length in bytes */
+	.log_len_mask = (4096 >> 2) - 1,  /* length mask in units of u32 */
 };
 
 struct platform_device msm8960_rpm_log_device = {
@@ -4502,11 +4420,6 @@
 	},
 };
 
-struct dev_avtimer_data dev_avtimer_pdata = {
-	.avtimer_msw_phy_addr = AVTIMER_MSW_PHYSICAL_ADDRESS,
-	.avtimer_lsw_phy_addr = AVTIMER_LSW_PHYSICAL_ADDRESS,
-};
-
 #define MDM2AP_ERRFATAL			40
 #define AP2MDM_ERRFATAL			80
 #define MDM2AP_STATUS			24
diff --unified -r mach-msm/devices.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices.h
--- mach-msm/devices.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices.h	2013-12-17 17:08:05.630151131 -0800
@@ -1,7 +1,7 @@
 /* linux/arch/arm/mach-msm/devices.h
  *
  * Copyright (C) 2008 Google, Inc.
- * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -55,17 +55,13 @@
 extern struct platform_device msm_device_uart_dm6;
 extern struct platform_device msm_device_uart_dm8;
 extern struct platform_device msm_device_uart_dm9;
-extern struct platform_device mpq8064_device_uartdm_gsbi6;
 
 extern struct platform_device msm8960_device_uart_gsbi2;
 extern struct platform_device msm8960_device_uart_gsbi5;
 extern struct platform_device msm8960_device_uart_gsbi8;
-extern struct platform_device msm8930_device_uart_gsbi10;
-extern struct platform_device msm8930_device_uart_gsbi11;
 extern struct platform_device msm8960_device_ssbi_pmic;
 extern struct platform_device msm8960_device_qup_i2c_gsbi3;
 extern struct platform_device msm8960_device_qup_i2c_gsbi4;
-extern struct platform_device msm8960_device_qup_i2c_gsbi8;
 extern struct platform_device msm8960_device_qup_i2c_gsbi9;
 extern struct platform_device msm8960_device_qup_i2c_gsbi10;
 extern struct platform_device msm8960_device_qup_i2c_gsbi12;
@@ -89,7 +85,6 @@
 extern struct platform_device apq8064_device_uart_gsbi1;
 extern struct platform_device apq8064_device_uart_gsbi3;
 extern struct platform_device apq8064_device_uart_gsbi4;
-extern struct platform_device apq8064_device_uartdm_gsbi4;
 extern struct platform_device apq8064_device_uart_gsbi7;
 extern struct platform_device apq8064_device_qup_i2c_gsbi1;
 extern struct platform_device apq8064_device_qup_i2c_gsbi3;
@@ -260,10 +255,6 @@
 extern struct platform_device msm_cpudai_incall_record_tx;
 extern struct platform_device msm_i2s_cpudai0;
 extern struct platform_device msm_i2s_cpudai1;
-extern struct platform_device msm_i2s_cpudai4;
-extern struct platform_device msm_i2s_cpudai5;
-extern struct platform_device msm_cpudai_stub;
-extern struct platform_device msm_fm_loopback;
 
 extern struct platform_device msm_pil_q6v3;
 extern struct platform_device msm_pil_modem;
@@ -339,6 +330,9 @@
 extern struct platform_device msm_kgsl_2d0;
 extern struct platform_device msm_kgsl_2d1;
 
+extern struct resource kgsl_3d0_resources_8960ab[];
+extern int kgsl_num_resources_8960ab;
+
 extern struct platform_device msm_mipi_dsi1_device;
 extern struct platform_device mipi_dsi_device;
 extern struct platform_device msm_lvds_device;
@@ -473,11 +467,3 @@
 extern struct platform_device apq8064_msm_mpd_device;
 
 extern struct platform_device msm_gpio_device;
-
-extern struct platform_device amdm_8064_device;
-extern struct platform_device bmdm_8064_device;
-
-extern struct platform_device sglte_mdm_8064_device;
-extern struct platform_device sglte2_qsc_8064_device;
-
-extern struct dev_avtimer_data dev_avtimer_pdata;
diff --unified -r mach-msm/devices-msm7x30.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-msm7x30.c
--- mach-msm/devices-msm7x30.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-msm7x30.c	2013-12-17 17:08:05.630151131 -0800
@@ -18,7 +18,6 @@
 #include <linux/msm_rotator.h>
 #include <linux/dma-mapping.h>
 #include <mach/kgsl.h>
-#include <linux/android_pmem.h>
 #include <linux/regulator/machine.h>
 #include <linux/init.h>
 #include <mach/irqs.h>
diff --unified -r mach-msm/devices-msm8x60.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-msm8x60.c
--- mach-msm/devices-msm8x60.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-msm8x60.c	2013-12-17 17:08:05.630151131 -0800
@@ -45,7 +45,6 @@
 #ifdef CONFIG_MSM_DSPS
 #include <mach/msm_dsps.h>
 #endif
-#include <linux/android_pmem.h>
 #include <linux/gpio.h>
 #include <linux/delay.h>
 #include <mach/mdm.h>
@@ -348,7 +347,6 @@
 	.uart_tx_gpio	= 67,
 	.uart_rx_gpio	= 66,
 	.line		= 1,
-	.set_uart_clk_zero = true,
 };
 
 static struct resource msm_uart_gsbi9_resources[] = {
diff --unified -r mach-msm/devices-msm8x60.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-msm8x60.h
--- mach-msm/devices-msm8x60.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/devices-msm8x60.h	2013-12-17 17:08:05.630151131 -0800
@@ -39,7 +39,7 @@
 #define I2C_LEDS_BUS_ID			21
 #define MSM_NFC_I2C_BUS_ID		17
 
-#if defined(CONFIG_CAMERA_SW_I2C)|| defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_CAMERA_SW_I2C)|| defined(CONFIG_MACH_JACTIVE_ATT)
 #define MSM_CAMERA_SW_I2C_BUS_ID		27//CAMERA_SW_I2C
 #endif
 
Only in mach-msm: early_random.c
diff --unified -r mach-msm/ebi_erp.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ebi_erp.c
--- mach-msm/ebi_erp.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ebi_erp.c	2013-12-17 17:08:05.630151131 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,9 +18,6 @@
 #include <linux/errno.h>
 #include <linux/proc_fs.h>
 #include <linux/cpu.h>
-#include <mach/usb_trace.h>
-
-DEFINE_TRACE(usb_daytona_invalid_access);
 
 #define MODULE_NAME "msm_ebi_erp"
 
@@ -116,11 +113,6 @@
 	err_cntl |= CNTL_CLEAR_ERR;
 	writel_relaxed(err_cntl, base + SLV_ERR_CNTL);
 	mb();	/* Ensure interrupt is cleared before returning */
-
-	if ((err_apacket0 & AMID_MASK) == 0x00000102)
-		trace_usb_daytona_invalid_access(err_addr, err_apacket0,
-							 err_apacket1);
-
 	return IRQ_HANDLED;
 }
 
diff --unified -r mach-msm/etm.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/etm.c
--- mach-msm/etm.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/etm.c	2013-12-17 17:08:05.634151123 -0800
@@ -24,7 +24,8 @@
 #include <linux/pm_qos.h>
 
 #include <asm/atomic.h>
-#include <asm/hardware/cp14.h>
+
+#include "cp14.h"
 
 #define LOG_BUF_LEN			32768
 /* each slot is 4 bytes, 8kb total */
diff --unified -r mach-msm/event_timer.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/event_timer.c
--- mach-msm/event_timer.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/event_timer.c	2013-12-17 17:08:05.634151123 -0800
@@ -37,9 +37,9 @@
 	void *data;
 };
 
+
 static DEFINE_TIME_HEAD(timer_head);
 static DEFINE_SPINLOCK(event_timer_lock);
-static DEFINE_SPINLOCK(event_setup_lock);
 static struct hrtimer event_hrtimer;
 static enum hrtimer_restart event_hrtimer_cb(struct hrtimer *hrtimer);
 
@@ -73,9 +73,6 @@
 	event_info->data = data;
 	/* Init rb node and hr timer */
 	timerqueue_init(&event_info->node);
-	pr_debug("%s: New Event Added. Event 0x%x.",
-	__func__,
-	(unsigned int)event_info);
 
 	return event_info;
 }
@@ -143,6 +140,10 @@
 
 	event_hrtimer.function = event_hrtimer_cb;
 	hrtimer_start(&event_hrtimer, expires, HRTIMER_MODE_ABS);
+
+	if (msm_event_debug_mask && MSM_EVENT_TIMER_DEBUG)
+		pr_info("%s: Setting timer for %lu", __func__,
+			(unsigned long)ktime_to_ns(expires));
 }
 
 /**
@@ -154,9 +155,7 @@
 {
 	struct event_timer_info *event;
 	struct timerqueue_node *next;
-	unsigned long flags;
 
-	spin_lock_irqsave(&event_timer_lock, flags);
 	next = timerqueue_getnext(&timer_head);
 
 	while (next && (ktime_to_ns(next->expires)
@@ -169,8 +168,7 @@
 			goto hrtimer_cb_exit;
 
 		if (msm_event_debug_mask && MSM_EVENT_TIMER_DEBUG)
-			pr_info("%s: Deleting event 0x%x @ %lu", __func__,
-			(unsigned int)event,
+			pr_info("%s: Deleting event @ %lu", __func__,
 			(unsigned long)ktime_to_ns(next->expires));
 
 		timerqueue_del(&timer_head, &event->node);
@@ -183,7 +181,6 @@
 	if (next)
 		create_hrtimer(next->expires);
 
-	spin_unlock_irqrestore(&event_timer_lock, flags);
 hrtimer_cb_exit:
 	return HRTIMER_NORESTART;
 }
@@ -204,10 +201,7 @@
 
 	next = timerqueue_getnext(&timer_head);
 	timerqueue_add(&timer_head, &event->node);
-	if (msm_event_debug_mask && MSM_EVENT_TIMER_DEBUG)
-		pr_info("%s: Adding Event 0x%x for %lu", __func__,
-		(unsigned int)event,
-		(unsigned long)ktime_to_ns(event->node.expires));
+	spin_unlock_irqrestore(&event_timer_lock, flags);
 
 	if (!next ||
 		(next && (ktime_to_ns(event->node.expires) <
@@ -217,7 +211,6 @@
 			(unsigned long)ktime_to_ns(event->node.expires));
 		create_hrtimer(event->node.expires);
 	}
-	spin_unlock_irqrestore(&event_timer_lock, flags);
 }
 
 /**
@@ -246,11 +239,9 @@
 		pr_info("%s: Adding event timer @ %lu", __func__,
 				(unsigned long)ktime_to_us(event_time));
 
-	spin_lock(&event_setup_lock);
 	event->node.expires = event_time;
 	/* Start hr timer and add event to rb tree */
 	setup_event_hrtimer(event);
-	spin_unlock(&event_setup_lock);
 }
 
 
diff --unified -r mach-msm/footswitch-8x60.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/footswitch-8x60.c
--- mach-msm/footswitch-8x60.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/footswitch-8x60.c	2013-12-17 17:08:05.634151123 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -25,7 +25,10 @@
 #include <mach/msm_bus.h>
 #include <mach/scm-io.h>
 #include <mach/clk.h>
+#include <mach/rpm.h>
+
 #include "footswitch.h"
+#include "rpm_resources.h"
 
 #ifdef CONFIG_MSM_SECURE_IO
 #undef readl_relaxed
@@ -52,7 +55,7 @@
 
 #define GFS_DELAY_CNT		31
 
-#define RESET_DELAY_US		1
+#define DEFAULT_RESET_DELAY_US	1
 /* Clock rate to use if one has not previously been set. */
 #define DEFAULT_RATE		27000000
 #define MAX_CLKS		10
@@ -72,6 +75,7 @@
 	bool			is_claimed;
 	struct fs_clk_data	*clk_data;
 	struct clk		*core_clk;
+	unsigned long		reset_delay_us;
 };
 
 static int setup_clocks(struct footswitch *fs)
@@ -181,7 +185,7 @@
 	for (clock--; clock >= fs->clk_data; clock--)
 		clk_reset(clock->clk, CLK_RESET_ASSERT);
 	/* Wait for synchronous resets to propagate. */
-	udelay(RESET_DELAY_US);
+	udelay(fs->reset_delay_us);
 
 	/* Enable the power rail at the footswitch. */
 	regval |= ENABLE_BIT;
@@ -202,9 +206,9 @@
 	/* Toggle core reset again after first power-on (required for GFX3D). */
 	if (fs->desc.id == FS_GFX3D) {
 		clk_reset(fs->core_clk, CLK_RESET_ASSERT);
-		udelay(RESET_DELAY_US);
+		udelay(fs->reset_delay_us);
 		clk_reset(fs->core_clk, CLK_RESET_DEASSERT);
-		udelay(RESET_DELAY_US);
+		udelay(fs->reset_delay_us);
 	}
 
 	/* Prevent core memory from collapsing when its clock is gated. */
@@ -240,7 +244,8 @@
 		return rc;
 
 	/* Allow core memory to collapse when its clock is gated. */
-	clk_set_flags(fs->core_clk, CLKFLAG_NORETAIN);
+	if (fs->desc.id != FS_GFX3D_8064)
+		clk_set_flags(fs->core_clk, CLKFLAG_NORETAIN);
 
 	/* Halt all bus ports in the power domain. */
 	if (fs->bus_port0) {
@@ -267,7 +272,7 @@
 	for (clock--; clock >= fs->clk_data; clock--)
 		clk_reset(clock->clk, CLK_RESET_ASSERT);
 	/* Wait for synchronous resets to propagate. */
-	udelay(RESET_DELAY_US);
+	udelay(fs->reset_delay_us);
 
 	/*
 	 * Return clocks to their state before this function. For robustness
@@ -342,7 +347,7 @@
 	for (clock--; clock >= fs->clk_data; clock--)
 		clk_reset(clock->clk, CLK_RESET_ASSERT);
 	/* Wait for synchronous resets to propagate. */
-	udelay(RESET_DELAY_US);
+	udelay(fs->reset_delay_us);
 
 	/* Enable the power rail at the footswitch. */
 	regval |= ENABLE_BIT;
@@ -357,7 +362,7 @@
 	/* Deassert resets for all clocks in the power domain. */
 	for (clock = fs->clk_data; clock->clk; clock++)
 		clk_reset(clock->clk, CLK_RESET_DEASSERT);
-	udelay(RESET_DELAY_US);
+	udelay(fs->reset_delay_us);
 
 	/* Re-enable core clock. */
 	clk_prepare_enable(fs->core_clk);
@@ -444,6 +449,119 @@
 	return rc;
 }
 
+static void force_bus_clocks(bool enforce)
+{
+	static struct msm_rpm_iv_pair iv;
+	int ret;
+
+	if (enforce) {
+		iv.id = MSM_RPM_STATUS_ID_RPM_CTL;
+		ret = msm_rpm_get_status(&iv, 1);
+		if (ret)
+			pr_err("Failed to read RPM_CTL resource status\n");
+
+		iv.id = MSM_RPM_ID_RPM_CTL;
+		iv.value |= BIT(6);
+	} else {
+		iv.id = MSM_RPM_ID_RPM_CTL;
+		iv.value &= ~BIT(6);
+	}
+
+	ret = msm_rpmrs_set(MSM_RPM_CTX_SET_0, &iv, 1);
+	if (ret)
+		pr_err("Force bus clocks request=%d failed\n", enforce);
+}
+
+static int gfx3d_8064_footswitch_enable(struct regulator_dev *rdev)
+{
+	struct footswitch *fs = rdev_get_drvdata(rdev);
+	struct fs_clk_data *clock;
+	uint32_t regval, rc = 0;
+
+	mutex_lock(&claim_lock);
+	fs->is_claimed = true;
+	mutex_unlock(&claim_lock);
+
+	/* Return early if already enabled. */
+	regval = readl_relaxed(fs->gfs_ctl_reg);
+	if ((regval & (ENABLE_BIT | CLAMP_BIT)) == ENABLE_BIT)
+		return 0;
+
+	/* Un-halt all bus ports in the power domain. */
+	if (fs->bus_port0) {
+		rc = msm_bus_axi_portunhalt(fs->bus_port0);
+		if (rc) {
+			pr_err("%s port 0 unhalt failed.\n", fs->desc.name);
+			goto err;
+		}
+	}
+	if (fs->bus_port1) {
+		rc = msm_bus_axi_portunhalt(fs->bus_port1);
+		if (rc) {
+			pr_err("%s port 1 unhalt failed.\n", fs->desc.name);
+			goto err_port2_halt;
+		}
+	}
+
+	/* Apply AFAB/EBI clock limits. */
+	force_bus_clocks(true);
+
+	/* Enable the power rail at the footswitch. */
+	regval |= ENABLE_BIT;
+	writel_relaxed(regval, fs->gfs_ctl_reg);
+	/* Wait for the rail to fully charge. */
+	mb();
+	udelay(1);
+
+	/* Make sure required clocks are on at the correct rates. */
+	rc = setup_clocks(fs);
+	if (rc)
+		goto err_setup_clocks;
+
+	/*
+	 * (Re-)Assert resets for all clocks in the clock domain, since
+	 * footswitch_enable() is first called before footswitch_disable()
+	 * and resets should be asserted before power is restored.
+	 */
+	for (clock = fs->clk_data; clock->clk; clock++)
+		; /* Do nothing */
+	for (clock--; clock >= fs->clk_data; clock--)
+		clk_reset(clock->clk, CLK_RESET_ASSERT);
+	/* Wait for synchronous resets to propagate. */
+	udelay(fs->reset_delay_us);
+
+	/* Un-clamp the I/O ports. */
+	regval &= ~CLAMP_BIT;
+	writel_relaxed(regval, fs->gfs_ctl_reg);
+
+	/* Deassert resets for all clocks in the power domain. */
+	for (clock = fs->clk_data; clock->clk; clock++)
+		clk_reset(clock->clk, CLK_RESET_DEASSERT);
+
+	/* Prevent core memory from collapsing when its clock is gated. */
+	clk_set_flags(fs->core_clk, CLKFLAG_RETAIN);
+
+	/* Return clocks to their state before this function. */
+	restore_clocks(fs);
+
+	/* Remove AFAB/EBI clock limits after any transients have settled. */
+	udelay(30);
+	force_bus_clocks(false);
+
+	fs->is_enabled = true;
+	return 0;
+
+err_setup_clocks:
+	regval &= ~ENABLE_BIT;
+	writel_relaxed(regval, fs->gfs_ctl_reg);
+	force_bus_clocks(false);
+err_port2_halt:
+	msm_bus_axi_porthalt(fs->bus_port0);
+err:
+	return rc;
+}
+
+
 static struct regulator_ops standard_fs_ops = {
 	.is_enabled = footswitch_is_enabled,
 	.enable = footswitch_enable,
@@ -456,6 +574,12 @@
 	.disable = gfx2d_footswitch_disable,
 };
 
+static struct regulator_ops gfx3d_8064_fs_ops = {
+	.is_enabled = footswitch_is_enabled,
+	.enable = gfx3d_8064_footswitch_enable,
+	.disable = footswitch_disable,
+};
+
 #define FOOTSWITCH(_id, _name, _ops, _gfs_ctl_reg) \
 	[(_id)] = { \
 		.desc = { \
@@ -470,6 +594,8 @@
 static struct footswitch footswitches[] = {
 	FOOTSWITCH(FS_GFX2D0, "fs_gfx2d0", &gfx2d_fs_ops, GFX2D0_GFS_CTL_REG),
 	FOOTSWITCH(FS_GFX2D1, "fs_gfx2d1", &gfx2d_fs_ops, GFX2D1_GFS_CTL_REG),
+	FOOTSWITCH(FS_GFX3D_8064, "fs_gfx3d", &gfx3d_8064_fs_ops,
+		   GFX3D_GFS_CTL_REG),
 	FOOTSWITCH(FS_GFX3D,  "fs_gfx3d", &standard_fs_ops, GFX3D_GFS_CTL_REG),
 	FOOTSWITCH(FS_IJPEG,  "fs_ijpeg", &standard_fs_ops, GEMINI_GFS_CTL_REG),
 	FOOTSWITCH(FS_MDP,    "fs_mdp",   &standard_fs_ops, MDP_GFS_CTL_REG),
@@ -500,6 +626,8 @@
 	fs->clk_data = driver_data->clks;
 	fs->bus_port0 = driver_data->bus_port0;
 	fs->bus_port1 = driver_data->bus_port1;
+	fs->reset_delay_us =
+		driver_data->reset_delay_us ? : DEFAULT_RESET_DELAY_US;
 
 	for (clock = fs->clk_data; clock->name; clock++) {
 		clock->clk = clk_get(&pdev->dev, clock->name);
diff --unified -r mach-msm/footswitch.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/footswitch.h
--- mach-msm/footswitch.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/footswitch.h	2013-12-17 17:08:05.634151123 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012 The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -28,7 +28,8 @@
 #define FS_VFE		8
 #define FS_VPE		9
 #define FS_VCAP		10
-#define MAX_FS		11
+#define FS_GFX3D_8064	11
+#define MAX_FS		12
 
 struct fs_clk_data {
 	const char *name;
@@ -41,6 +42,7 @@
 struct fs_driver_data {
 	int bus_port0, bus_port1;
 	struct fs_clk_data *clks;
+	unsigned long reset_delay_us;
 };
 
 #define FS_GENERIC(_drv_name, _id, _name, _dev_id, _data) \
diff --unified -r mach-msm/gpiomux.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/gpiomux.c
--- mach-msm/gpiomux.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/gpiomux.c	2013-12-17 17:08:05.634151123 -0800
@@ -17,15 +17,6 @@
 #include <linux/gpio.h>
 #include <mach/irqs.h>
 
-#ifdef CONFIG_SEC_GPIO_DVS
-#include <linux/errno.h>
-#include <linux/io.h>
-#include <mach/msm_iomap.h>
-
-#include <linux/secgpio_dvs.h>
-#include <linux/platform_device.h>
-#endif
-
 struct msm_gpiomux_rec {
 	struct gpiomux_setting *sets[GPIOMUX_NSETTINGS];
 	int ref;
@@ -35,112 +26,6 @@
 static struct gpiomux_setting *msm_gpiomux_sets;
 static unsigned msm_gpiomux_ngpio;
 
-#ifdef CONFIG_SEC_GPIO_DVS
-
-/****************************************************************/
-/* Define value in accordance with
-	the specification of each BB vendor. */
-#define AP_GPIO_COUNT	90
-/****************************************************************/
-
-enum {
-	GPIO_IN_BIT  = 0,
-	GPIO_OUT_BIT = 1
-};
-
-#define GPIO_IN_OUT(gpio)        (MSM_TLMM_BASE + 0x1004 + (0x10 * (gpio)))
-
-#define GET_RESULT_GPIO(a, b, c)	\
-	((a<<4 & 0xF0) | (b<<1 & 0xE) | (c & 0x1))
-
-/****************************************************************/
-/* Pre-defined variables. (DO NOT CHANGE THIS!!) */
-static unsigned char checkgpiomap_result[GDVS_PHONE_STATUS_MAX][AP_GPIO_COUNT];
-static struct gpiomap_result gpiomap_result = {
-	.init = checkgpiomap_result[PHONE_INIT],
-	.sleep = checkgpiomap_result[PHONE_SLEEP]
-};
-/****************************************************************/
-
-static unsigned __msm_gpio_get_inout_lh(unsigned gpio)
-{
-	return __raw_readl(GPIO_IN_OUT(gpio)) & BIT(GPIO_IN_BIT);
-}
-
-static void msm8x30_check_gpio_status(unsigned char phonestate)
-{
-	struct gpiomux_setting val;
-
-	u32 i;
-
-	u8 temp_io = 0, temp_pdpu = 0, temp_lh = 0;
-
-	pr_info("[secgpio_dvs][%s] state : %s\n", __func__,
-		(phonestate == PHONE_INIT) ? "init" : "sleep");
-
-	for (i = 0; i < AP_GPIO_COUNT; i++) {
-		msm_gpiomux_read(i, &val);
-
-		if (val.func == GPIOMUX_FUNC_GPIO) {
-			if (val.dir == GPIOMUX_IN)
-				temp_io = 0x01;	/* GPIO_IN */
-			else if (val.dir == GPIOMUX_OUT_HIGH ||
-					val.dir == GPIOMUX_OUT_LOW)
-				temp_io = 0x02;	/* GPIO_OUT */
-			else {
-				temp_io = 0xF;	/* not alloc. */
-				pr_err("[secgpio_dvs] gpio : %d, val.dir : %d, temp_io = 0x3",
-					i, val.dir);
-			}
-		} else {
-			temp_io = 0x0;		/* FUNC */
-		}
-
-		if (val.pull  == GPIOMUX_PULL_NONE)
-			temp_pdpu = 0x00;
-		else if (val.pull  == GPIOMUX_PULL_DOWN)
-			temp_pdpu = 0x01;
-		else if (val.pull == GPIOMUX_PULL_UP)
-			temp_pdpu = 0x02;
-		else if (val.pull == GPIOMUX_PULL_KEEPER)
-			temp_pdpu = 0x03;
-		else {
-			temp_pdpu = 0x07;
-			pr_err("[secgpio_dvs] gpio : %d, val.pull : %d, temp_pdpu : %d",
-				i, val.pull, temp_pdpu);
-		}
-
-		if (val.func == GPIOMUX_FUNC_GPIO) {
-			if (val.dir == GPIOMUX_OUT_LOW)
-				temp_lh = 0x00;
-			else if (val.dir == GPIOMUX_OUT_HIGH)
-				temp_lh = 0x01;
-			else if (val.dir == GPIOMUX_IN)
-				temp_lh = __msm_gpio_get_inout_lh(i);
-		} else
-			temp_lh = 0;
-
-
-		checkgpiomap_result[phonestate][i] =
-			GET_RESULT_GPIO(temp_io, temp_pdpu, temp_lh);
-	}
-
-	pr_info("[secgpio_dvs][%s]-\n", __func__);
-
-	return;
-}
-
-/****************************************************************/
-/* Define appropriate variable in accordance with
-	the specification of each BB vendor */
-static struct gpio_dvs msm8x30_gpio_dvs = {
-	.result = &gpiomap_result,
-	.check_gpio_status = msm8x30_check_gpio_status,
-	.count = AP_GPIO_COUNT,
-};
-/****************************************************************/
-#endif
-
 int msm_gpiomux_write(unsigned gpio, enum msm_gpiomux_setting which,
 	struct gpiomux_setting *setting, struct gpiomux_setting *old_setting)
 {
@@ -338,26 +223,3 @@
 	}
 }
 EXPORT_SYMBOL(msm_gpiomux_install);
-
-#ifdef CONFIG_SEC_GPIO_DVS
-static struct platform_device secgpio_dvs_device = {
-	.name	= "secgpio_dvs",
-	.id		= -1,
-/****************************************************************/
-/* Designate appropriate variable pointer
-	in accordance with the specification of each BB vendor. */
-	.dev.platform_data = &msm8x30_gpio_dvs,
-/****************************************************************/
-};
-
-static struct platform_device *secgpio_dvs_devices[] __initdata = {
-	&secgpio_dvs_device,
-};
-
-static int __init secgpio_dvs_device_init(void)
-{
-	return platform_add_devices(
-		secgpio_dvs_devices, ARRAY_SIZE(secgpio_dvs_devices));
-}
-arch_initcall(secgpio_dvs_device_init);
-#endif
diff --unified -r mach-msm/hotplug.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hotplug.c
--- mach-msm/hotplug.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hotplug.c	2013-12-17 17:08:05.634151123 -0800
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 2002 ARM Ltd.
  *  All Rights Reserved
- *  Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *  Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -24,13 +24,9 @@
 
 extern volatile int pen_release;
 
-struct msm_hotplug_device {
-	struct completion cpu_killed;
-	unsigned int warm_boot;
-};
+static cpumask_t cpu_dying_mask;
 
-static DEFINE_PER_CPU_SHARED_ALIGNED(struct msm_hotplug_device,
-			msm_hotplug_devices);
+static DEFINE_PER_CPU(unsigned int, warm_boot_flag);
 
 static inline void cpu_enter_lowpower(void)
 {
@@ -70,13 +66,12 @@
 
 int platform_cpu_kill(unsigned int cpu)
 {
-	int ret;
+	int ret = 0;
 
-	ret = msm_pm_wait_cpu_shutdown(cpu);
-	if (ret)
-		return 0;
+	if (cpumask_test_and_clear_cpu(cpu, &cpu_dying_mask))
+		ret = msm_pm_wait_cpu_shutdown(cpu);
 
-	return 1;
+	return ret ? 0 : 1;
 }
 
 /*
@@ -93,7 +88,6 @@
 			__func__, smp_processor_id(), cpu);
 		BUG();
 	}
-	complete(&__get_cpu_var(msm_hotplug_devices).cpu_killed);
 	/*
 	 * we're ready for shutdown now, so do it
 	 */
@@ -143,6 +137,7 @@
 		uncached_logk(LOGK_HOTPLUG, (void *)(cpudata | this_cpumask));
 		break;
 	case CPU_DYING:
+		cpumask_set_cpu((unsigned long)hcpu, &cpu_dying_mask);
 		uncached_logk(LOGK_HOTPLUG, (void *)(cpudata & ~this_cpumask));
 		break;
 	default:
@@ -158,11 +153,10 @@
 int msm_platform_secondary_init(unsigned int cpu)
 {
 	int ret;
-	struct msm_hotplug_device *dev = &__get_cpu_var(msm_hotplug_devices);
+	unsigned int *warm_boot = &__get_cpu_var(warm_boot_flag);
 
-	if (!dev->warm_boot) {
-		dev->warm_boot = 1;
-		init_completion(&dev->cpu_killed);
+	if (!(*warm_boot)) {
+		*warm_boot = 1;
 		return 0;
 	}
 	msm_jtag_restore_state();
@@ -176,9 +170,6 @@
 
 static int __init init_hotplug(void)
 {
-
-	struct msm_hotplug_device *dev = &__get_cpu_var(msm_hotplug_devices);
-	init_completion(&dev->cpu_killed);
 	return register_hotcpu_notifier(&hotplug_rtb_notifier);
 }
 early_initcall(init_hotplug);
diff --unified -r mach-msm/hsic_sysmon.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hsic_sysmon.c
--- mach-msm/hsic_sysmon.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hsic_sysmon.c	2013-12-17 17:08:05.634151123 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -239,7 +239,7 @@
 		if (!hs)
 			continue;
 
-		ret += scnprintf(buf + ret, DEBUG_BUF_SIZE - ret,
+		ret += scnprintf(buf, DEBUG_BUF_SIZE,
 				"---HSIC Sysmon #%d---\n"
 				"epin:%d, epout:%d\n"
 				"bytes to host: %d\n"
@@ -324,6 +324,15 @@
 	struct usb_endpoint_descriptor	*ep_desc;
 	int				i;
 	int				ret = -ENOMEM;
+	__u8				ifc_num;
+
+	pr_debug("id:%lu", id->driver_info);
+
+	ifc_num = ifc->cur_altsetting->desc.bInterfaceNumber;
+
+	/* is this the interface we're looking for? */
+	if (ifc_num != id->driver_info)
+		return -ENODEV;
 
 	hs = kzalloc(sizeof(*hs), GFP_KERNEL);
 	if (!hs) {
@@ -358,17 +367,12 @@
 		goto error;
 	}
 
-	hs->id = HSIC_SYSMON_DEV_EXT_MODEM + id->driver_info;
-	if (hs->id >= NUM_HSIC_SYSMON_DEVS) {
-		pr_warn("invalid dev id(%d)", hs->id);
-		hs->id = 0;
-	}
-
-	hsic_sysmon_devices[hs->id] = hs;
+	hs->id = HSIC_SYSMON_DEV_EXT_MODEM;
+	hsic_sysmon_devices[HSIC_SYSMON_DEV_EXT_MODEM] = hs;
 	usb_set_intfdata(ifc, hs);
 
 	hs->pdev.name = "sys_mon";
-	hs->pdev.id = SYSMON_SS_EXT_MODEM + hs->id;
+	hs->pdev.id = SYSMON_SS_EXT_MODEM;
 	hs->pdev.dev.release = hsic_sysmon_pdev_release;
 	platform_device_register(&hs->pdev);
 
@@ -402,13 +406,10 @@
 	return 0;
 }
 
-/* driver_info is the instance number when multiple devices are present */
+/* driver_info maps to the interface number corresponding to sysmon */
 static const struct usb_device_id hsic_sysmon_ids[] = {
-	{ USB_DEVICE_INTERFACE_NUMBER(0x5c6, 0x9048, 1), .driver_info = 0, },
-	{ USB_DEVICE_INTERFACE_NUMBER(0x5c6, 0x904C, 1), .driver_info = 0, },
-	{ USB_DEVICE_INTERFACE_NUMBER(0x5c6, 0x9075, 1), .driver_info = 0, },
-	{ USB_DEVICE_INTERFACE_NUMBER(0x5c6, 0x9079, 1), .driver_info = 1, },
-	{ USB_DEVICE_INTERFACE_NUMBER(0x5c6, 0x908A, 1), .driver_info = 0, },
+	{ USB_DEVICE(0x5c6, 0x9048), .driver_info = 1, },
+	{ USB_DEVICE(0x5c6, 0x904C), .driver_info = 1, },
 	{} /* terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, hsic_sysmon_ids);
diff --unified -r mach-msm/hsic_sysmon.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hsic_sysmon.h
--- mach-msm/hsic_sysmon.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hsic_sysmon.h	2013-12-17 17:08:05.634151123 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,7 +18,6 @@
  */
 enum hsic_sysmon_device_id {
 	HSIC_SYSMON_DEV_EXT_MODEM,
-	HSIC_SYSMON_DEV_EXT_MODEM_2,
 	NUM_HSIC_SYSMON_DEVS
 };
 
diff --unified -r mach-msm/hsic_sysmon_test.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hsic_sysmon_test.c
--- mach-msm/hsic_sysmon_test.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/hsic_sysmon_test.c	2013-12-17 17:08:05.634151123 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -15,7 +15,6 @@
 
 #include <linux/slab.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/debugfs.h>
 #include <linux/uaccess.h>
@@ -37,14 +36,13 @@
 				 size_t count, loff_t *ppos)
 {
 	struct sysmon_test_dev *dev = sysmon_dev;
-	enum hsic_sysmon_device_id id =
-				(enum hsic_sysmon_device_id)file->private_data;
 	int ret;
 
 	if (!dev)
 		return -ENODEV;
 
-	ret = hsic_sysmon_read(id, dev->buf, RD_BUF_SIZE, &dev->buflen, 3000);
+	ret = hsic_sysmon_read(HSIC_SYSMON_DEV_EXT_MODEM, dev->buf, RD_BUF_SIZE,
+				&dev->buflen, 3000);
 	if (!ret)
 		return simple_read_from_buffer(ubuf, count, ppos,
 					dev->buf, dev->buflen);
@@ -55,9 +53,7 @@
 static ssize_t sysmon_test_write(struct file *file, const char __user *ubuf,
 				 size_t count, loff_t *ppos)
 {
-	struct sysmon_test_dev *dev = sysmon_dev;
-	enum hsic_sysmon_device_id id =
-				(enum hsic_sysmon_device_id)file->private_data;
+	struct sysmon_test_dev	*dev = sysmon_dev;
 	int ret;
 
 	if (!dev)
@@ -68,7 +64,8 @@
 		return 0;
 	}
 
-	ret = hsic_sysmon_write(id, dev->buf, count, 1000);
+	ret = hsic_sysmon_write(HSIC_SYSMON_DEV_EXT_MODEM,
+				dev->buf, count, 1000);
 	if (ret < 0) {
 		pr_err("error writing to hsic_sysmon");
 		return ret;
@@ -79,44 +76,38 @@
 
 static int sysmon_test_open(struct inode *inode, struct file *file)
 {
-	file->private_data = inode->i_private;
-	return hsic_sysmon_open((enum hsic_sysmon_device_id)inode->i_private);
+	return hsic_sysmon_open(HSIC_SYSMON_DEV_EXT_MODEM);
 }
 
 static int sysmon_test_release(struct inode *inode, struct file *file)
 {
-	hsic_sysmon_close((enum hsic_sysmon_device_id)inode->i_private);
+	hsic_sysmon_close(HSIC_SYSMON_DEV_EXT_MODEM);
 	return 0;
 }
 
-static const struct file_operations sysmon_test_ops = {
+static struct dentry *dfile;
+const struct file_operations sysmon_test_ops = {
 	.read = sysmon_test_read,
 	.write = sysmon_test_write,
 	.open = sysmon_test_open,
 	.release = sysmon_test_release
 };
 
-static struct dentry *dfile0, *dfile1;
-
 static int __init sysmon_test_init(void)
 {
 	sysmon_dev = kzalloc(sizeof(*sysmon_dev), GFP_KERNEL);
 	if (!sysmon_dev)
 		return -ENOMEM;
 
-	dfile0 = debugfs_create_file("hsic_sysmon_test.0", 0666, NULL,
-			(void *)HSIC_SYSMON_DEV_EXT_MODEM, &sysmon_test_ops);
-	dfile1 = debugfs_create_file("hsic_sysmon_test.1", 0666, NULL,
-			(void *)HSIC_SYSMON_DEV_EXT_MODEM_2, &sysmon_test_ops);
+	dfile = debugfs_create_file("hsic_sysmon_test", 0666, NULL,
+			0, &sysmon_test_ops);
 	return 0;
 }
 
 static void __exit sysmon_test_exit(void)
 {
-	if (dfile0)
-		debugfs_remove(dfile0);
-	if (dfile1)
-		debugfs_remove(dfile1);
+	if (dfile)
+		debugfs_remove(dfile);
 	kfree(sysmon_dev);
 }
 
diff --unified -r mach-msm/idle-v7.S /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/idle-v7.S
--- mach-msm/idle-v7.S	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/idle-v7.S	2013-12-17 17:08:05.634151123 -0800
@@ -2,7 +2,7 @@
  * Idle processing for ARMv7-based Qualcomm SoCs.
  *
  * Copyright (C) 2007 Google, Inc.
- * Copyright (c) 2007-2009, 2011-2013 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2007-2009, 2011-2012 The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -97,7 +97,7 @@
 	mrc     p15, 0, ip, c13, c0, 1 /* context ID */
 	stmia   r0!, {r1-r9, ip}
 
-#if defined(CONFIG_MSM_JTAG) || defined(CONFIG_MSM_JTAG_MM)
+#ifdef CONFIG_MSM_JTAG
 	bl      msm_jtag_save_state
 #endif
 
@@ -169,7 +169,7 @@
 
 skip_pc_debug2:
 
-#if defined(CONFIG_MSM_JTAG) || defined(CONFIG_MSM_JTAG_MM)
+#ifdef CONFIG_MSM_JTAG
 	bl	msm_jtag_restore_state
 #endif
 	ldr     r0, =msm_saved_state	/* address of msm_saved_state ptr */
@@ -264,7 +264,7 @@
 	SET_SMP_COHERENCY ON
 #endif
 
-#if defined(CONFIG_MSM_JTAG) || defined(CONFIG_MSM_JTAG_MM)
+#ifdef CONFIG_MSM_JTAG
 	stmfd   sp!, {lr}
 	bl      msm_jtag_restore_state
 	ldmfd   sp!, {lr}
diff --unified -r mach-msm/include/mach/bam_dmux.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/bam_dmux.h
--- mach-msm/include/mach/bam_dmux.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/bam_dmux.h	2013-12-17 17:08:05.634151123 -0800
@@ -28,18 +28,6 @@
 	BAM_DMUX_DATA_RMNET_6,
 	BAM_DMUX_DATA_RMNET_7,
 	BAM_DMUX_USB_RMNET_0,
-	BAM_DMUX_RESERVED_0, /* 9..11 are reserved*/
-	BAM_DMUX_RESERVED_1,
-	BAM_DMUX_RESERVED_2,
-	BAM_DMUX_DATA_REV_RMNET_0,
-	BAM_DMUX_DATA_REV_RMNET_1,
-	BAM_DMUX_DATA_REV_RMNET_2,
-	BAM_DMUX_DATA_REV_RMNET_3,
-	BAM_DMUX_DATA_REV_RMNET_4,
-	BAM_DMUX_DATA_REV_RMNET_5,
-	BAM_DMUX_DATA_REV_RMNET_6,
-	BAM_DMUX_DATA_REV_RMNET_7,
-	BAM_DMUX_DATA_REV_RMNET_8,
 	BAM_DMUX_NUM_CHANNELS
 };
 
diff --unified -r mach-msm/include/mach/board.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/board.h
--- mach-msm/include/mach/board.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/board.h	2013-12-17 17:08:05.634151123 -0800
@@ -84,7 +84,7 @@
 #define MSM_CAMERA_FLASH_SRC_EXT     (0x00000001<<3)
 #define MSM_CAMERA_FLASH_SRC_LED (0x00000001<<3)
 #define MSM_CAMERA_FLASH_SRC_LED1 (0x00000001<<4)
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 #define MSM_CAMERA_FLASH_SRC_PMIC_GPIO (0x00000001<<5) /* richardra added 3 */
 #endif
 
@@ -97,7 +97,7 @@
 	int (*pmic_set_current)(enum pmic8058_leds id, unsigned mA);
 };
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 /* richardra added 4 */
 struct msm_camera_sensor_flash_pmic_gpio {
 	uint8_t num_of_src;
@@ -139,7 +139,7 @@
 	const int led_name_len;
 };
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
+#if defined(CONFIG_MACH_JACTIVE_ATT)
 struct msm_camera_sensor_flash_src {
 	int flash_sr_type;
 
@@ -440,7 +440,7 @@
 	int (*vga_switch)(int select_vga);
 	int *gpio_num;
 	u32 mdp_max_clk;
-	u32 mdp_max_bw;
+	u64 mdp_max_bw;
 	u32 mdp_bw_ab_factor;
 	u32 mdp_bw_ib_factor;
 #ifdef CONFIG_MSM_BUS_SCALING
@@ -519,7 +519,6 @@
 	char dlane_swap;
 	void (*dsi_pwm_cfg)(void);
 	char enable_wled_bl_ctrl;
-	void (*gpio_set_backlight)(int bl_level);
 };
 
 struct lvds_panel_platform_data {
diff --unified -r mach-msm/include/mach/camera.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/camera.h
--- mach-msm/include/mach/camera.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/camera.h	2013-12-17 17:08:05.634151123 -0800
@@ -46,7 +46,7 @@
 #define max_control_command_size 512
 #define CROP_LEN 36
 
-enum vfe_mode_of_operation{
+enum vfe_mode_of_operation {
 	VFE_MODE_OF_OPERATION_CONTINUOUS,
 	VFE_MODE_OF_OPERATION_SNAPSHOT,
 	VFE_MODE_OF_OPERATION_VIDEO,
@@ -162,7 +162,7 @@
 	uint32_t frame_id;
 };
 
-struct video_crop_t{
+struct video_crop_t {
 	uint32_t  in1_w;
 	uint32_t  out1_w;
 	uint32_t  in1_h;
diff --unified -r mach-msm/include/mach/diag_bridge.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/diag_bridge.h
--- mach-msm/include/mach/diag_bridge.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/diag_bridge.h	2013-12-17 17:08:05.634151123 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, 2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,32 +23,33 @@
 	void (*resume)(void *ctxt);
 };
 
-#if IS_ENABLED(CONFIG_USB_QCOM_DIAG_BRIDGE)
+#if defined(CONFIG_USB_QCOM_DIAG_BRIDGE) \
+	|| defined(CONFIG_USB_QCOM_DIAG_BRIDGE_MODULE)
 
-extern int diag_bridge_read(int id, char *data, int size);
-extern int diag_bridge_write(int id, char *data, int size);
-extern int diag_bridge_open(int id, struct diag_bridge_ops *ops);
-extern void diag_bridge_close(int id);
+extern int diag_bridge_read(char *data, int size);
+extern int diag_bridge_write(char *data, int size);
+extern int diag_bridge_open(struct diag_bridge_ops *ops);
+extern void diag_bridge_close(void);
 extern void request_autopm_lock(int status);
 
 #else
 
-static int __maybe_unused diag_bridge_read(int id, char *data, int size)
+static int __maybe_unused diag_bridge_read(char *data, int size)
 {
 	return -ENODEV;
 }
 
-static int __maybe_unused diag_bridge_write(int id, char *data, int size)
+static int __maybe_unused diag_bridge_write(char *data, int size)
 {
 	return -ENODEV;
 }
 
-static int __maybe_unused diag_bridge_open(int id, struct diag_bridge_ops *ops)
+static int __maybe_unused diag_bridge_open(struct diag_bridge_ops *ops)
 {
 	return -ENODEV;
 }
 
-static void __maybe_unused diag_bridge_close(int id) { }
+static void __maybe_unused diag_bridge_close(void) { }
 
 #endif
 
diff --unified -r mach-msm/include/mach/dma.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/dma.h
--- mach-msm/include/mach/dma.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/dma.h	2013-12-17 17:08:05.634151123 -0800
@@ -272,19 +272,6 @@
 #define DMOV8064_TSIF_CHAN         2
 #define DMOV8064_TSIF_CRCI         1
 
-/* channels for APQ8064 SGLTE*/
-#define DMOV_APQ8064_HSUART_GSBI4_TX_CHAN	11
-#define DMOV_APQ8064_HSUART_GSBI4_TX_CRCI	8
-
-#define DMOV_APQ8064_HSUART_GSBI4_RX_CHAN	10
-#define DMOV_APQ8064_HSUART_GSBI4_RX_CRCI	7
-
-/* channels for MPQ8064 */
-#define DMOV_MPQ8064_HSUART_GSBI6_TX_CHAN	7
-#define DMOV_MPQ8064_HSUART_GSBI6_TX_CRCI	6
-
-#define DMOV_MPQ8064_HSUART_GSBI6_RX_CHAN	6
-#define DMOV_MPQ8064_HSUART_GSBI6_RX_CRCI	11
 
 /* no client rate control ifc (eg, ram) */
 #define DMOV_NONE_CRCI        0
diff --unified -r mach-msm/include/mach/iommu_domains.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/iommu_domains.h
--- mach-msm/include/mach/iommu_domains.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/iommu_domains.h	2013-12-17 17:08:05.638151116 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -90,6 +90,7 @@
 
 extern int msm_iommu_map_extra(struct iommu_domain *domain,
 						unsigned long start_iova,
+						unsigned long phys_addr,
 						unsigned long size,
 						unsigned long page_size,
 						int cached);
@@ -114,6 +115,7 @@
 					unsigned long size);
 
 extern int msm_register_domain(struct msm_iova_layout *layout);
+extern int msm_unregister_domain(struct iommu_domain *domain);
 
 #else
 static inline struct iommu_domain
@@ -139,6 +141,7 @@
 
 static inline int msm_iommu_map_extra(struct iommu_domain *domain,
 						unsigned long start_iova,
+						unsigned long phys_addr,
 						unsigned long size,
 						unsigned long page_size,
 						int cached)
@@ -177,6 +180,11 @@
 {
 	return -ENODEV;
 }
+
+static inline int msm_unregister_domain(struct iommu_domain *domain)
+{
+	return -ENODEV;
+}
 #endif
 
 #endif
Only in mach-msm/include/mach: ipc_bridge.h
diff --unified -r mach-msm/include/mach/jactive_eur-gpio.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/jactive_eur-gpio.h
--- mach-msm/include/mach/jactive_eur-gpio.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/jactive_eur-gpio.h	2013-12-17 17:08:05.638151116 -0800
@@ -20,11 +20,6 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
-#define PM8921_GPIO_BASE        NR_GPIO_IRQS
-#define PM8921_GPIO_PM_TO_SYS(pm_gpio)  (pm_gpio - 1 + PM8921_GPIO_BASE)
-#define PM8921_MPP_BASE         (PM8921_GPIO_BASE + PM8921_NR_GPIOS)
-#define PM8921_MPP_PM_TO_SYS(pm_mpp)    (pm_mpp - 1 + PM8921_MPP_BASE)
-#define PM8921_IRQ_BASE         (NR_MSM_IRQS + NR_GPIO_IRQS)
 /* APQ8064 GPIO */
 #define GPIO_S_LED_I2C_SDA		 6
 #define GPIO_S_LED_I2C_SCL		 7
@@ -71,11 +66,6 @@
 #define GPIO_MHL_INT                    77
 #define GPIO_MHL_VSIL                    PM8921_GPIO_PM_TO_SYS(32)
 #endif
-#define GPIO_CAM_IO_EN			PM8921_GPIO_PM_TO_SYS(32) 
-#define GPIO_MAIN_CAM_MCLK      5
-#define GPIO_CAM1_RST_N			PM8921_GPIO_PM_TO_SYS(6)
-#define GPIO_I2C_CLK_AF			70
-#define GPIO_I2C_DATA_AF		71
 
 /* PM8921 GPIO */
 #define PMIC_GPIO_VPS_SOUND_EN		9
diff --unified -r mach-msm/include/mach/jf_att-gpio.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/jf_att-gpio.h
--- mach-msm/include/mach/jf_att-gpio.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/jf_att-gpio.h	2013-12-17 17:08:05.638151116 -0800
@@ -74,10 +74,8 @@
 #define PMIC_GPIO_SPK_EN                18
 #define PMIC_GPIO_VPS_EN                19
 #define PMIC_GPIO_FSA8048_EN		28
-#ifdef CONFIG_IRDA_MC96
 #define PMIC_GPIO_IRDA_WAKE             -1
 #define PMIC_GPIO_IRDA_IRQ		3
-#endif
 #define PMIC_GPIO_2MIC_WAKE             34
 #define PMIC_GPIO_CODEC_RESET_N         38
 #ifdef CONFIG_SEC_FPGA
diff --unified -r mach-msm/include/mach/jtag.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/jtag.h
--- mach-msm/include/mach/jtag.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/jtag.h	2013-12-17 17:08:05.638151116 -0800
@@ -16,9 +16,11 @@
 #if defined(CONFIG_MSM_JTAG) || defined(CONFIG_MSM_JTAG_MM)
 extern void msm_jtag_save_state(void);
 extern void msm_jtag_restore_state(void);
+extern bool msm_jtag_fuse_apps_access_disabled(void);
 #else
 static inline void msm_jtag_save_state(void) {}
 static inline void msm_jtag_restore_state(void) {}
+static inline bool msm_jtag_fuse_apps_access_disabled(void) { return false; }
 #endif
 
 #endif
diff --unified -r mach-msm/include/mach/kgsl.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/kgsl.h
--- mach-msm/include/mach/kgsl.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/kgsl.h	2013-12-17 17:08:05.638151116 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,13 +20,15 @@
 #define KGSL_CLK_MEM	0x00000008
 #define KGSL_CLK_MEM_IFACE 0x00000010
 #define KGSL_CLK_AXI	0x00000020
+#define KGSL_CLK_ALT_MEM_IFACE 0x00000040
 
-#define KGSL_MAX_PWRLEVELS 5
+#define KGSL_MAX_PWRLEVELS 10
 
 #define KGSL_CONVERT_TO_MBPS(val) \
 	(val*1000*1000U)
 
 #define KGSL_3D0_REG_MEMORY	"kgsl_3d0_reg_memory"
+#define KGSL_3D0_SHADER_MEMORY	"kgsl_3d0_shader_memory"
 #define KGSL_3D0_IRQ		"kgsl_3d0_irq"
 #define KGSL_2D0_REG_MEMORY	"kgsl_2d0_reg_memory"
 #define KGSL_2D0_IRQ		"kgsl_2d0_irq"
@@ -49,9 +51,19 @@
 	enum kgsl_iommu_context_id ctx_id;
 };
 
+/*
+ * struct kgsl_device_iommu_data - Struct holding iommu context data obtained
+ * from dtsi file
+ * @iommu_ctxs:		Pointer to array of struct hoding context name and id
+ * @iommu_ctx_count:	Number of contexts defined in the dtsi file
+ * @iommu_halt_enable:	Indicated if smmu halt h/w feature is supported
+ * @physstart:		Start of iommu registers physical address
+ * @physend:		End of iommu registers physical address
+ */
 struct kgsl_device_iommu_data {
 	const struct kgsl_iommu_ctx *iommu_ctxs;
 	int iommu_ctx_count;
+	int iommu_halt_enable;
 	unsigned int physstart;
 	unsigned int physend;
 };
@@ -69,13 +81,15 @@
 	int (*set_grp_async)(void);
 	unsigned int idle_timeout;
 	bool strtstp_sleepwake;
-	unsigned int nap_allowed;
 	unsigned int clk_map;
 	unsigned int idle_needed;
+	unsigned int step_mul;
 	struct msm_bus_scale_pdata *bus_scale_table;
 	struct kgsl_device_iommu_data *iommu_data;
 	int iommu_count;
 	struct msm_dcvs_core_info *core_info;
+	struct coresight_device *csdev;
+	struct coresight_platform_data *coresight_pdata;
 	unsigned int chipid;
 };
 
diff --unified -r mach-msm/include/mach/mdm2.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/mdm2.h
--- mach-msm/include/mach/mdm2.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/mdm2.h	2013-12-17 17:08:05.638151116 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,7 +12,6 @@
 
 #ifndef _ARCH_ARM_MACH_MSM_MDM2_H
 #define _ARCH_ARM_MACH_MSM_MDM2_H
-#include "../../sysmon.h"
 
 struct mdm_vddmin_resource {
 	int rpm_id;
@@ -25,7 +24,6 @@
 struct mdm_platform_data {
 	char *mdm_version;
 	int ramdump_delay_ms;
-	int ps_hold_delay_ms;
 	int soft_reset_inverted;
 	int early_power_on;
 	int sfr_query;
@@ -35,14 +33,6 @@
 	const unsigned int ramdump_timeout_ms;
 	int image_upgrade_supported;
 	struct gpiomux_setting *mdm2ap_status_gpio_run_cfg;
-	int send_shdn;
-	int cascading_ssr;
-	int sysmon_subsys_id_valid;
-	enum subsys_id sysmon_subsys_id;
-	int no_a2m_errfatal_on_ssr;
-	int no_reset_on_first_powerup;
-	int kpd_not_inverted;
-	char *subsys_name;
 };
 
 #endif
diff --unified -r mach-msm/include/mach/memory.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/memory.h
--- mach-msm/include/mach/memory.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/memory.h	2013-12-17 17:08:05.638151116 -0800
@@ -1,7 +1,7 @@
 /* arch/arm/mach-msm/include/mach/memory.h
  *
  * Copyright (C) 2007 Google, Inc.
- * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -19,6 +19,9 @@
 
 /* physical offset of RAM */
 #define PLAT_PHYS_OFFSET UL(CONFIG_PHYS_OFFSET)
+#ifdef CONFIG_HAVE_END_MEM
+#define END_MEM          UL(CONFIG_END_MEM)
+#endif
 
 #define MAX_PHYSMEM_BITS 32
 #define SECTION_SIZE_BITS 28
@@ -69,7 +72,6 @@
 #endif
 
 #ifndef __ASSEMBLY__
-void *alloc_bootmem_aligned(unsigned long size, unsigned long alignment);
 void *allocate_contiguous_ebi(unsigned long, unsigned long, int);
 unsigned long allocate_contiguous_ebi_nomap(unsigned long, unsigned long);
 void clean_and_invalidate_caches(unsigned long, unsigned long, unsigned long);
@@ -97,26 +99,31 @@
 #define finish_arch_switch(prev)	do { store_ttbr0(); } while (0)
 #endif
 
+#define MAX_HOLE_ADDRESS    (PHYS_OFFSET + 0x10000000)
+extern phys_addr_t memory_hole_offset;
+extern phys_addr_t memory_hole_start;
+extern phys_addr_t memory_hole_end;
+extern unsigned long memory_hole_align;
+extern unsigned long virtual_hole_start;
+extern unsigned long virtual_hole_end;
 #ifdef CONFIG_DONT_MAP_HOLE_AFTER_MEMBANK0
-extern unsigned long membank0_size;
-extern unsigned long membank1_start;
-void find_membank0_hole(void);
-
-#define MEMBANK0_PHYS_OFFSET PHYS_OFFSET
-#define MEMBANK0_PAGE_OFFSET PAGE_OFFSET
+void find_memory_hole(void);
 
-#define MEMBANK1_PHYS_OFFSET (membank1_start)
-#define MEMBANK1_PAGE_OFFSET (MEMBANK0_PAGE_OFFSET + (membank0_size))
+#define MEM_HOLE_END_PHYS_OFFSET (memory_hole_end)
+#define MEM_HOLE_PAGE_OFFSET (PAGE_OFFSET + memory_hole_offset + \
+				memory_hole_align)
 
 #define __phys_to_virt(phys)				\
-	((MEMBANK1_PHYS_OFFSET && ((phys) >= MEMBANK1_PHYS_OFFSET)) ?	\
-	(phys) - MEMBANK1_PHYS_OFFSET + MEMBANK1_PAGE_OFFSET :	\
-	(phys) - MEMBANK0_PHYS_OFFSET + MEMBANK0_PAGE_OFFSET)
+	(unsigned long)\
+	((MEM_HOLE_END_PHYS_OFFSET && ((phys) >= MEM_HOLE_END_PHYS_OFFSET)) ? \
+	(phys) - MEM_HOLE_END_PHYS_OFFSET + MEM_HOLE_PAGE_OFFSET :	\
+	(phys) - PHYS_OFFSET + PAGE_OFFSET)
 
 #define __virt_to_phys(virt)				\
-	((MEMBANK1_PHYS_OFFSET && ((virt) >= MEMBANK1_PAGE_OFFSET)) ?	\
-	(virt) - MEMBANK1_PAGE_OFFSET + MEMBANK1_PHYS_OFFSET :	\
-	(virt) - MEMBANK0_PAGE_OFFSET + MEMBANK0_PHYS_OFFSET)
+	(unsigned long)\
+	((MEM_HOLE_END_PHYS_OFFSET && ((virt) >= MEM_HOLE_PAGE_OFFSET)) ? \
+	(virt) - MEM_HOLE_PAGE_OFFSET + MEM_HOLE_END_PHYS_OFFSET :	\
+	(virt) - PAGE_OFFSET + PHYS_OFFSET)
 #endif
 
 /*
diff --unified -r mach-msm/include/mach/msm_ipc_logging.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_ipc_logging.h
--- mach-msm/include/mach/msm_ipc_logging.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_ipc_logging.h	2013-12-17 17:08:05.642151109 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -185,49 +185,47 @@
 				      struct decode_context *));
 #else
 
-static inline void *ipc_log_context_create(int max_num_pages,
-	const char *modname)
+void *ipc_log_context_create(int max_num_pages, const char *modname)
 { return NULL; }
 
-static inline void msg_encode_start(struct encode_context *ectxt,
-	uint32_t type) { }
+void msg_encode_start(struct encode_context *ectxt, uint32_t type) { }
 
-static inline int tsv_timestamp_write(struct encode_context *ectxt)
+int tsv_timestamp_write(struct encode_context *ectxt)
 { return -EINVAL; }
 
-static inline int tsv_pointer_write(struct encode_context *ectxt, void *pointer)
+int tsv_pointer_write(struct encode_context *ectxt, void *pointer)
 { return -EINVAL; }
 
-static inline int tsv_int32_write(struct encode_context *ectxt, int32_t n)
+int tsv_int32_write(struct encode_context *ectxt, int32_t n)
 { return -EINVAL; }
 
-static inline int tsv_byte_array_write(struct encode_context *ectxt,
+int tsv_byte_array_write(struct encode_context *ectxt,
 			 void *data, int data_size)
 { return -EINVAL; }
 
-static inline void msg_encode_end(struct encode_context *ectxt) { }
+void msg_encode_end(struct encode_context *ectxt) { }
 
-static inline void ipc_log_write(void *ctxt, struct encode_context *ectxt) { }
+void ipc_log_write(void *ctxt, struct encode_context *ectxt) { }
 
-static inline int ipc_log_string(void *ilctxt, const char *fmt, ...)
+int ipc_log_string(void *ilctxt, const char *fmt, ...)
 { return -EINVAL; }
 
 #define IPC_SPRINTF_DECODE(dctxt, args...) do { } while (0)
 
-static inline void tsv_timestamp_read(struct encode_context *ectxt,
+void tsv_timestamp_read(struct encode_context *ectxt,
 			struct decode_context *dctxt, const char *format) { }
 
-static inline void tsv_pointer_read(struct encode_context *ectxt,
+void tsv_pointer_read(struct encode_context *ectxt,
 		      struct decode_context *dctxt, const char *format) { }
 
-static inline int32_t tsv_int32_read(struct encode_context *ectxt,
+int32_t tsv_int32_read(struct encode_context *ectxt,
 		       struct decode_context *dctxt, const char *format)
 { return 0; }
 
-static inline void tsv_byte_array_read(struct encode_context *ectxt,
+void tsv_byte_array_read(struct encode_context *ectxt,
 			 struct decode_context *dctxt, const char *format) { }
 
-static inline int add_deserialization_func(void *ctxt, int type,
+int add_deserialization_func(void *ctxt, int type,
 			void (*dfunc)(struct encode_context *,
 				      struct decode_context *))
 { return 0; }
Only in mach-msm/include/mach: msm_ipc_router.h
diff --unified -r mach-msm/include/mach/msm_memory_dump.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_memory_dump.h
--- mach-msm/include/mach/msm_memory_dump.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_memory_dump.h	2013-12-17 17:08:05.642151109 -0800
@@ -19,13 +19,9 @@
 	MSM_CPU_CTXT = 0,
 	MSM_CACHE,
 	MSM_OCMEM,
-	MSM_TMC_ETFETB,
-	MSM_ETM0_REG,
-	MSM_ETM1_REG,
-	MSM_ETM2_REG,
-	MSM_ETM3_REG,
-	MSM_TMC0_REG, /* TMC_ETR */
-	MSM_TMC1_REG, /* TMC_ETF */
+	MSM_ETB,
+	MSM_ETM,
+	MSM_TMC,
 	MAX_NUM_CLIENTS,
 };
 
diff --unified -r mach-msm/include/mach/msm_memtypes.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_memtypes.h
--- mach-msm/include/mach/msm_memtypes.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_memtypes.h	2013-12-17 17:08:05.642151109 -0800
@@ -67,6 +67,8 @@
 
 int __init dt_scan_for_memory_reserve(unsigned long node, const char *uname,
 					int depth, void *data);
-
+int __init dt_scan_for_memory_hole(unsigned long node, const char *uname,
+					int depth, void *data);
+void adjust_meminfo(unsigned long start, unsigned long size);
 unsigned long __init reserve_memory_for_fmem(unsigned long, unsigned long);
 #endif
diff --unified -r mach-msm/include/mach/msm_serial_hs.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_serial_hs.h
--- mach-msm/include/mach/msm_serial_hs.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_serial_hs.h	2013-12-17 17:08:05.642151109 -0800
@@ -45,7 +45,6 @@
 	int uart_cts_gpio;
 	int uart_rfr_gpio;
 	int userid;
-	int uartdm_rx_buf_size;
 };
 
 unsigned int msm_hs_tx_empty(struct uart_port *uport);
diff --unified -r mach-msm/include/mach/msm_serial_hs_lite.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_serial_hs_lite.h
--- mach-msm/include/mach/msm_serial_hs_lite.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_serial_hs_lite.h	2013-12-17 17:08:05.642151109 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013 The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,30 +13,11 @@
 
 #ifndef __ASM_ARCH_MSM_SERIAL_HS_LITE_H
 #define __ASM_ARCH_MSM_SERIAL_HS_LITE_H
-/**
- * struct msm_serial_hslite_platform_data - platform device data
- *              for msm_hs_lite.
- * @config_gpio: Select GPIOs to configure.
- *		Set 4 if 4-wire UART used (for Tx, Rx, CTS, RFR GPIOs).
- *		Set 1 if 2-wire UART used (for Tx, Rx GPIOs).
- * @uart_tx_gpio: GPIO number for UART Tx Line.
- * @uart_rx_gpio: GPIO number for UART Rx Line.
- * @uart_cts_gpio: GPIO number for UART CTS Line.
- * @uart_rfr_gpio: GPIO number for UART RFR Line.
- * @set_uart_clk_zero: use this if setting UART Clock to zero is required
- * It is mainly required where same UART is used across different processor.
- * Make sure that Clock driver for platform support setting clock rate to zero.
- * @use_pm: use this to enable power management
- * @line: Used to set UART Port number.
- */
+
 struct msm_serial_hslite_platform_data {
 	unsigned config_gpio;
 	unsigned uart_tx_gpio;
 	unsigned uart_rx_gpio;
-	unsigned uart_cts_gpio;
-	unsigned uart_rfr_gpio;
-	bool set_uart_clk_zero;
-	bool use_pm;
 	int line;
 };
 
diff --unified -r mach-msm/include/mach/msm_tspp.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_tspp.h
--- mach-msm/include/mach/msm_tspp.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/msm_tspp.h	2013-12-17 17:08:05.642151109 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -42,8 +42,6 @@
 int tspp_close_stream(u32 dev, u32 channel_id);
 int tspp_open_channel(u32 dev, u32 channel_id);
 int tspp_close_channel(u32 dev, u32 channel_id);
-int tspp_get_ref_clk_counter(u32 dev,
-	enum tspp_source source, u32 *tcr_counter);
 int tspp_add_filter(u32 dev, u32 channel_id, struct tspp_filter *filter);
 int tspp_remove_filter(u32 dev, u32 channel_id,	struct tspp_filter *filter);
 int tspp_set_key(u32 dev, u32 channel_id, struct tspp_key *key);
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach: qdsp5
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach: qdsp5v2
Only in mach-msm/include/mach/qdsp6v2: audio_def.h
diff --unified -r mach-msm/include/mach/qdsp6v2/audio_dev_ctl.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/qdsp6v2/audio_dev_ctl.h
--- mach-msm/include/mach/qdsp6v2/audio_dev_ctl.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/qdsp6v2/audio_dev_ctl.h	2013-12-17 17:08:05.646151103 -0800
@@ -12,7 +12,7 @@
  */
 #ifndef __MACH_QDSP6_V2_SNDDEV_H
 #define __MACH_QDSP6_V2_SNDDEV_H
-#include <mach/qdsp6v2/audio_def.h>
+#include <mach/qdsp5v2/audio_def.h>
 #include <sound/q6afe.h>
 
 #define AUDIO_DEV_CTL_MAX_DEV 64
diff --unified -r mach-msm/include/mach/restart.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/restart.h
--- mach-msm/include/mach/restart.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/restart.h	2013-12-17 17:08:05.646151103 -0800
@@ -35,6 +35,7 @@
 #endif
 
 extern int pmic_reset_irq;
+int resout_irq_control (int enable);
 
 #endif
 
diff --unified -r mach-msm/include/mach/scm.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/scm.h
--- mach-msm/include/mach/scm.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/scm.h	2013-12-17 17:08:05.646151103 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -25,24 +25,13 @@
 #define SCM_SVC_DCVS			0xD
 #define SCM_SVC_TZSCHEDULER		0xFC
 
-#define DEFINE_SCM_BUFFER(__n) \
-static char __n[PAGE_SIZE] __aligned(PAGE_SIZE);
-
-#define SCM_BUFFER_SIZE(__buf)	sizeof(__buf)
-
-#define SCM_BUFFER_PHYS(__buf)	virt_to_phys(__buf)
-
 #ifdef CONFIG_MSM_SCM
 extern int scm_call(u32 svc_id, u32 cmd_id, const void *cmd_buf, size_t cmd_len,
 		void *resp_buf, size_t resp_len);
 
-extern int scm_call_noalloc(u32 svc_id, u32 cmd_id, const void *cmd_buf,
-		size_t cmd_len, void *resp_buf, size_t resp_len,
-		void *scm_buf, size_t scm_buf_size);
-
-
 extern s32 scm_call_atomic1(u32 svc, u32 cmd, u32 arg1);
 extern s32 scm_call_atomic2(u32 svc, u32 cmd, u32 arg1, u32 arg2);
+extern s32 scm_call_atomic3(u32 svc, u32 cmd, u32 arg1, u32 arg2, u32 arg3);
 extern s32 scm_call_atomic4_3(u32 svc, u32 cmd, u32 arg1, u32 arg2, u32 arg3,
 		u32 arg4, u32 *ret1, u32 *ret2);
 
@@ -60,19 +49,18 @@
 	return 0;
 }
 
-static inline int scm_call_noalloc(u32 svc_id, u32 cmd_id,
-		const void *cmd_buf, size_t cmd_len, void *resp_buf,
-		size_t resp_len, void *scm_buf, size_t scm_buf_size)
+static inline s32 scm_call_atomic1(u32 svc, u32 cmd, u32 arg1)
 {
 	return 0;
 }
 
-static inline s32 scm_call_atomic1(u32 svc, u32 cmd, u32 arg1)
+static inline s32 scm_call_atomic2(u32 svc, u32 cmd, u32 arg1, u32 arg2)
 {
 	return 0;
 }
 
-static inline s32 scm_call_atomic2(u32 svc, u32 cmd, u32 arg1, u32 arg2)
+static inline s32 scm_call_atomic3(u32 svc, u32 cmd, u32 arg1, u32 arg2,
+		u32 arg3)
 {
 	return 0;
 }
diff --unified -r mach-msm/include/mach/sec_debug.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/sec_debug.h
--- mach-msm/include/mach/sec_debug.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/sec_debug.h	2013-12-17 17:08:05.646151103 -0800
@@ -29,7 +29,7 @@
 
 extern void *restart_reason;
 
-#if CONFIG_SEC_DEBUG
+#ifdef CONFIG_SEC_DEBUG
 extern int sec_debug_init(void);
 extern int sec_debug_dump_stack(void);
 extern void sec_debug_hw_reset(void);
@@ -50,7 +50,7 @@
 {
 	return 0;
 }
-static inline int sec_debug_dump_stack(void) {}
+static inline int sec_debug_dump_stack(void) { return 0; }
 static inline void sec_debug_check_crash_key(unsigned int code, int value) {}
 
 static inline void sec_getlog_supply_fbinfo(void *p_fb, u32 res_x, u32 res_y,
diff --unified -r mach-msm/include/mach/smem_log.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/smem_log.h
--- mach-msm/include/mach/smem_log.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/smem_log.h	2013-12-17 17:08:05.646151103 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2009, 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2008-2009, 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -51,9 +51,6 @@
 #define SMEM_LOG_DCVS_EVENT_BASE        0x00070000
 #define SMEM_LOG_SLEEP_EVENT_BASE       0x00080000
 #define SMEM_LOG_RPC_ROUTER_EVENT_BASE  0x00090000
-#define SMEM_LOG_IPC_ROUTER_EVENT_BASE  0x000D0000
-#define SMEM_LOG_QMI_CCI_EVENT_BASE     0x000E0000
-#define SMEM_LOG_QMI_CSI_EVENT_BASE     0x000F0000
 #if defined(CONFIG_MSM_N_WAY_SMSM)
 #define DEM_SMSM_ISR                    (SMEM_LOG_DEM_EVENT_BASE + 0x1)
 #define DEM_STATE_CHANGE                (SMEM_LOG_DEM_EVENT_BASE + 0x2)
diff --unified -r mach-msm/include/mach/sps.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/sps.h
--- mach-msm/include/mach/sps.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/sps.h	2013-12-17 17:08:05.646151103 -0800
@@ -254,6 +254,7 @@
 enum sps_callback_case {
 	SPS_CALLBACK_BAM_ERROR_IRQ = 1,     /* BAM ERROR IRQ */
 	SPS_CALLBACK_BAM_HRESP_ERR_IRQ,	    /* Erroneous HResponse */
+	SPS_CALLBACK_BAM_TIMER_IRQ,	    /* Inactivity timer */
 };
 
 /*
@@ -1253,14 +1254,23 @@
  *
  * @tb_sel - testbus selection
  *
- * @desc_sel - selection of descriptors
+ * @pre_level - prescreening level
  *
  * @return 0 on success, negative value on error
  *
  */
 int sps_get_bam_debug_info(u32 dev, u32 option, u32 para,
-		u32 tb_sel, u8 desc_sel);
+		u32 tb_sel, u8 pre_level);
 
+/**
+ * Vote for or relinquish BAM DMA clock
+ *
+ * @clk_on - to turn on or turn off the clock
+ *
+ * @return 0 on success, negative value on error
+ *
+ */
+int sps_ctrl_bam_dma_clk(bool clk_on);
 #else
 static inline int sps_register_bam_device(const struct sps_bam_props
 			*bam_props, u32 *dev_handle)
@@ -1423,6 +1433,11 @@
 {
 	return -EPERM;
 }
+
+static inline int sps_ctrl_bam_dma_clk(bool clk_on)
+{
+	return -EPERM;
+}
 #endif
 
 #endif /* _SPS_H_ */
diff --unified -r mach-msm/include/mach/usb_bridge.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/usb_bridge.h
--- mach-msm/include/mach/usb_bridge.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/usb_bridge.h	2013-12-17 17:08:05.646151103 -0800
@@ -17,8 +17,10 @@
 #include <linux/netdevice.h>
 #include <linux/usb.h>
 
-#define MAX_BRIDGE_DEVICES 4
-#define BRIDGE_NAME_MAX_LEN 20
+/* bridge device 0: DUN
+ * bridge device 1 : Tethered RMNET
+ */
+#define MAX_BRIDGE_DEVICES 2
 
 struct bridge_ops {
 	int (*send_pkt)(void *, void *, size_t actual);
@@ -35,12 +37,11 @@
 	/* context of the gadget port using bridge driver */
 	void *ctx;
 
-	/*to maps bridge driver instance*/
+	/* bridge device array index mapped to the gadget port array index.
+	 * data bridge[ch_id] <-- bridge --> gadget port[ch_id]
+	 */
 	unsigned int ch_id;
 
-	/*to match against bridge xport name to get bridge driver instance*/
-	char *name;
-
 	/* flow control bits */
 	unsigned long flags;
 
@@ -100,10 +101,7 @@
 int data_bridge_unthrottle_rx(unsigned int);
 
 /* defined in control bridge */
-int ctrl_bridge_init(void);
-void ctrl_bridge_exit(void);
-int ctrl_bridge_probe(struct usb_interface *, struct usb_host_endpoint *,
-		char *, int);
+int ctrl_bridge_probe(struct usb_interface *, struct usb_host_endpoint *, int);
 void ctrl_bridge_disconnect(unsigned int);
 int ctrl_bridge_resume(unsigned int);
 int ctrl_bridge_suspend(unsigned int);
diff --unified -r mach-msm/include/mach/usbdiag.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/usbdiag.h
--- mach-msm/include/mach/usbdiag.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/usbdiag.h	2013-12-17 17:08:05.646151103 -0800
@@ -26,7 +26,6 @@
 #define DIAG_LEGACY		"diag"
 #define DIAG_MDM		"diag_mdm"
 #define DIAG_QSC		"diag_qsc"
-#define DIAG_MDM2		"diag_mdm2"
 
 #define USB_DIAG_CONNECT	0
 #define USB_DIAG_DISCONNECT	1
diff --unified -r mach-msm/include/mach/usb_gadget_xport.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/usb_gadget_xport.h
--- mach-msm/include/mach/usb_gadget_xport.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/include/mach/usb_gadget_xport.h	2013-12-17 17:08:05.646151103 -0800
@@ -79,8 +79,8 @@
 	USB_GADGET_RMNET,
 };
 
-#define NUM_RMNET_HSIC_PORTS 2
-#define NUM_DUN_HSIC_PORTS 2
+#define NUM_RMNET_HSIC_PORTS 1
+#define NUM_DUN_HSIC_PORTS 1
 #define NUM_PORTS (NUM_RMNET_HSIC_PORTS \
 	+ NUM_DUN_HSIC_PORTS)
 
@@ -92,11 +92,9 @@
 int ghsic_ctrl_connect(void *, int);
 void ghsic_ctrl_disconnect(void *, int);
 int ghsic_ctrl_setup(unsigned int, enum gadget_type);
-void ghsic_ctrl_set_port_name(const char *, const char *);
 int ghsic_data_connect(void *, int);
 void ghsic_data_disconnect(void *, int);
 int ghsic_data_setup(unsigned int, enum gadget_type);
-void ghsic_data_set_port_name(const char *, const char *);
 
 int ghsuart_ctrl_connect(void *, int);
 void ghsuart_ctrl_disconnect(void *, int);
Only in mach-msm/include/mach: usb_trace.h
diff --unified -r mach-msm/iommu_domains.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/iommu_domains.c
--- mach-msm/iommu_domains.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/iommu_domains.c	2013-12-17 17:08:05.646151103 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -15,8 +15,15 @@
 #include <linux/iommu.h>
 #include <linux/memory_alloc.h>
 #include <linux/platform_device.h>
+#include <linux/vmalloc.h>
 #include <linux/rbtree.h>
 #include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/idr.h>
+#include <linux/err.h>
 #include <asm/sizes.h>
 #include <asm/page.h>
 #include <mach/iommu.h>
@@ -24,9 +31,6 @@
 #include <mach/socinfo.h>
 #include <mach/msm_subsystem_map.h>
 
-/* dummy 64K for overmapping */
-char iommu_dummy[2*SZ_64K-4];
-
 struct msm_iova_data {
 	struct rb_node node;
 	struct mem_pool *pools;
@@ -35,31 +39,48 @@
 	int domain_num;
 };
 
+struct msm_iommu_data_entry {
+	struct list_head list;
+	void *data;
+};
+
 static struct rb_root domain_root;
 DEFINE_MUTEX(domain_mutex);
-static atomic_t domain_nums = ATOMIC_INIT(-1);
+static DEFINE_IDA(domain_nums);
 
 int msm_use_iommu()
 {
 	return iommu_present(&platform_bus_type);
 }
 
+bool msm_iommu_page_size_is_supported(unsigned long page_size)
+{
+	return page_size == SZ_4K
+		|| page_size == SZ_64K
+		|| page_size == SZ_1M
+		|| page_size == SZ_16M;
+}
+
 int msm_iommu_map_extra(struct iommu_domain *domain,
 				unsigned long start_iova,
+				unsigned long phy_addr,
 				unsigned long size,
 				unsigned long page_size,
-				int cached)
+				int prot)
 {
 	int ret = 0;
 	int i = 0;
-	unsigned long phy_addr = ALIGN(virt_to_phys(iommu_dummy), page_size);
 	unsigned long temp_iova = start_iova;
-	if (page_size == SZ_4K) {
+	/* the extra "padding" should never be written to. map it
+	 * read-only. */
+	prot &= ~IOMMU_WRITE;
+
+	if (msm_iommu_page_size_is_supported(page_size)) {
 		struct scatterlist *sglist;
 		unsigned int nrpages = PFN_ALIGN(size) >> PAGE_SHIFT;
 		struct page *dummy_page = phys_to_page(phy_addr);
 
-		sglist = kmalloc(sizeof(*sglist) * nrpages, GFP_KERNEL);
+		sglist = vmalloc(sizeof(*sglist) * nrpages);
 		if (!sglist) {
 			ret = -ENOMEM;
 			goto out;
@@ -70,13 +91,13 @@
 		for (i = 0; i < nrpages; i++)
 			sg_set_page(&sglist[i], dummy_page, PAGE_SIZE, 0);
 
-		ret = iommu_map_range(domain, temp_iova, sglist, size, cached);
+		ret = iommu_map_range(domain, temp_iova, sglist, size, prot);
 		if (ret) {
 			pr_err("%s: could not map extra %lx in domain %p\n",
 				__func__, start_iova, domain);
 		}
 
-		kfree(sglist);
+		vfree(sglist);
 	} else {
 		unsigned long order = get_order(page_size);
 		unsigned long aligned_size = ALIGN(size, page_size);
@@ -84,7 +105,7 @@
 
 		for (i = 0; i < nrpages; i++) {
 			ret = iommu_map(domain, temp_iova, phy_addr, page_size,
-						cached);
+						prot);
 			if (ret) {
 				pr_err("%s: could not map %lx in domain %p, error: %d\n",
 					__func__, start_iova, domain, ret);
@@ -131,7 +152,7 @@
 	int prot = IOMMU_WRITE | IOMMU_READ;
 	prot |= cached ? IOMMU_CACHE : 0;
 
-	sglist = kmalloc(sizeof(*sglist), GFP_KERNEL);
+	sglist = vmalloc(sizeof(*sglist));
 	if (!sglist) {
 		ret = -ENOMEM;
 		goto err1;
@@ -148,7 +169,7 @@
 			__func__, iova, domain);
 	}
 
-	kfree(sglist);
+	vfree(sglist);
 err1:
 	return ret;
 
@@ -254,6 +275,27 @@
 	return 0;
 }
 
+static int remove_domain(struct iommu_domain *domain)
+{
+	struct rb_root *root = &domain_root;
+	struct rb_node *n;
+	struct msm_iova_data *node;
+	int ret = -EINVAL;
+
+	mutex_lock(&domain_mutex);
+
+	for (n = rb_first(root); n; n = rb_next(n)) {
+		node = rb_entry(n, struct msm_iova_data, node);
+		if (node->domain == domain) {
+			rb_erase(&node->node, &domain_root);
+			ret = 0;
+			break;
+		}
+	}
+	mutex_unlock(&domain_mutex);
+	return ret;
+}
+
 struct iommu_domain *msm_get_iommu_domain(int domain_num)
 {
 	struct msm_iova_data *data;
@@ -266,6 +308,27 @@
 		return NULL;
 }
 
+static struct msm_iova_data *msm_domain_to_iova_data(struct iommu_domain
+						     const *domain)
+{
+	struct rb_root *root = &domain_root;
+	struct rb_node *n;
+	struct msm_iova_data *node;
+	struct msm_iova_data *iova_data = ERR_PTR(-EINVAL);
+
+	mutex_lock(&domain_mutex);
+
+	for (n = rb_first(root); n; n = rb_next(n)) {
+		node = rb_entry(n, struct msm_iova_data, node);
+		if (node->domain == domain) {
+			iova_data = node;
+			break;
+		}
+	}
+	mutex_unlock(&domain_mutex);
+	return iova_data;
+}
+
 int msm_allocate_iova_address(unsigned int iommu_domain,
 					unsigned int partition_no,
 					unsigned long size,
@@ -351,11 +414,11 @@
 	if (!data)
 		return -ENOMEM;
 
-	pools = kmalloc(sizeof(struct mem_pool) * layout->npartitions,
+	pools = kzalloc(sizeof(struct mem_pool) * layout->npartitions,
 			GFP_KERNEL);
 
 	if (!pools)
-		goto out;
+		goto free_data;
 
 	for (i = 0; i < layout->npartitions; i++) {
 		if (layout->partitions[i].size == 0)
@@ -389,22 +452,64 @@
 
 	data->pools = pools;
 	data->npools = layout->npartitions;
-	data->domain_num = atomic_inc_return(&domain_nums);
+	data->domain_num = ida_simple_get(&domain_nums, 0, 0, GFP_KERNEL);
+	if (data->domain_num < 0)
+		goto free_pools;
+
 	data->domain = iommu_domain_alloc(&platform_bus_type,
 					  layout->domain_flags);
+	if (!data->domain)
+		goto free_domain_num;
 
 	add_domain(data);
 
 	return data->domain_num;
 
-out:
+free_domain_num:
+	ida_simple_remove(&domain_nums, data->domain_num);
+
+free_pools:
+	for (i = 0; i < layout->npartitions; i++) {
+		if (pools[i].gpool)
+			gen_pool_destroy(pools[i].gpool);
+	}
+	kfree(pools);
+free_data:
 	kfree(data);
 
 	return -EINVAL;
 }
 EXPORT_SYMBOL(msm_register_domain);
 
-static int __init iommu_domain_probe(struct platform_device *pdev)
+int msm_unregister_domain(struct iommu_domain *domain)
+{
+	unsigned int i;
+	struct msm_iova_data *data = msm_domain_to_iova_data(domain);
+
+	if (IS_ERR_OR_NULL(data)) {
+		pr_err("%s: Could not find iova_data\n", __func__);
+		return -EINVAL;
+	}
+
+	if (remove_domain(data->domain)) {
+		pr_err("%s: Domain not found. Failed to remove domain\n",
+			__func__);
+	}
+
+	iommu_domain_free(domain);
+
+	ida_simple_remove(&domain_nums, data->domain_num);
+
+	for (i = 0; i < data->npools; ++i)
+		gen_pool_destroy(data->pools[i].gpool);
+
+	kfree(data->pools);
+	kfree(data);
+	return 0;
+}
+EXPORT_SYMBOL(msm_unregister_domain);
+
+static int iommu_domain_probe(struct platform_device *pdev)
 {
 	struct iommu_domains_pdata *p  = pdev->dev.platform_data;
 	int i, j;
diff --unified -r mach-msm/ipc_router.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_router.c
--- mach-msm/ipc_router.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_router.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -27,19 +27,15 @@
 #include <linux/platform_device.h>
 #include <linux/uaccess.h>
 #include <linux/debugfs.h>
-#include <linux/rwsem.h>
 
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
 
 #include <mach/smem_log.h>
 #include <mach/subsystem_notif.h>
-#include <mach/msm_ipc_router.h>
-#include <mach/msm_ipc_logging.h>
 
 #include "ipc_router.h"
 #include "modem_notifier.h"
-#include "msm_ipc_router_security.h"
 
 enum {
 	SMEM_LOG = 1U << 0,
@@ -54,21 +50,15 @@
 module_param_named(debug_mask, msm_ipc_router_debug_mask,
 		   int, S_IRUGO | S_IWUSR | S_IWGRP);
 
-static void *ipc_rtr_log_ctxt;
-#define IPC_RTR_LOG_PAGES 5
 #define DIAG(x...) pr_info("[RR] ERROR " x)
 
 #if defined(DEBUG)
 #define D(x...) do { \
-if (ipc_rtr_log_ctxt) \
-	ipc_log_string(ipc_rtr_log_ctxt, x); \
 if (msm_ipc_router_debug_mask & RTR_DBG) \
 	pr_info(x); \
 } while (0)
 
 #define RR(x...) do { \
-if (ipc_rtr_log_ctxt) \
-	ipc_log_string(ipc_rtr_log_ctxt, x); \
 if (msm_ipc_router_debug_mask & R2R_MSG) \
 	pr_info("[RR] "x); \
 } while (0)
@@ -95,61 +85,43 @@
 #define NTFY(x...) do { } while (0)
 #endif
 
-#define IPC_ROUTER_LOG_EVENT_ERROR      0x00
-#define IPC_ROUTER_LOG_EVENT_TX         0x01
-#define IPC_ROUTER_LOG_EVENT_RX         0x02
-#define IPC_ROUTER_DUMMY_DEST_NODE	0xFFFFFFFF
+#define IPC_ROUTER_LOG_EVENT_ERROR      0x10
+#define IPC_ROUTER_LOG_EVENT_TX         0x11
+#define IPC_ROUTER_LOG_EVENT_RX         0x12
 
 static LIST_HEAD(control_ports);
-static DECLARE_RWSEM(control_ports_lock_lha5);
+static DEFINE_MUTEX(control_ports_lock);
 
 #define LP_HASH_SIZE 32
 static struct list_head local_ports[LP_HASH_SIZE];
-static DECLARE_RWSEM(local_ports_lock_lha2);
+static DEFINE_MUTEX(local_ports_lock);
 
-/*
- * Server info is organized as a hash table. The server's service ID is
- * used to index into the hash table. The instance ID of most of the servers
- * are 1 or 2. The service IDs are well distributed compared to the instance
- * IDs and hence choosing service ID to index into this hash table optimizes
- * the hash table operations like add, lookup, destroy.
- */
 #define SRV_HASH_SIZE 32
 static struct list_head server_list[SRV_HASH_SIZE];
-static DECLARE_RWSEM(server_list_lock_lha2);
+static DEFINE_MUTEX(server_list_lock);
+static wait_queue_head_t newserver_wait;
 
 struct msm_ipc_server {
 	struct list_head list;
 	struct msm_ipc_port_name name;
-	int synced_sec_rule;
-	char pdev_name[32];
-	int next_pdev_id;
 	struct list_head server_port_list;
 };
 
 struct msm_ipc_server_port {
 	struct list_head list;
-	struct platform_device pdev;
 	struct msm_ipc_port_addr server_addr;
 	struct msm_ipc_router_xprt_info *xprt_info;
 };
 
-struct msm_ipc_resume_tx_port {
-	struct list_head list;
-	uint32_t port_id;
-	uint32_t node_id;
-};
-
 #define RP_HASH_SIZE 32
 struct msm_ipc_router_remote_port {
 	struct list_head list;
 	uint32_t node_id;
 	uint32_t port_id;
+	uint32_t restart_state;
+	wait_queue_head_t quota_wait;
 	uint32_t tx_quota_cnt;
-	struct mutex quota_lock_lhb2;
-	struct list_head resume_tx_port_list;
-	void *sec_rule;
-	struct msm_ipc_server *server;
+	struct mutex quota_lock;
 };
 
 struct msm_ipc_router_xprt_info {
@@ -159,8 +131,8 @@
 	uint32_t initialized;
 	struct list_head pkt_list;
 	struct wake_lock wakelock;
-	struct mutex rx_lock_lhb2;
-	struct mutex tx_lock_lhb2;
+	struct mutex rx_lock;
+	struct mutex tx_lock;
 	uint32_t need_len;
 	uint32_t abort_data_read;
 	struct work_struct read_data;
@@ -174,28 +146,51 @@
 	uint32_t neighbor_node_id;
 	struct list_head remote_port_list[RP_HASH_SIZE];
 	struct msm_ipc_router_xprt_info *xprt_info;
-	struct rw_semaphore lock_lha4;
+	struct mutex lock;
 	unsigned long num_tx_bytes;
 	unsigned long num_rx_bytes;
 };
 
 static struct list_head routing_table[RT_HASH_SIZE];
-static DECLARE_RWSEM(routing_table_lock_lha3);
+static DEFINE_MUTEX(routing_table_lock);
 static int routing_table_inited;
 
+static LIST_HEAD(msm_ipc_board_dev_list);
+static DEFINE_MUTEX(msm_ipc_board_dev_list_lock);
+
 static void do_read_data(struct work_struct *work);
 
+#define RR_STATE_IDLE    0
+#define RR_STATE_HEADER  1
+#define RR_STATE_BODY    2
+#define RR_STATE_ERROR   3
+
+#define RESTART_NORMAL 0
+#define RESTART_PEND 1
+
+/* State for remote ep following restart */
+#define RESTART_QUOTA_ABORT  1
+
 static LIST_HEAD(xprt_info_list);
-static DECLARE_RWSEM(xprt_info_list_lock_lha5);
+static DEFINE_MUTEX(xprt_info_list_lock);
 
+DECLARE_COMPLETION(msm_ipc_remote_router_up);
 static DECLARE_COMPLETION(msm_ipc_local_router_up);
 #define IPC_ROUTER_INIT_TIMEOUT (10 * HZ)
 
 static uint32_t next_port_id;
-static DEFINE_MUTEX(next_port_id_lock_lha1);
+static DEFINE_MUTEX(next_port_id_lock);
+static atomic_t pending_close_count = ATOMIC_INIT(0);
+static wait_queue_head_t subsystem_restart_wait;
 static struct workqueue_struct *msm_ipc_router_workqueue;
 
 enum {
+	CLIENT_PORT,
+	SERVER_PORT,
+	CONTROL_PORT,
+};
+
+enum {
 	DOWN,
 	UP,
 };
@@ -224,13 +219,13 @@
 	for (i = 0; i < RP_HASH_SIZE; i++)
 		INIT_LIST_HEAD(&rt_entry->remote_port_list[i]);
 
-	init_rwsem(&rt_entry->lock_lha4);
+	mutex_init(&rt_entry->lock);
 	rt_entry->node_id = node_id;
 	rt_entry->xprt_info = NULL;
 	return rt_entry;
 }
 
-/* Must be called with routing_table_lock_lha3 locked. */
+/*Please take routing_table_lock before calling this function*/
 static int add_routing_table_entry(
 	struct msm_ipc_routing_table_entry *rt_entry)
 {
@@ -244,7 +239,7 @@
 	return 0;
 }
 
-/* Must be called with routing_table_lock_lha3 locked. */
+/*Please take routing_table_lock before calling this function*/
 static struct msm_ipc_routing_table_entry *lookup_routing_table(
 	uint32_t node_id)
 {
@@ -265,16 +260,16 @@
 	if (!xprt_info)
 		return NULL;
 
-	mutex_lock(&xprt_info->rx_lock_lhb2);
+	mutex_lock(&xprt_info->rx_lock);
 	if (xprt_info->abort_data_read) {
-		mutex_unlock(&xprt_info->rx_lock_lhb2);
+		mutex_unlock(&xprt_info->rx_lock);
 		pr_err("%s detected SSR & exiting now\n",
 			xprt_info->xprt->name);
 		return NULL;
 	}
 
 	if (list_empty(&xprt_info->pkt_list)) {
-		mutex_unlock(&xprt_info->rx_lock_lhb2);
+		mutex_unlock(&xprt_info->rx_lock);
 		return NULL;
 	}
 
@@ -283,7 +278,7 @@
 	list_del(&temp_pkt->list);
 	if (list_empty(&xprt_info->pkt_list))
 		wake_unlock(&xprt_info->wakelock);
-	mutex_unlock(&xprt_info->rx_lock_lhb2);
+	mutex_unlock(&xprt_info->rx_lock);
 	return temp_pkt;
 }
 
@@ -298,8 +293,6 @@
 		pr_err("%s: failure\n", __func__);
 		return NULL;
 	}
-	memcpy(&(cloned_pkt->hdr), &(pkt->hdr), sizeof(struct rr_header_v1));
-	/* TODO: Copy optional headers, if available */
 
 	pkt_fragment_q = kmalloc(sizeof(struct sk_buff_head), GFP_KERNEL);
 	if (!pkt_fragment_q) {
@@ -325,7 +318,6 @@
 		kfree_skb(temp_skb);
 	}
 	kfree(pkt_fragment_q);
-	/* TODO: Free optional headers, if present */
 	kfree(cloned_pkt);
 	return NULL;
 }
@@ -364,498 +356,28 @@
 		kfree_skb(temp_skb);
 	}
 	kfree(pkt->pkt_fragment_q);
-	/* TODO: Free Optional headers, if present */
 	kfree(pkt);
 	return;
 }
 
-static struct sk_buff_head *msm_ipc_router_buf_to_skb(void *buf,
-						unsigned int buf_len)
-{
-	struct sk_buff_head *skb_head;
-	struct sk_buff *skb;
-	int first = 1, offset = 0;
-	int skb_size, data_size;
-	void *data;
-	int last = 1;
-	int align_size;
-
-	skb_head = kmalloc(sizeof(struct sk_buff_head), GFP_KERNEL);
-	if (!skb_head) {
-		pr_err("%s: Couldnot allocate skb_head\n", __func__);
-		return NULL;
-	}
-	skb_queue_head_init(skb_head);
-
-	data_size = buf_len;
-	align_size = ALIGN_SIZE(data_size);
-	while (offset != buf_len) {
-		skb_size = data_size;
-		if (first)
-			skb_size += IPC_ROUTER_HDR_SIZE;
-		if (last)
-			skb_size += align_size;
-
-		skb = alloc_skb(skb_size, GFP_KERNEL);
-		if (!skb) {
-			if (skb_size <= (PAGE_SIZE/2)) {
-				pr_err("%s: cannot allocate skb\n", __func__);
-				goto buf_to_skb_error;
-			}
-			data_size = data_size / 2;
-			last = 0;
-			continue;
-		}
-
-		if (first) {
-			skb_reserve(skb, IPC_ROUTER_HDR_SIZE);
-			first = 0;
-		}
-
-		data = skb_put(skb, data_size);
-		memcpy(skb->data, buf + offset, data_size);
-		skb_queue_tail(skb_head, skb);
-		offset += data_size;
-		data_size = buf_len - offset;
-		last = 1;
-	}
-	return skb_head;
-
-buf_to_skb_error:
-	while (!skb_queue_empty(skb_head)) {
-		skb = skb_dequeue(skb_head);
-		kfree_skb(skb);
-	}
-	kfree(skb_head);
-	return NULL;
-}
-
-static void *msm_ipc_router_skb_to_buf(struct sk_buff_head *skb_head,
-				       unsigned int len)
-{
-	struct sk_buff *temp;
-	int offset = 0, buf_len = 0, copy_len;
-	void *buf;
-
-	if (!skb_head) {
-		pr_err("%s: NULL skb_head\n", __func__);
-		return NULL;
-	}
-
-	temp = skb_peek(skb_head);
-	buf_len = len;
-	buf = kmalloc(buf_len, GFP_KERNEL);
-	if (!buf) {
-		pr_err("%s: cannot allocate buf\n", __func__);
-		return NULL;
-	}
-	skb_queue_walk(skb_head, temp) {
-		copy_len = buf_len < temp->len ? buf_len : temp->len;
-		memcpy(buf + offset, temp->data, copy_len);
-		offset += copy_len;
-		buf_len -= copy_len;
-	}
-	return buf;
-}
-
-void msm_ipc_router_free_skb(struct sk_buff_head *skb_head)
-{
-	struct sk_buff *temp_skb;
-
-	if (!skb_head)
-		return;
-
-	while (!skb_queue_empty(skb_head)) {
-		temp_skb = skb_dequeue(skb_head);
-		kfree_skb(temp_skb);
-	}
-	kfree(skb_head);
-}
-
-/**
- * extract_header_v1() - Extract IPC Router header of version 1
- * @pkt: Packet structure into which the header has to be extraced.
- * @skb: SKB from which the header has to be extracted.
- *
- * @return: 0 on success, standard Linux error codes on failure.
- */
-static int extract_header_v1(struct rr_packet *pkt, struct sk_buff *skb)
-{
-	if (!pkt || !skb) {
-		pr_err("%s: Invalid pkt or skb\n", __func__);
-		return -EINVAL;
-	}
-
-	memcpy(&pkt->hdr, skb->data, sizeof(struct rr_header_v1));
-	skb_pull(skb, sizeof(struct rr_header_v1));
-	pkt->length -= sizeof(struct rr_header_v1);
-	return 0;
-}
-
-/**
- * extract_header_v2() - Extract IPC Router header of version 2
- * @pkt: Packet structure into which the header has to be extraced.
- * @skb: SKB from which the header has to be extracted.
- *
- * @return: 0 on success, standard Linux error codes on failure.
- */
-static int extract_header_v2(struct rr_packet *pkt, struct sk_buff *skb)
-{
-	struct rr_header_v2 *hdr;
-
-	if (!pkt || !skb) {
-		pr_err("%s: Invalid pkt or skb\n", __func__);
-		return -EINVAL;
-	}
-
-	hdr = (struct rr_header_v2 *)skb->data;
-	pkt->hdr.version = (uint32_t)hdr->version;
-	pkt->hdr.type = (uint32_t)hdr->type;
-	pkt->hdr.src_node_id = (uint32_t)hdr->src_node_id;
-	pkt->hdr.src_port_id = (uint32_t)hdr->src_port_id;
-	pkt->hdr.size = (uint32_t)hdr->size;
-	pkt->hdr.control_flag = (uint32_t)hdr->control_flag;
-	pkt->hdr.dst_node_id = (uint32_t)hdr->dst_node_id;
-	pkt->hdr.dst_port_id = (uint32_t)hdr->dst_port_id;
-	skb_pull(skb, sizeof(struct rr_header_v2));
-	pkt->length -= sizeof(struct rr_header_v2);
-	return 0;
-}
-
-/**
- * extract_header() - Extract IPC Router header
- * @pkt: Packet from which the header has to be extraced.
- *
- * @return: 0 on success, standard Linux error codes on failure.
- *
- * This function will check if the header version is v1 or v2 and invoke
- * the corresponding helper function to extract the IPC Router header.
- */
-static int extract_header(struct rr_packet *pkt)
-{
-	struct sk_buff *temp_skb;
-	int ret;
-
-	if (!pkt) {
-		pr_err("%s: NULL PKT\n", __func__);
-		return -EINVAL;
-	}
-
-	temp_skb = skb_peek(pkt->pkt_fragment_q);
-	if (!temp_skb || !temp_skb->data) {
-		pr_err("%s: No SKBs in skb_queue\n", __func__);
-		return -EINVAL;
-	}
-
-	if (temp_skb->data[0] == IPC_ROUTER_V1) {
-		ret = extract_header_v1(pkt, temp_skb);
-	} else if (temp_skb->data[0] == IPC_ROUTER_V2) {
-		ret = extract_header_v2(pkt, temp_skb);
-		/* TODO: Extract optional headers if present */
-	} else {
-		pr_err("%s: Invalid Header version %02x\n",
-			__func__, temp_skb->data[0]);
-		print_hex_dump(KERN_ERR, "Header: ", DUMP_PREFIX_ADDRESS,
-			       16, 1, temp_skb->data, pkt->length, true);
-		return -EINVAL;
-	}
-	return ret;
-}
-
-/**
- * calc_tx_header_size() - Calculate header size to be reserved in SKB
- * @pkt: Packet in which the space for header has to be reserved.
- * @dst_xprt_info: XPRT through which the destination is reachable.
- *
- * @return: required header size on success,
- *          starndard Linux error codes on failure.
- *
- * This function is used to calculate the header size that has to be reserved
- * in a transmit SKB. The header size is calculated based on the XPRT through
- * which the destination node is reachable.
- */
-static int calc_tx_header_size(struct rr_packet *pkt,
-			       struct msm_ipc_router_xprt_info *dst_xprt_info)
-{
-	int hdr_size = 0;
-	int xprt_version = 0;
-	struct msm_ipc_routing_table_entry *rt_entry;
-	struct msm_ipc_router_xprt_info *xprt_info = dst_xprt_info;
-
-	if (!pkt) {
-		pr_err("%s: NULL PKT\n", __func__);
-		return -EINVAL;
-	}
-
-	if (!xprt_info) {
-		rt_entry = lookup_routing_table(pkt->hdr.dst_node_id);
-		if (!rt_entry || !(rt_entry->xprt_info)) {
-			pr_err("%s: Node %d is not up\n",
-				__func__, pkt->hdr.dst_node_id);
-			return -ENODEV;
-		}
-
-		xprt_info = rt_entry->xprt_info;
-	}
-	if (xprt_info)
-		xprt_version = xprt_info->xprt->get_version(xprt_info->xprt);
-
-	if (xprt_version == IPC_ROUTER_V1) {
-		pkt->hdr.version = IPC_ROUTER_V1;
-		hdr_size = sizeof(struct rr_header_v1);
-	} else if (xprt_version == IPC_ROUTER_V2) {
-		pkt->hdr.version = IPC_ROUTER_V2;
-		hdr_size = sizeof(struct rr_header_v2);
-		/* TODO: Calculate optional header length, if present */
-	} else {
-		pr_err("%s: Invalid xprt_version %d\n",
-			__func__, xprt_version);
-		hdr_size = -EINVAL;
-	}
-
-	return hdr_size;
-}
-
-/**
- * calc_rx_header_size() - Calculate the RX header size
- * @xprt_info: XPRT info of the received message.
- *
- * @return: valid header size on success, INT_MAX on failure.
- */
-static int calc_rx_header_size(struct msm_ipc_router_xprt_info *xprt_info)
-{
-	int xprt_version = 0;
-	int hdr_size = INT_MAX;
-
-	if (xprt_info)
-		xprt_version = xprt_info->xprt->get_version(xprt_info->xprt);
-
-	if (xprt_version == IPC_ROUTER_V1)
-		hdr_size = sizeof(struct rr_header_v1);
-	else if (xprt_version == IPC_ROUTER_V2)
-		hdr_size = sizeof(struct rr_header_v2);
-	return hdr_size;
-}
-
-/**
- * prepend_header_v1() - Prepend IPC Router header of version 1
- * @pkt: Packet structure which contains the header info to be prepended.
- * @hdr_size: Size of the header
- *
- * @return: 0 on success, standard Linux error codes on failure.
- */
-static int prepend_header_v1(struct rr_packet *pkt, int hdr_size)
-{
-	struct sk_buff *temp_skb;
-	struct rr_header_v1 *hdr;
-
-	if (!pkt || hdr_size <= 0) {
-		pr_err("%s: Invalid input parameters\n", __func__);
-		return -EINVAL;
-	}
-
-	temp_skb = skb_peek(pkt->pkt_fragment_q);
-	if (!temp_skb || !temp_skb->data) {
-		pr_err("%s: No SKBs in skb_queue\n", __func__);
-		return -EINVAL;
-	}
-
-	if (skb_headroom(temp_skb) < hdr_size) {
-		temp_skb = alloc_skb(hdr_size, GFP_KERNEL);
-		if (!temp_skb) {
-			pr_err("%s: Could not allocate SKB of size %d\n",
-				__func__, hdr_size);
-			return -ENOMEM;
-		}
-	}
-
-	hdr = (struct rr_header_v1 *)skb_push(temp_skb, hdr_size);
-	memcpy(hdr, &pkt->hdr, hdr_size);
-	if (temp_skb != skb_peek(pkt->pkt_fragment_q))
-		skb_queue_head(pkt->pkt_fragment_q, temp_skb);
-	pkt->length += hdr_size;
-	return 0;
-}
-
-/**
- * prepend_header_v2() - Prepend IPC Router header of version 2
- * @pkt: Packet structure which contains the header info to be prepended.
- * @hdr_size: Size of the header
- *
- * @return: 0 on success, standard Linux error codes on failure.
- */
-static int prepend_header_v2(struct rr_packet *pkt, int hdr_size)
-{
-	struct sk_buff *temp_skb;
-	struct rr_header_v2 *hdr;
-
-	if (!pkt || hdr_size <= 0) {
-		pr_err("%s: Invalid input parameters\n", __func__);
-		return -EINVAL;
-	}
-
-	temp_skb = skb_peek(pkt->pkt_fragment_q);
-	if (!temp_skb || !temp_skb->data) {
-		pr_err("%s: No SKBs in skb_queue\n", __func__);
-		return -EINVAL;
-	}
-
-	if (skb_headroom(temp_skb) < hdr_size) {
-		temp_skb = alloc_skb(hdr_size, GFP_KERNEL);
-		if (!temp_skb) {
-			pr_err("%s: Could not allocate SKB of size %d\n",
-				__func__, hdr_size);
-			return -ENOMEM;
-		}
-	}
-
-	hdr = (struct rr_header_v2 *)skb_push(temp_skb, hdr_size);
-	hdr->version = (uint8_t)pkt->hdr.version;
-	hdr->type = (uint8_t)pkt->hdr.type;
-	hdr->control_flag = (uint16_t)pkt->hdr.control_flag;
-	hdr->size = (uint32_t)pkt->hdr.size;
-	hdr->src_node_id = (uint16_t)pkt->hdr.src_node_id;
-	hdr->src_port_id = (uint16_t)pkt->hdr.src_port_id;
-	hdr->dst_node_id = (uint16_t)pkt->hdr.dst_node_id;
-	hdr->dst_port_id = (uint16_t)pkt->hdr.dst_port_id;
-	/* TODO: Add optional headers, if present */
-	if (temp_skb != skb_peek(pkt->pkt_fragment_q))
-		skb_queue_head(pkt->pkt_fragment_q, temp_skb);
-	pkt->length += hdr_size;
-	return 0;
-}
-
-/**
- * prepend_header() - Prepend IPC Router header
- * @pkt: Packet structure which contains the header info to be prepended.
- * @xprt_info: XPRT through which the packet is transmitted.
- *
- * @return: 0 on success, standard Linux error codes on failure.
- *
- * This function prepends the header to the packet to be transmitted. The
- * IPC Router header version to be prepended depends on the XPRT through
- * which the destination is reachable.
- */
-static int prepend_header(struct rr_packet *pkt,
-			  struct msm_ipc_router_xprt_info *xprt_info)
-{
-	int hdr_size;
-	struct sk_buff *temp_skb;
-
-	if (!pkt) {
-		pr_err("%s: NULL PKT\n", __func__);
-		return -EINVAL;
-	}
-
-	temp_skb = skb_peek(pkt->pkt_fragment_q);
-	if (!temp_skb || !temp_skb->data) {
-		pr_err("%s: No SKBs in skb_queue\n", __func__);
-		return -EINVAL;
-	}
-
-	hdr_size = calc_tx_header_size(pkt, xprt_info);
-	if (hdr_size <= 0)
-		return hdr_size;
-
-	if (pkt->hdr.version == IPC_ROUTER_V1)
-		return prepend_header_v1(pkt, hdr_size);
-	else if (pkt->hdr.version == IPC_ROUTER_V2)
-		return prepend_header_v2(pkt, hdr_size);
-	else
-		return -EINVAL;
-}
-
-/**
- * defragment_pkt() - Defragment and linearize the packet
- * @pkt: Packet to be linearized.
- *
- * @return: 0 on success, standard Linux error codes on failure.
- *
- * Some packets contain fragments of data over multiple SKBs. If an XPRT
- * does not supported fragmented writes, linearize multiple SKBs into one
- * single SKB.
- */
-static int defragment_pkt(struct rr_packet *pkt)
-{
-	struct sk_buff *dst_skb, *src_skb, *temp_skb;
-	int offset = 0, buf_len = 0, copy_len;
-	void *buf;
-	int align_size;
-
-	if (!pkt || pkt->length <= 0) {
-		pr_err("%s: Invalid PKT\n", __func__);
-		return -EINVAL;
-	}
-
-	if (skb_queue_len(pkt->pkt_fragment_q) == 1)
-		return 0;
-
-	align_size = ALIGN_SIZE(pkt->length);
-	dst_skb = alloc_skb(pkt->length + align_size, GFP_KERNEL);
-	if (!dst_skb) {
-		pr_err("%s: could not allocate one skb of size %d\n",
-			__func__, pkt->length);
-		return -ENOMEM;
-	}
-	buf = skb_put(dst_skb, pkt->length);
-	buf_len = pkt->length;
-
-	skb_queue_walk(pkt->pkt_fragment_q, src_skb) {
-		copy_len =  buf_len < src_skb->len ? buf_len : src_skb->len;
-		memcpy(buf + offset, src_skb->data, copy_len);
-		offset += copy_len;
-		buf_len -= copy_len;
-	}
-
-	while (!skb_queue_empty(pkt->pkt_fragment_q)) {
-		temp_skb = skb_dequeue(pkt->pkt_fragment_q);
-		kfree_skb(temp_skb);
-	}
-	skb_queue_tail(pkt->pkt_fragment_q, dst_skb);
-	return 0;
-}
-
-static int post_pkt_to_port(struct msm_ipc_port *port_ptr,
-			    struct rr_packet *pkt, int clone)
-{
-	struct rr_packet *temp_pkt = pkt;
-	void (*notify)(unsigned event, void *priv);
-
-	if (unlikely(!port_ptr || !pkt))
-		return -EINVAL;
-
-	if (clone) {
-		temp_pkt = clone_pkt(pkt);
-		if (!temp_pkt) {
-			pr_err("%s: Error cloning packet for port %08x:%08x\n",
-				__func__, port_ptr->this_port.node_id,
-				port_ptr->this_port.port_id);
-			return -ENOMEM;
-		}
-	}
-
-	mutex_lock(&port_ptr->port_rx_q_lock_lhb3);
-	wake_lock(&port_ptr->port_rx_wake_lock);
-	list_add_tail(&temp_pkt->list, &port_ptr->port_rx_q);
-	wake_up(&port_ptr->port_rx_wait_q);
-	notify = port_ptr->notify;
-	mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
-	if (notify)
-		notify(MSM_IPC_ROUTER_READ_CB, port_ptr->priv);
-	return 0;
-}
-
 static int post_control_ports(struct rr_packet *pkt)
 {
 	struct msm_ipc_port *port_ptr;
+	struct rr_packet *cloned_pkt;
 
 	if (!pkt)
 		return -EINVAL;
 
-	down_read(&control_ports_lock_lha5);
-	list_for_each_entry(port_ptr, &control_ports, list)
-		post_pkt_to_port(port_ptr, pkt, 1);
-	up_read(&control_ports_lock_lha5);
+	mutex_lock(&control_ports_lock);
+	list_for_each_entry(port_ptr, &control_ports, list) {
+		mutex_lock(&port_ptr->port_rx_q_lock);
+		cloned_pkt = clone_pkt(pkt);
+		wake_lock(&port_ptr->port_rx_wake_lock);
+		list_add_tail(&cloned_pkt->list, &port_ptr->port_rx_q);
+		wake_up(&port_ptr->port_rx_wait_q);
+		mutex_unlock(&port_ptr->port_rx_q_lock);
+	}
+	mutex_unlock(&control_ports_lock);
 	return 0;
 }
 
@@ -864,12 +386,12 @@
 	uint32_t port_id = 0, prev_port_id, key;
 	struct msm_ipc_port *port_ptr;
 
-	mutex_lock(&next_port_id_lock_lha1);
+	mutex_lock(&next_port_id_lock);
 	prev_port_id = next_port_id;
-	down_read(&local_ports_lock_lha2);
+	mutex_lock(&local_ports_lock);
 	do {
 		next_port_id++;
-		if ((next_port_id & IPC_ROUTER_ADDRESS) == IPC_ROUTER_ADDRESS)
+		if ((next_port_id & 0xFFFFFFFE) == 0xFFFFFFFE)
 			next_port_id = 1;
 
 		key = (next_port_id & (LP_HASH_SIZE - 1));
@@ -889,8 +411,8 @@
 		}
 		port_id = 0;
 	} while (next_port_id != prev_port_id);
-	up_read(&local_ports_lock_lha2);
-	mutex_unlock(&next_port_id_lock_lha1);
+	mutex_unlock(&local_ports_lock);
+	mutex_unlock(&next_port_id_lock);
 
 	return port_id;
 }
@@ -903,13 +425,14 @@
 		return;
 
 	key = (port_ptr->this_port.port_id & (LP_HASH_SIZE - 1));
-	down_write(&local_ports_lock_lha2);
+	mutex_lock(&local_ports_lock);
 	list_add_tail(&port_ptr->list, &local_ports[key]);
-	up_write(&local_ports_lock_lha2);
+	mutex_unlock(&local_ports_lock);
 }
 
 struct msm_ipc_port *msm_ipc_router_create_raw_port(void *endpoint,
-		void (*notify)(unsigned event, void *priv),
+		void (*notify)(unsigned event, void *data,
+			       void *addr, void *priv),
 		void *priv)
 {
 	struct msm_ipc_port *port_ptr;
@@ -927,13 +450,15 @@
 	}
 
 	spin_lock_init(&port_ptr->port_lock);
+	INIT_LIST_HEAD(&port_ptr->incomplete);
+	mutex_init(&port_ptr->incomplete_lock);
 	INIT_LIST_HEAD(&port_ptr->port_rx_q);
-	mutex_init(&port_ptr->port_rx_q_lock_lhb3);
+	mutex_init(&port_ptr->port_rx_q_lock);
 	init_waitqueue_head(&port_ptr->port_rx_wait_q);
 	snprintf(port_ptr->rx_wakelock_name, MAX_WAKELOCK_NAME_SZ,
-		 "ipc%08x_%s",
-		 port_ptr->this_port.port_id,
-		 current->comm);
+		 "msm_ipc_read%08x:%08x",
+		 port_ptr->this_port.node_id,
+		 port_ptr->this_port.port_id);
 	wake_lock_init(&port_ptr->port_rx_wake_lock,
 			WAKE_LOCK_SUSPEND, port_ptr->rx_wakelock_name);
 
@@ -945,7 +470,9 @@
 	return port_ptr;
 }
 
-/* Must be called with local_ports_lock_lha2 locked. */
+/*
+ * Should be called with local_ports_lock locked
+ */
 static struct msm_ipc_port *msm_ipc_router_lookup_local_port(uint32_t port_id)
 {
 	int key = (port_id & (LP_HASH_SIZE - 1));
@@ -959,7 +486,6 @@
 	return NULL;
 }
 
-/* Must be called with routing_table_lock_lha3 locked. */
 static struct msm_ipc_router_remote_port *msm_ipc_router_lookup_remote_port(
 						uint32_t node_id,
 						uint32_t port_id)
@@ -968,25 +494,30 @@
 	struct msm_ipc_routing_table_entry *rt_entry;
 	int key = (port_id & (RP_HASH_SIZE - 1));
 
+	mutex_lock(&routing_table_lock);
 	rt_entry = lookup_routing_table(node_id);
 	if (!rt_entry) {
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Node is not up\n", __func__);
 		return NULL;
 	}
 
-	down_read(&rt_entry->lock_lha4);
+	mutex_lock(&rt_entry->lock);
 	list_for_each_entry(rport_ptr,
 			    &rt_entry->remote_port_list[key], list) {
 		if (rport_ptr->port_id == port_id) {
-			up_read(&rt_entry->lock_lha4);
+			if (rport_ptr->restart_state != RESTART_NORMAL)
+				rport_ptr = NULL;
+			mutex_unlock(&rt_entry->lock);
+			mutex_unlock(&routing_table_lock);
 			return rport_ptr;
 		}
 	}
-	up_read(&rt_entry->lock_lha4);
+	mutex_unlock(&rt_entry->lock);
+	mutex_unlock(&routing_table_lock);
 	return NULL;
 }
 
-/* Must be called with routing_table_lock_lha3 locked. */
 static struct msm_ipc_router_remote_port *msm_ipc_router_create_remote_port(
 						uint32_t node_id,
 						uint32_t port_id)
@@ -995,115 +526,36 @@
 	struct msm_ipc_routing_table_entry *rt_entry;
 	int key = (port_id & (RP_HASH_SIZE - 1));
 
+	mutex_lock(&routing_table_lock);
 	rt_entry = lookup_routing_table(node_id);
 	if (!rt_entry) {
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Node is not up\n", __func__);
 		return NULL;
 	}
 
+	mutex_lock(&rt_entry->lock);
 	rport_ptr = kmalloc(sizeof(struct msm_ipc_router_remote_port),
 			    GFP_KERNEL);
 	if (!rport_ptr) {
+		mutex_unlock(&rt_entry->lock);
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Remote port alloc failed\n", __func__);
 		return NULL;
 	}
 	rport_ptr->port_id = port_id;
 	rport_ptr->node_id = node_id;
-	rport_ptr->sec_rule = NULL;
-	rport_ptr->server = NULL;
+	rport_ptr->restart_state = RESTART_NORMAL;
 	rport_ptr->tx_quota_cnt = 0;
-	mutex_init(&rport_ptr->quota_lock_lhb2);
-	INIT_LIST_HEAD(&rport_ptr->resume_tx_port_list);
-	down_write(&rt_entry->lock_lha4);
+	init_waitqueue_head(&rport_ptr->quota_wait);
+	mutex_init(&rport_ptr->quota_lock);
 	list_add_tail(&rport_ptr->list,
 		      &rt_entry->remote_port_list[key]);
-	up_write(&rt_entry->lock_lha4);
+	mutex_unlock(&rt_entry->lock);
+	mutex_unlock(&routing_table_lock);
 	return rport_ptr;
 }
 
-/**
- * msm_ipc_router_free_resume_tx_port() - Free the resume_tx ports
- * @rport_ptr: Pointer to the remote port.
- *
- * This function deletes all the resume_tx ports associated with a remote port
- * and frees the memory allocated to each resume_tx port.
- *
- * Must be called with rport_ptr->quota_lock_lhb2 locked.
- */
-static void msm_ipc_router_free_resume_tx_port(
-	struct msm_ipc_router_remote_port *rport_ptr)
-{
-	struct msm_ipc_resume_tx_port *rtx_port, *tmp_rtx_port;
-
-	list_for_each_entry_safe(rtx_port, tmp_rtx_port,
-			&rport_ptr->resume_tx_port_list, list) {
-		list_del(&rtx_port->list);
-		kfree(rtx_port);
-	}
-}
-
-/**
- * msm_ipc_router_lookup_resume_tx_port() - Lookup resume_tx port list
- * @rport_ptr: Remote port whose resume_tx port list needs to be looked.
- * @port_id: Port ID which needs to be looked from the list.
- *
- * return 1 if the port_id is found in the list, else 0.
- *
- * This function is used to lookup the existence of a local port in
- * remote port's resume_tx list. This function is used to ensure that
- * the same port is not added to the remote_port's resume_tx list repeatedly.
- *
- * Must be called with rport_ptr->quota_lock_lhb2 locked.
- */
-static int msm_ipc_router_lookup_resume_tx_port(
-	struct msm_ipc_router_remote_port *rport_ptr, uint32_t port_id)
-{
-	struct msm_ipc_resume_tx_port *rtx_port;
-
-	list_for_each_entry(rtx_port, &rport_ptr->resume_tx_port_list, list) {
-		if (port_id == rtx_port->port_id)
-			return 1;
-	}
-	return 0;
-}
-
-/**
- * post_resume_tx() - Post the resume_tx event
- * @rport_ptr: Pointer to the remote port
- * @pkt : The data packet that is received on a resume_tx event
- *
- * This function informs about the reception of the resume_tx message from a
- * remote port pointed by rport_ptr to all the local ports that are in the
- * resume_tx_ports_list of this remote port. On posting the information, this
- * function sequentially deletes each entry in the resume_tx_port_list of the
- * remote port.
- *
- * Must be called with rport_ptr->quota_lock_lhb2 locked.
- */
-static void post_resume_tx(struct msm_ipc_router_remote_port *rport_ptr,
-						   struct rr_packet *pkt)
-{
-	struct msm_ipc_resume_tx_port *rtx_port, *tmp_rtx_port;
-	struct msm_ipc_port *local_port;
-
-	list_for_each_entry_safe(rtx_port, tmp_rtx_port,
-				&rport_ptr->resume_tx_port_list, list) {
-		local_port =
-			msm_ipc_router_lookup_local_port(rtx_port->port_id);
-		if (local_port && local_port->notify)
-			local_port->notify(MSM_IPC_ROUTER_RESUME_TX,
-						local_port->priv);
-		else if (local_port)
-			post_pkt_to_port(local_port, pkt, 1);
-		else
-			pr_err("%s: Local Port %d not Found",
-				__func__, rtx_port->port_id);
-		list_del(&rtx_port->list);
-		kfree(rtx_port);
-	}
-}
-
-/* Must be called with routing_table_lock_lha3 locked. */
 static void msm_ipc_router_destroy_remote_port(
 	struct msm_ipc_router_remote_port *rport_ptr)
 {
@@ -1114,35 +566,22 @@
 		return;
 
 	node_id = rport_ptr->node_id;
+	mutex_lock(&routing_table_lock);
 	rt_entry = lookup_routing_table(node_id);
 	if (!rt_entry) {
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Node %d is not up\n", __func__, node_id);
 		return;
 	}
-	down_write(&rt_entry->lock_lha4);
+
+	mutex_lock(&rt_entry->lock);
 	list_del(&rport_ptr->list);
-	up_write(&rt_entry->lock_lha4);
-	mutex_lock(&rport_ptr->quota_lock_lhb2);
-	msm_ipc_router_free_resume_tx_port(rport_ptr);
-	mutex_unlock(&rport_ptr->quota_lock_lhb2);
 	kfree(rport_ptr);
+	mutex_unlock(&rt_entry->lock);
+	mutex_unlock(&routing_table_lock);
 	return;
 }
 
-/**
- * msm_ipc_router_lookup_server() - Lookup server information
- * @service: Service ID of the server info to be looked up.
- * @instance: Instance ID of the server info to be looked up.
- * @node_id: Node/Processor ID in which the server is hosted.
- * @port_id: Port ID within the node in which the server is hosted.
- *
- * @return: If found Pointer to server structure, else NULL.
- *
- * Note1: Lock the server_list_lock_lha2 before accessing this function.
- * Note2: If the <node_id:port_id> are <0:0>, then the lookup is restricted
- *        to <service:instance>. Used only when a client wants to send a
- *        message to any QMI server.
- */
 static struct msm_ipc_server *msm_ipc_router_lookup_server(
 				uint32_t service,
 				uint32_t instance,
@@ -1151,43 +590,30 @@
 {
 	struct msm_ipc_server *server;
 	struct msm_ipc_server_port *server_port;
-	int key = (service & (SRV_HASH_SIZE - 1));
+	int key = (instance & (SRV_HASH_SIZE - 1));
 
+	mutex_lock(&server_list_lock);
 	list_for_each_entry(server, &server_list[key], list) {
 		if ((server->name.service != service) ||
 		    (server->name.instance != instance))
 			continue;
-		if ((node_id == 0) && (port_id == 0))
+		if ((node_id == 0) && (port_id == 0)) {
+			mutex_unlock(&server_list_lock);
 			return server;
+		}
 		list_for_each_entry(server_port, &server->server_port_list,
 				    list) {
 			if ((server_port->server_addr.node_id == node_id) &&
-			    (server_port->server_addr.port_id == port_id))
+			    (server_port->server_addr.port_id == port_id)) {
+				mutex_unlock(&server_list_lock);
 				return server;
+			}
 		}
 	}
+	mutex_unlock(&server_list_lock);
 	return NULL;
 }
 
-static void dummy_release(struct device *dev)
-{
-}
-
-/**
- * msm_ipc_router_create_server() - Add server info to hash table
- * @service: Service ID of the server info to be created.
- * @instance: Instance ID of the server info to be created.
- * @node_id: Node/Processor ID in which the server is hosted.
- * @port_id: Port ID within the node in which the server is hosted.
- * @xprt_info: XPRT through which the node hosting the server is reached.
- *
- * @return: Pointer to server structure on success, else NULL.
- *
- * This function adds the server info to the hash table. If the same
- * server(i.e. <service_id:instance_id>) is hosted in different nodes,
- * they are maintained as list of "server_port" under "server" structure.
- * Note: Lock the server_list_lock_lha2 before accessing this function.
- */
 static struct msm_ipc_server *msm_ipc_router_create_server(
 					uint32_t service,
 					uint32_t instance,
@@ -1197,35 +623,34 @@
 {
 	struct msm_ipc_server *server = NULL;
 	struct msm_ipc_server_port *server_port;
-	int key = (service & (SRV_HASH_SIZE - 1));
+	int key = (instance & (SRV_HASH_SIZE - 1));
 
+	mutex_lock(&server_list_lock);
 	list_for_each_entry(server, &server_list[key], list) {
 		if ((server->name.service == service) &&
 		    (server->name.instance == instance))
 			goto create_srv_port;
 	}
 
-	server = kzalloc(sizeof(struct msm_ipc_server), GFP_KERNEL);
+	server = kmalloc(sizeof(struct msm_ipc_server), GFP_KERNEL);
 	if (!server) {
+		mutex_unlock(&server_list_lock);
 		pr_err("%s: Server allocation failed\n", __func__);
 		return NULL;
 	}
 	server->name.service = service;
 	server->name.instance = instance;
-	server->synced_sec_rule = 0;
 	INIT_LIST_HEAD(&server->server_port_list);
 	list_add_tail(&server->list, &server_list[key]);
-	scnprintf(server->pdev_name, sizeof(server->pdev_name),
-		  "QMI%08x:%08x", service, instance);
-	server->next_pdev_id = 1;
 
 create_srv_port:
-	server_port = kzalloc(sizeof(struct msm_ipc_server_port), GFP_KERNEL);
+	server_port = kmalloc(sizeof(struct msm_ipc_server_port), GFP_KERNEL);
 	if (!server_port) {
 		if (list_empty(&server->server_port_list)) {
 			list_del(&server->list);
 			kfree(server);
 		}
+		mutex_unlock(&server_list_lock);
 		pr_err("%s: Server Port allocation failed\n", __func__);
 		return NULL;
 	}
@@ -1233,27 +658,11 @@
 	server_port->server_addr.port_id = port_id;
 	server_port->xprt_info = xprt_info;
 	list_add_tail(&server_port->list, &server->server_port_list);
-
-	server_port->pdev.name = server->pdev_name;
-	server_port->pdev.id = server->next_pdev_id++;
-	server_port->pdev.dev.release = dummy_release;
-	platform_device_register(&server_port->pdev);
+	mutex_unlock(&server_list_lock);
 
 	return server;
 }
 
-/**
- * msm_ipc_router_destroy_server() - Remove server info from hash table
- * @server: Server info to be removed.
- * @node_id: Node/Processor ID in which the server is hosted.
- * @port_id: Port ID within the node in which the server is hosted.
- *
- * This function removes the server_port identified using <node_id:port_id>
- * from the server structure. If the server_port list under server structure
- * is empty after removal, then remove the server structure from the server
- * hash table.
- * Note: Lock the server_list_lock_lha2 before accessing this function.
- */
 static void msm_ipc_router_destroy_server(struct msm_ipc_server *server,
 					  uint32_t node_id, uint32_t port_id)
 {
@@ -1262,13 +671,13 @@
 	if (!server)
 		return;
 
+	mutex_lock(&server_list_lock);
 	list_for_each_entry(server_port, &server->server_port_list, list) {
 		if ((server_port->server_addr.node_id == node_id) &&
 		    (server_port->server_addr.port_id == port_id))
 			break;
 	}
 	if (server_port) {
-		platform_device_unregister(&server_port->pdev);
 		list_del(&server_port->list);
 		kfree(server_port);
 	}
@@ -1276,17 +685,17 @@
 		list_del(&server->list);
 		kfree(server);
 	}
+	mutex_unlock(&server_list_lock);
 	return;
 }
 
 static int msm_ipc_router_send_control_msg(
 		struct msm_ipc_router_xprt_info *xprt_info,
-		union rr_control_msg *msg,
-		uint32_t dst_node_id)
+		union rr_control_msg *msg)
 {
 	struct rr_packet *pkt;
 	struct sk_buff *ipc_rtr_pkt;
-	struct rr_header_v1 *hdr;
+	struct rr_header *hdr;
 	int pkt_size;
 	void *data;
 	struct sk_buff_head *pkt_fragment_q;
@@ -1327,40 +736,36 @@
 	skb_reserve(ipc_rtr_pkt, IPC_ROUTER_HDR_SIZE);
 	data = skb_put(ipc_rtr_pkt, sizeof(*msg));
 	memcpy(data, msg, sizeof(*msg));
-	skb_queue_tail(pkt_fragment_q, ipc_rtr_pkt);
-	pkt->pkt_fragment_q = pkt_fragment_q;
-	pkt->length = sizeof(*msg);
+	hdr = (struct rr_header *)skb_push(ipc_rtr_pkt, IPC_ROUTER_HDR_SIZE);
+	if (!hdr) {
+		pr_err("%s: skb_push failed\n", __func__);
+		kfree_skb(ipc_rtr_pkt);
+		kfree(pkt_fragment_q);
+		kfree(pkt);
+		return -ENOMEM;
+	}
 
-	hdr = &(pkt->hdr);
-	hdr->version = IPC_ROUTER_V1;
+	hdr->version = IPC_ROUTER_VERSION;
 	hdr->type = msg->cmd;
 	hdr->src_node_id = IPC_ROUTER_NID_LOCAL;
 	hdr->src_port_id = IPC_ROUTER_ADDRESS;
-	hdr->control_flag = 0;
+	hdr->confirm_rx = 0;
 	hdr->size = sizeof(*msg);
-	if (hdr->type == IPC_ROUTER_CTRL_CMD_RESUME_TX)
-		hdr->dst_node_id = dst_node_id;
-	else
-		hdr->dst_node_id = xprt_info->remote_node_id;
+	hdr->dst_node_id = xprt_info->remote_node_id;
 	hdr->dst_port_id = IPC_ROUTER_ADDRESS;
+	skb_queue_tail(pkt_fragment_q, ipc_rtr_pkt);
+	pkt->pkt_fragment_q = pkt_fragment_q;
+	pkt->length = pkt_size;
 
-	mutex_lock(&xprt_info->tx_lock_lhb2);
-	ret = prepend_header(pkt, xprt_info);
-	if (ret < 0) {
-		mutex_unlock(&xprt_info->tx_lock_lhb2);
-		pr_err("%s: Prepend Header failed\n", __func__);
-		release_pkt(pkt);
-		return ret;
-	}
-
-	ret = xprt_info->xprt->write(pkt, pkt->length, xprt_info->xprt);
-	mutex_unlock(&xprt_info->tx_lock_lhb2);
+	mutex_lock(&xprt_info->tx_lock);
+	ret = xprt_info->xprt->write(pkt, pkt_size, xprt_info->xprt);
+	mutex_unlock(&xprt_info->tx_lock);
 
 	release_pkt(pkt);
 	return ret;
 }
 
-static int msm_ipc_router_send_server_list(uint32_t node_id,
+static int msm_ipc_router_send_server_list(
 		struct msm_ipc_router_xprt_info *xprt_info)
 {
 	union rr_control_msg ctl;
@@ -1373,17 +778,17 @@
 		return -EINVAL;
 	}
 
-	memset(&ctl, 0, sizeof(ctl));
 	ctl.cmd = IPC_ROUTER_CTRL_CMD_NEW_SERVER;
 
+	mutex_lock(&server_list_lock);
 	for (i = 0; i < SRV_HASH_SIZE; i++) {
 		list_for_each_entry(server, &server_list[i], list) {
 			ctl.srv.service = server->name.service;
 			ctl.srv.instance = server->name.instance;
 			list_for_each_entry(server_port,
 					    &server->server_port_list, list) {
-				if (server_port->server_addr.node_id !=
-				    node_id)
+				if (server_port->server_addr.node_id ==
+				    xprt_info->remote_node_id)
 					continue;
 
 				ctl.srv.node_id =
@@ -1391,10 +796,11 @@
 				ctl.srv.port_id =
 					server_port->server_addr.port_id;
 				msm_ipc_router_send_control_msg(xprt_info,
-					&ctl, IPC_ROUTER_DUMMY_DEST_NODE);
+								&ctl);
 			}
 		}
 	}
+	mutex_unlock(&server_list_lock);
 
 	return 0;
 }
@@ -1429,7 +835,7 @@
 {
 	struct rr_packet *pkt;
 	struct sk_buff *ipc_rtr_pkt;
-	struct rr_header_v1 *hdr;
+	struct rr_header *hdr;
 	int pkt_size;
 	void *data;
 	struct sk_buff_head *pkt_fragment_q;
@@ -1449,7 +855,7 @@
 	}
 	skb_queue_head_init(pkt_fragment_q);
 
-	pkt_size = sizeof(*msg);
+	pkt_size = IPC_ROUTER_HDR_SIZE + sizeof(*msg);
 	ipc_rtr_pkt = alloc_skb(pkt_size, GFP_KERNEL);
 	if (!ipc_rtr_pkt) {
 		pr_err("%s: ipc_rtr_pkt alloc failed\n", __func__);
@@ -1458,14 +864,22 @@
 		return -ENOMEM;
 	}
 
+	skb_reserve(ipc_rtr_pkt, IPC_ROUTER_HDR_SIZE);
 	data = skb_put(ipc_rtr_pkt, sizeof(*msg));
 	memcpy(data, msg, sizeof(*msg));
-	hdr = &(pkt->hdr);
-	hdr->version = IPC_ROUTER_V1;
+	hdr = (struct rr_header *)skb_push(ipc_rtr_pkt, IPC_ROUTER_HDR_SIZE);
+	if (!hdr) {
+		pr_err("%s: skb_push failed\n", __func__);
+		kfree_skb(ipc_rtr_pkt);
+		kfree(pkt_fragment_q);
+		kfree(pkt);
+		return -ENOMEM;
+	}
+	hdr->version = IPC_ROUTER_VERSION;
 	hdr->type = msg->cmd;
 	hdr->src_node_id = IPC_ROUTER_NID_LOCAL;
 	hdr->src_port_id = IPC_ROUTER_ADDRESS;
-	hdr->control_flag = 0;
+	hdr->confirm_rx = 0;
 	hdr->size = sizeof(*msg);
 	hdr->dst_node_id = IPC_ROUTER_NID_LOCAL;
 	hdr->dst_port_id = IPC_ROUTER_ADDRESS;
@@ -1482,12 +896,11 @@
 {
 	struct msm_ipc_router_xprt_info *xprt_info;
 
-	down_read(&xprt_info_list_lock_lha5);
+	mutex_lock(&xprt_info_list_lock);
 	list_for_each_entry(xprt_info, &xprt_info_list, list) {
-		msm_ipc_router_send_control_msg(xprt_info, ctl,
-					IPC_ROUTER_DUMMY_DEST_NODE);
+		msm_ipc_router_send_control_msg(xprt_info, ctl);
 	}
-	up_read(&xprt_info_list_lock_lha5);
+	mutex_unlock(&xprt_info_list_lock);
 
 	return 0;
 }
@@ -1500,580 +913,427 @@
 	if (!xprt_info || !ctl)
 		return -EINVAL;
 
-	down_read(&xprt_info_list_lock_lha5);
+	mutex_lock(&xprt_info_list_lock);
 	list_for_each_entry(fwd_xprt_info, &xprt_info_list, list) {
 		if (xprt_info->xprt->link_id != fwd_xprt_info->xprt->link_id)
-			msm_ipc_router_send_control_msg(fwd_xprt_info, ctl,
-						IPC_ROUTER_DUMMY_DEST_NODE);
+			msm_ipc_router_send_control_msg(fwd_xprt_info, ctl);
 	}
-	up_read(&xprt_info_list_lock_lha5);
+	mutex_unlock(&xprt_info_list_lock);
+
+	return 0;
+}
+
+static int relay_msg(struct msm_ipc_router_xprt_info *xprt_info,
+		     struct rr_packet *pkt)
+{
+	struct msm_ipc_router_xprt_info *fwd_xprt_info;
+
+	if (!xprt_info || !pkt)
+		return -EINVAL;
 
+	mutex_lock(&xprt_info_list_lock);
+	list_for_each_entry(fwd_xprt_info, &xprt_info_list, list) {
+		mutex_lock(&fwd_xprt_info->tx_lock);
+		if (xprt_info->xprt->link_id != fwd_xprt_info->xprt->link_id)
+			fwd_xprt_info->xprt->write(pkt, pkt->length,
+						   fwd_xprt_info->xprt);
+		mutex_unlock(&fwd_xprt_info->tx_lock);
+	}
+	mutex_unlock(&xprt_info_list_lock);
 	return 0;
 }
 
 static int forward_msg(struct msm_ipc_router_xprt_info *xprt_info,
 		       struct rr_packet *pkt)
 {
-	struct rr_header_v1 *hdr;
+	uint32_t dst_node_id;
+	struct sk_buff *head_pkt;
+	struct rr_header *hdr;
 	struct msm_ipc_router_xprt_info *fwd_xprt_info;
 	struct msm_ipc_routing_table_entry *rt_entry;
-	int ret = 0;
-	int fwd_xprt_option;
 
 	if (!xprt_info || !pkt)
 		return -EINVAL;
 
-	hdr = &(pkt->hdr);
-	down_read(&routing_table_lock_lha3);
-	rt_entry = lookup_routing_table(hdr->dst_node_id);
+	head_pkt = skb_peek(pkt->pkt_fragment_q);
+	if (!head_pkt)
+		return -EINVAL;
+
+	hdr = (struct rr_header *)head_pkt->data;
+	dst_node_id = hdr->dst_node_id;
+	mutex_lock(&routing_table_lock);
+	rt_entry = lookup_routing_table(dst_node_id);
 	if (!(rt_entry) || !(rt_entry->xprt_info)) {
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Routing table not initialized\n", __func__);
-		ret = -ENODEV;
-		goto fm_error1;
+		return -ENODEV;
 	}
 
-	down_read(&rt_entry->lock_lha4);
+	mutex_lock(&rt_entry->lock);
 	fwd_xprt_info = rt_entry->xprt_info;
-	ret = prepend_header(pkt, fwd_xprt_info);
-	if (ret < 0) {
-		pr_err("%s: Prepend Header failed\n", __func__);
-		goto fm_error2;
-	}
-	fwd_xprt_option = fwd_xprt_info->xprt->get_option(fwd_xprt_info->xprt);
-	if (!(fwd_xprt_option & FRAG_PKT_WRITE_ENABLE)) {
-		ret = defragment_pkt(pkt);
-		if (ret < 0)
-			goto fm_error2;
-	}
-
-	mutex_lock(&fwd_xprt_info->tx_lock_lhb2);
+	mutex_lock(&fwd_xprt_info->tx_lock);
 	if (xprt_info->remote_node_id == fwd_xprt_info->remote_node_id) {
+		mutex_unlock(&fwd_xprt_info->tx_lock);
+		mutex_unlock(&rt_entry->lock);
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Discarding Command to route back\n", __func__);
-		ret = -EINVAL;
-		goto fm_error3;
+		return -EINVAL;
 	}
 
 	if (xprt_info->xprt->link_id == fwd_xprt_info->xprt->link_id) {
+		mutex_unlock(&fwd_xprt_info->tx_lock);
+		mutex_unlock(&rt_entry->lock);
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: DST in the same cluster\n", __func__);
-		ret = 0;
-		goto fm_error3;
+		return 0;
 	}
 	fwd_xprt_info->xprt->write(pkt, pkt->length, fwd_xprt_info->xprt);
+	mutex_unlock(&fwd_xprt_info->tx_lock);
+	mutex_unlock(&rt_entry->lock);
+	mutex_unlock(&routing_table_lock);
 
-fm_error3:
-	mutex_unlock(&fwd_xprt_info->tx_lock_lhb2);
-fm_error2:
-	up_read(&rt_entry->lock_lha4);
-fm_error1:
-	up_read(&routing_table_lock_lha3);
-
-	return ret;
+	return 0;
 }
 
-static int msm_ipc_router_send_remove_client(struct comm_mode_info *mode_info,
-					uint32_t node_id, uint32_t port_id)
+static void reset_remote_port_info(uint32_t node_id, uint32_t port_id)
 {
-	union rr_control_msg msg;
-	struct msm_ipc_router_xprt_info *tmp_xprt_info;
-	int mode;
-	void *xprt_info;
-	int rc = 0;
-
-	if (!mode_info) {
-		pr_err("%s: NULL mode_info\n", __func__);
-		return -EINVAL;
-	}
-	mode = mode_info->mode;
-	xprt_info = mode_info->xprt_info;
-
-	memset(&msg, 0, sizeof(msg));
-	msg.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_CLIENT;
-	msg.cli.node_id = node_id;
-	msg.cli.port_id = port_id;
-
-	if ((mode == SINGLE_LINK_MODE) && xprt_info) {
-		down_read(&xprt_info_list_lock_lha5);
-		list_for_each_entry(tmp_xprt_info, &xprt_info_list, list) {
-			if (tmp_xprt_info != xprt_info)
-				continue;
-			msm_ipc_router_send_control_msg(tmp_xprt_info, &msg,
-						IPC_ROUTER_DUMMY_DEST_NODE);
-			break;
-		}
-		up_read(&xprt_info_list_lock_lha5);
-	} else if ((mode == SINGLE_LINK_MODE) && !xprt_info) {
-		broadcast_ctl_msg_locally(&msg);
-	} else if (mode == MULTI_LINK_MODE) {
-		broadcast_ctl_msg(&msg);
-		broadcast_ctl_msg_locally(&msg);
-	} else if (mode != NULL_MODE) {
-		pr_err("%s: Invalid mode(%d) + xprt_inf(%p) for %08x:%08x\n",
-			__func__, mode, xprt_info, node_id, port_id);
-		rc = -EINVAL;
-	}
-	return rc;
-}
+	struct msm_ipc_router_remote_port *rport_ptr;
 
-static void update_comm_mode_info(struct comm_mode_info *mode_info,
-				  struct msm_ipc_router_xprt_info *xprt_info)
-{
-	if (!mode_info) {
-		pr_err("%s: NULL mode_info\n", __func__);
+	rport_ptr = msm_ipc_router_lookup_remote_port(node_id, port_id);
+	if (!rport_ptr) {
+		pr_err("%s: No such remote port %08x:%08x\n",
+			__func__, node_id, port_id);
 		return;
 	}
-
-	if (mode_info->mode == NULL_MODE) {
-		mode_info->xprt_info = xprt_info;
-		mode_info->mode = SINGLE_LINK_MODE;
-	} else if (mode_info->mode == SINGLE_LINK_MODE &&
-		   mode_info->xprt_info != xprt_info) {
-		mode_info->mode = MULTI_LINK_MODE;
-	}
-
+	mutex_lock(&rport_ptr->quota_lock);
+	rport_ptr->restart_state = RESTART_PEND;
+	wake_up(&rport_ptr->quota_wait);
+	mutex_unlock(&rport_ptr->quota_lock);
 	return;
 }
 
-static void cleanup_rmt_server(struct msm_ipc_router_xprt_info *xprt_info,
-			       struct msm_ipc_router_remote_port *rport_ptr)
-{
-	union rr_control_msg ctl;
-	struct msm_ipc_server *server = rport_ptr->server;
-
-	D("Remove server %08x:%08x - %08x:%08x",
-	   server->name.service, server->name.instance,
-	   rport_ptr->node_id, rport_ptr->port_id);
-	memset(&ctl, 0, sizeof(ctl));
-	ctl.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_SERVER;
-	ctl.srv.service = server->name.service;
-	ctl.srv.instance = server->name.instance;
-	ctl.srv.node_id = rport_ptr->node_id;
-	ctl.srv.port_id = rport_ptr->port_id;
-	relay_ctl_msg(xprt_info, &ctl);
-	broadcast_ctl_msg_locally(&ctl);
-	msm_ipc_router_destroy_server(server,
-			rport_ptr->node_id, rport_ptr->port_id);
-}
-
-static void cleanup_rmt_ports(struct msm_ipc_router_xprt_info *xprt_info,
-			      struct msm_ipc_routing_table_entry *rt_entry)
-{
-	struct msm_ipc_router_remote_port *rport_ptr, *tmp_rport_ptr;
-	union rr_control_msg ctl;
-	int j;
-
-	memset(&ctl, 0, sizeof(ctl));
-	for (j = 0; j < RP_HASH_SIZE; j++) {
-		list_for_each_entry_safe(rport_ptr, tmp_rport_ptr,
-				&rt_entry->remote_port_list[j], list) {
-			list_del(&rport_ptr->list);
-			mutex_lock(&rport_ptr->quota_lock_lhb2);
-			msm_ipc_router_free_resume_tx_port(rport_ptr);
-			mutex_unlock(&rport_ptr->quota_lock_lhb2);
-
-			if (rport_ptr->server)
-				cleanup_rmt_server(xprt_info, rport_ptr);
-
-			ctl.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_CLIENT;
-			ctl.cli.node_id = rport_ptr->node_id;
-			ctl.cli.port_id = rport_ptr->port_id;
-			relay_ctl_msg(xprt_info, &ctl);
-			broadcast_ctl_msg_locally(&ctl);
-			kfree(rport_ptr);
-		}
-	}
-}
-
-static void msm_ipc_cleanup_routing_table(
-	struct msm_ipc_router_xprt_info *xprt_info)
+static void msm_ipc_cleanup_remote_server_info(
+		struct msm_ipc_router_xprt_info *xprt_info)
 {
+	struct msm_ipc_server *svr, *tmp_svr;
+	struct msm_ipc_server_port *svr_port, *tmp_svr_port;
 	int i;
-	struct msm_ipc_routing_table_entry *rt_entry, *tmp_rt_entry;
+	union rr_control_msg ctl;
 
 	if (!xprt_info) {
 		pr_err("%s: Invalid xprt_info\n", __func__);
 		return;
 	}
 
-	down_write(&server_list_lock_lha2);
-	down_write(&routing_table_lock_lha3);
-	for (i = 0; i < RT_HASH_SIZE; i++) {
-		list_for_each_entry_safe(rt_entry, tmp_rt_entry,
-					 &routing_table[i], list) {
-			down_write(&rt_entry->lock_lha4);
-			if (rt_entry->xprt_info != xprt_info) {
-				up_write(&rt_entry->lock_lha4);
-				continue;
+	ctl.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_SERVER;
+	mutex_lock(&server_list_lock);
+	for (i = 0; i < SRV_HASH_SIZE; i++) {
+		list_for_each_entry_safe(svr, tmp_svr, &server_list[i], list) {
+			ctl.srv.service = svr->name.service;
+			ctl.srv.instance = svr->name.instance;
+			list_for_each_entry_safe(svr_port, tmp_svr_port,
+					 &svr->server_port_list, list) {
+				if (svr_port->xprt_info != xprt_info)
+					continue;
+				D("Remove server %08x:%08x - %08x:%08x",
+				   ctl.srv.service, ctl.srv.instance,
+				   svr_port->server_addr.node_id,
+				   svr_port->server_addr.port_id);
+				reset_remote_port_info(
+					svr_port->server_addr.node_id,
+					svr_port->server_addr.port_id);
+				ctl.srv.node_id = svr_port->server_addr.node_id;
+				ctl.srv.port_id = svr_port->server_addr.port_id;
+				relay_ctl_msg(xprt_info, &ctl);
+				broadcast_ctl_msg_locally(&ctl);
+				list_del(&svr_port->list);
+				kfree(svr_port);
+			}
+			if (list_empty(&svr->server_port_list)) {
+				list_del(&svr->list);
+				kfree(svr);
 			}
-			cleanup_rmt_ports(xprt_info, rt_entry);
-			rt_entry->xprt_info = NULL;
-			up_write(&rt_entry->lock_lha4);
-			list_del(&rt_entry->list);
-			kfree(rt_entry);
-		}
-	}
-	up_write(&routing_table_lock_lha3);
-	up_write(&server_list_lock_lha2);
-}
-
-/**
- * sync_sec_rule() - Synchrnoize the security rule into the server structure
- * @server: Server structure where the rule has to be synchronized.
- * @rule: Security tule to be synchronized.
- *
- * This function is used to update the server structure with the security
- * rule configured for the <service:instance> corresponding to that server.
- */
-static void sync_sec_rule(struct msm_ipc_server *server, void *rule)
-{
-	struct msm_ipc_server_port *server_port;
-	struct msm_ipc_router_remote_port *rport_ptr = NULL;
-
-	down_read(&routing_table_lock_lha3);
-	list_for_each_entry(server_port, &server->server_port_list, list) {
-		rport_ptr = msm_ipc_router_lookup_remote_port(
-				server_port->server_addr.node_id,
-				server_port->server_addr.port_id);
-		if (!rport_ptr)
-			continue;
-		rport_ptr->sec_rule = rule;
-	}
-	up_read(&routing_table_lock_lha3);
-	server->synced_sec_rule = 1;
-}
-
-/**
- * msm_ipc_sync_sec_rule() - Sync the security rule to the service
- * @service: Service for which the rule has to be synchronized.
- * @instance: Instance for which the rule has to be synchronized.
- * @rule: Security rule to be synchronized.
- *
- * This function is used to syncrhonize the security rule with the server
- * hash table, if the user-space script configures the rule after the service
- * has come up. This function is used to synchronize the security rule to a
- * specific service and optionally a specific instance.
- */
-void msm_ipc_sync_sec_rule(uint32_t service, uint32_t instance, void *rule)
-{
-	int key = (service & (SRV_HASH_SIZE - 1));
-	struct msm_ipc_server *server;
-
-	down_write(&server_list_lock_lha2);
-	list_for_each_entry(server, &server_list[key], list) {
-		if (server->name.service != service)
-			continue;
-
-		if (server->name.instance != instance &&
-		    instance != ALL_INSTANCE)
-			continue;
-
-		/*
-		 * If the rule applies to all instances and if the specific
-		 * instance of a service has a rule synchronized already,
-		 * do not apply the rule for that specific instance.
-		 */
-		if (instance == ALL_INSTANCE && server->synced_sec_rule)
-			continue;
-
-		sync_sec_rule(server, rule);
-	}
-	up_write(&server_list_lock_lha2);
-}
-
-/**
- * msm_ipc_sync_default_sec_rule() - Default security rule to all services
- * @rule: Security rule to be synchronized.
- *
- * This function is used to syncrhonize the security rule with the server
- * hash table, if the user-space script configures the rule after the service
- * has come up. This function is used to synchronize the security rule that
- * applies to all services, if the concerned service do not have any rule
- * defined.
- */
-void msm_ipc_sync_default_sec_rule(void *rule)
-{
-	int key;
-	struct msm_ipc_server *server;
-
-	down_write(&server_list_lock_lha2);
-	for (key = 0; key < SRV_HASH_SIZE; key++) {
-		list_for_each_entry(server, &server_list[key], list) {
-			if (server->synced_sec_rule)
-				continue;
-
-			sync_sec_rule(server, rule);
 		}
 	}
-	up_write(&server_list_lock_lha2);
+	mutex_unlock(&server_list_lock);
 }
 
-static int process_hello_msg(struct msm_ipc_router_xprt_info *xprt_info,
-			     struct rr_header_v1 *hdr)
+static void msm_ipc_cleanup_remote_client_info(
+		struct msm_ipc_router_xprt_info *xprt_info)
 {
-	int i, rc = 0;
-	union rr_control_msg ctl;
 	struct msm_ipc_routing_table_entry *rt_entry;
+	struct msm_ipc_router_remote_port *rport_ptr;
+	int i, j;
+	union rr_control_msg ctl;
 
-	if (!hdr)
-		return -EINVAL;
-
-	RR("o HELLO NID %d\n", hdr->src_node_id);
-
-	xprt_info->remote_node_id = hdr->src_node_id;
-	/*
-	 * Find the entry from Routing Table corresponding to Node ID.
-	 * Under SSR, an entry will be found. When the system boots up
-	 * for the 1st time, an entry will not be found and hence allocate
-	 * an entry. Update the entry with the Node ID that it corresponds
-	 * to and the XPRT through which it can be reached.
-	 */
-	down_write(&routing_table_lock_lha3);
-	rt_entry = lookup_routing_table(hdr->src_node_id);
-	if (!rt_entry) {
-		rt_entry = alloc_routing_table_entry(hdr->src_node_id);
-		if (!rt_entry) {
-			up_write(&routing_table_lock_lha3);
-			pr_err("%s: rt_entry allocation failed\n", __func__);
-			return -ENOMEM;
-		}
-		add_routing_table_entry(rt_entry);
+	if (!xprt_info) {
+		pr_err("%s: Invalid xprt_info\n", __func__);
+		return;
 	}
-	down_write(&rt_entry->lock_lha4);
-	rt_entry->neighbor_node_id = xprt_info->remote_node_id;
-	rt_entry->xprt_info = xprt_info;
-	up_write(&rt_entry->lock_lha4);
-	up_write(&routing_table_lock_lha3);
-
-	/* Send a reply HELLO message */
-	memset(&ctl, 0, sizeof(ctl));
-	ctl.hello.cmd = IPC_ROUTER_CTRL_CMD_HELLO;
-	rc = msm_ipc_router_send_control_msg(xprt_info, &ctl,
-						IPC_ROUTER_DUMMY_DEST_NODE);
-	if (rc < 0) {
-		pr_err("%s: Error sending reply HELLO message\n", __func__);
-		return rc;
-	}
-	xprt_info->initialized = 1;
-
-	/*
-	 * Send list of servers from the local node and from nodes
-	 * outside the mesh network in which this XPRT is part of.
-	 */
-	down_read(&server_list_lock_lha2);
-	down_read(&routing_table_lock_lha3);
+
+	ctl.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_CLIENT;
+	mutex_lock(&routing_table_lock);
 	for (i = 0; i < RT_HASH_SIZE; i++) {
 		list_for_each_entry(rt_entry, &routing_table[i], list) {
-			if ((rt_entry->node_id != IPC_ROUTER_NID_LOCAL) &&
-			    (!rt_entry->xprt_info ||
-			     (rt_entry->xprt_info->xprt->link_id ==
-			      xprt_info->xprt->link_id)))
+			mutex_lock(&rt_entry->lock);
+			if (rt_entry->xprt_info != xprt_info) {
+				mutex_unlock(&rt_entry->lock);
 				continue;
-			rc = msm_ipc_router_send_server_list(rt_entry->node_id,
-							     xprt_info);
-			if (rc < 0) {
-				up_read(&routing_table_lock_lha3);
-				up_read(&server_list_lock_lha2);
-				return rc;
 			}
+			for (j = 0; j < RP_HASH_SIZE; j++) {
+				list_for_each_entry(rport_ptr,
+					&rt_entry->remote_port_list[j], list) {
+					if (rport_ptr->restart_state ==
+						RESTART_PEND)
+						continue;
+					mutex_lock(&rport_ptr->quota_lock);
+					rport_ptr->restart_state = RESTART_PEND;
+					wake_up(&rport_ptr->quota_wait);
+					mutex_unlock(&rport_ptr->quota_lock);
+					ctl.cli.node_id = rport_ptr->node_id;
+					ctl.cli.port_id = rport_ptr->port_id;
+					broadcast_ctl_msg_locally(&ctl);
+				}
+			}
+			mutex_unlock(&rt_entry->lock);
 		}
 	}
-	up_read(&routing_table_lock_lha3);
-	up_read(&server_list_lock_lha2);
-	RR("HELLO message processed\n");
-	return rc;
+	mutex_unlock(&routing_table_lock);
 }
 
-static int process_resume_tx_msg(union rr_control_msg *msg,
-				 struct rr_packet *pkt)
+static void msm_ipc_cleanup_remote_port_info(uint32_t node_id)
 {
-	struct msm_ipc_router_remote_port *rport_ptr;
-	int ret = 0;
-
-	RR("o RESUME_TX id=%d:%08x\n", msg->cli.node_id, msg->cli.port_id);
-
-	down_read(&local_ports_lock_lha2);
-	down_read(&routing_table_lock_lha3);
-	rport_ptr = msm_ipc_router_lookup_remote_port(msg->cli.node_id,
-						      msg->cli.port_id);
-	if (!rport_ptr) {
-		pr_err("%s: Unable to resume client\n", __func__);
-		ret = -ENODEV;
-		goto prtm_out;
-	}
-	mutex_lock(&rport_ptr->quota_lock_lhb2);
-	rport_ptr->tx_quota_cnt = 0;
-	post_resume_tx(rport_ptr, pkt);
-	mutex_unlock(&rport_ptr->quota_lock_lhb2);
-prtm_out:
-	up_read(&routing_table_lock_lha3);
-	up_read(&local_ports_lock_lha2);
-	return 0;
-}
-
-static int process_new_server_msg(struct msm_ipc_router_xprt_info *xprt_info,
-			union rr_control_msg *msg, struct rr_packet *pkt)
-{
-	struct msm_ipc_routing_table_entry *rt_entry;
-	struct msm_ipc_server *server;
-	struct msm_ipc_router_remote_port *rport_ptr;
-
-	if (msg->srv.instance == 0) {
-		pr_err("%s: Server %08x create rejected, version = 0\n",
-			__func__, msg->srv.service);
-		return -EINVAL;
-	}
-
-	RR("o NEW_SERVER id=%d:%08x service=%08x:%08x\n", msg->srv.node_id,
-	    msg->srv.port_id, msg->srv.service, msg->srv.instance);
-	/*
-	 * Find the entry from Routing Table corresponding to Node ID.
-	 * Under SSR, an entry will be found. When the subsystem hosting
-	 * service is not adjacent, an entry will not be found and hence
-	 * allocate an entry. Update the entry with the Node ID that it
-	 * corresponds to and the XPRT through which it can be reached.
-	 */
-	down_write(&routing_table_lock_lha3);
-	rt_entry = lookup_routing_table(msg->srv.node_id);
-	if (!rt_entry) {
-		rt_entry = alloc_routing_table_entry(msg->srv.node_id);
-		if (!rt_entry) {
-			up_write(&routing_table_lock_lha3);
-			pr_err("%s: rt_entry allocation failed\n", __func__);
-			return -ENOMEM;
-		}
-		down_write(&rt_entry->lock_lha4);
-		rt_entry->neighbor_node_id = xprt_info->remote_node_id;
-		rt_entry->xprt_info = xprt_info;
-		up_write(&rt_entry->lock_lha4);
-		add_routing_table_entry(rt_entry);
-	}
-	up_write(&routing_table_lock_lha3);
-
-	/*
-	 * If the service does not exist already in the database, create and
-	 * store the service info. Create a remote port structure in which
-	 * the service is hosted and cache the security rule for the service
-	 * in that remote port structure.
-	 */
-	down_write(&server_list_lock_lha2);
-	server = msm_ipc_router_lookup_server(msg->srv.service,
-			msg->srv.instance, msg->srv.node_id, msg->srv.port_id);
-	if (!server) {
-		server = msm_ipc_router_create_server(
-				msg->srv.service, msg->srv.instance,
-				msg->srv.node_id, msg->srv.port_id, xprt_info);
-		if (!server) {
-			up_write(&server_list_lock_lha2);
-			pr_err("%s: Server Create failed\n", __func__);
-			return -ENOMEM;
-		}
+	struct msm_ipc_routing_table_entry *rt_entry, *tmp_rt_entry;
+	struct msm_ipc_router_remote_port *rport_ptr, *tmp_rport_ptr;
+	int i, j;
 
-		down_read(&routing_table_lock_lha3);
-		if (!msm_ipc_router_lookup_remote_port(
-				msg->srv.node_id, msg->srv.port_id)) {
-			rport_ptr = msm_ipc_router_create_remote_port(
-					msg->srv.node_id, msg->srv.port_id);
-			if (!rport_ptr) {
-				up_read(&routing_table_lock_lha3);
-				up_write(&server_list_lock_lha2);
-				return -ENOMEM;
+	mutex_lock(&routing_table_lock);
+	for (i = 0; i < RT_HASH_SIZE; i++) {
+		list_for_each_entry_safe(rt_entry, tmp_rt_entry,
+					 &routing_table[i], list) {
+			mutex_lock(&rt_entry->lock);
+			if (rt_entry->neighbor_node_id != node_id) {
+				mutex_unlock(&rt_entry->lock);
+				continue;
 			}
-			rport_ptr->server = server;
-			rport_ptr->sec_rule = msm_ipc_get_security_rule(
-						msg->srv.service,
-						msg->srv.instance);
-		}
-		up_read(&routing_table_lock_lha3);
-	}
-	up_write(&server_list_lock_lha2);
-
-	/*
-	 * Relay the new server message to other subsystems that do not belong
-	 * to the cluster from which this message is received. Notify the
-	 * local clients waiting for this service.
-	 */
-	relay_ctl_msg(xprt_info, msg);
-	post_control_ports(pkt);
-	return 0;
+			for (j = 0; j < RP_HASH_SIZE; j++) {
+				list_for_each_entry_safe(rport_ptr,
+					tmp_rport_ptr,
+					&rt_entry->remote_port_list[j], list) {
+					list_del(&rport_ptr->list);
+					kfree(rport_ptr);
+				}
+			}
+			mutex_unlock(&rt_entry->lock);
+		}
+	}
+	mutex_unlock(&routing_table_lock);
 }
 
-static int process_rmv_server_msg(struct msm_ipc_router_xprt_info *xprt_info,
-			union rr_control_msg *msg, struct rr_packet *pkt)
+static void msm_ipc_cleanup_routing_table(
+	struct msm_ipc_router_xprt_info *xprt_info)
 {
-	struct msm_ipc_server *server;
+	int i;
+	struct msm_ipc_routing_table_entry *rt_entry;
 
-	RR("o REMOVE_SERVER service=%08x:%d\n",
-	    msg->srv.service, msg->srv.instance);
-	down_write(&server_list_lock_lha2);
-	server = msm_ipc_router_lookup_server(msg->srv.service,
-			msg->srv.instance, msg->srv.node_id, msg->srv.port_id);
-	if (server) {
-		msm_ipc_router_destroy_server(server, msg->srv.node_id,
-					      msg->srv.port_id);
-		/*
-		 * Relay the new server message to other subsystems that do not
-		 * belong to the cluster from which this message is received.
-		 * Notify the local clients communicating with the service.
-		 */
-		relay_ctl_msg(xprt_info, msg);
-		post_control_ports(pkt);
+	if (!xprt_info) {
+		pr_err("%s: Invalid xprt_info\n", __func__);
+		return;
 	}
-	up_write(&server_list_lock_lha2);
-	return 0;
+
+	mutex_lock(&routing_table_lock);
+	for (i = 0; i < RT_HASH_SIZE; i++) {
+		list_for_each_entry(rt_entry, &routing_table[i], list) {
+			mutex_lock(&rt_entry->lock);
+			if (rt_entry->xprt_info == xprt_info)
+				rt_entry->xprt_info = NULL;
+			mutex_unlock(&rt_entry->lock);
+		}
+	}
+	mutex_unlock(&routing_table_lock);
 }
 
-static int process_rmv_client_msg(struct msm_ipc_router_xprt_info *xprt_info,
-			union rr_control_msg *msg, struct rr_packet *pkt)
+static void modem_reset_cleanup(struct msm_ipc_router_xprt_info *xprt_info)
 {
-	struct msm_ipc_router_remote_port *rport_ptr;
 
-	RR("o REMOVE_CLIENT id=%d:%08x\n", msg->cli.node_id, msg->cli.port_id);
-	down_write(&routing_table_lock_lha3);
-	rport_ptr = msm_ipc_router_lookup_remote_port(msg->cli.node_id,
-						      msg->cli.port_id);
-	if (rport_ptr)
-		msm_ipc_router_destroy_remote_port(rport_ptr);
-	up_write(&routing_table_lock_lha3);
+	if (!xprt_info) {
+		pr_err("%s: Invalid xprt_info\n", __func__);
+		return;
+	}
 
-	relay_ctl_msg(xprt_info, msg);
-	post_control_ports(pkt);
-	return 0;
+	msm_ipc_cleanup_remote_server_info(xprt_info);
+	msm_ipc_cleanup_remote_client_info(xprt_info);
+	msm_ipc_cleanup_routing_table(xprt_info);
 }
 
 static int process_control_msg(struct msm_ipc_router_xprt_info *xprt_info,
 			       struct rr_packet *pkt)
 {
+	union rr_control_msg ctl;
 	union rr_control_msg *msg;
+	struct msm_ipc_router_remote_port *rport_ptr;
 	int rc = 0;
-	struct rr_header_v1 *hdr;
+	static uint32_t first = 1;
+	struct sk_buff *temp_ptr;
+	struct rr_header *hdr;
+	struct msm_ipc_server *server;
+	struct msm_ipc_routing_table_entry *rt_entry;
 
-	if (pkt->length != sizeof(*msg)) {
+	if (pkt->length != (IPC_ROUTER_HDR_SIZE + sizeof(*msg))) {
 		pr_err("%s: r2r msg size %d != %d\n", __func__, pkt->length,
-			sizeof(*msg));
+			(IPC_ROUTER_HDR_SIZE + sizeof(*msg)));
 		return -EINVAL;
 	}
 
-	hdr = &(pkt->hdr);
-	msg = msm_ipc_router_skb_to_buf(pkt->pkt_fragment_q, sizeof(*msg));
-	if (!msg) {
-		pr_err("%s: Error extracting control msg\n", __func__);
-		return -ENOMEM;
+	temp_ptr = skb_peek(pkt->pkt_fragment_q);
+	if (!temp_ptr) {
+		pr_err("%s: pkt_fragment_q is empty\n", __func__);
+		return -EINVAL;
+	}
+	hdr = (struct rr_header *)temp_ptr->data;
+	if (!hdr) {
+		pr_err("%s: No data inside the skb\n", __func__);
+		return -EINVAL;
 	}
+	msg = (union rr_control_msg *)((char *)hdr + IPC_ROUTER_HDR_SIZE);
 
 	switch (msg->cmd) {
 	case IPC_ROUTER_CTRL_CMD_HELLO:
-		rc = process_hello_msg(xprt_info, hdr);
+		RR("o HELLO NID %d\n", hdr->src_node_id);
+		xprt_info->remote_node_id = hdr->src_node_id;
+
+		mutex_lock(&routing_table_lock);
+		rt_entry = lookup_routing_table(hdr->src_node_id);
+		if (!rt_entry) {
+			rt_entry = alloc_routing_table_entry(hdr->src_node_id);
+			if (!rt_entry) {
+				mutex_unlock(&routing_table_lock);
+				pr_err("%s: rt_entry allocation failed\n",
+					__func__);
+				return -ENOMEM;
+			}
+			add_routing_table_entry(rt_entry);
+		}
+		mutex_lock(&rt_entry->lock);
+		rt_entry->neighbor_node_id = xprt_info->remote_node_id;
+		rt_entry->xprt_info = xprt_info;
+		mutex_unlock(&rt_entry->lock);
+		mutex_unlock(&routing_table_lock);
+		msm_ipc_cleanup_remote_port_info(xprt_info->remote_node_id);
+
+		memset(&ctl, 0, sizeof(ctl));
+		ctl.cmd = IPC_ROUTER_CTRL_CMD_HELLO;
+		msm_ipc_router_send_control_msg(xprt_info, &ctl);
+
+		xprt_info->initialized = 1;
+
+		/* Send list of servers one at a time */
+		msm_ipc_router_send_server_list(xprt_info);
+
+		if (first) {
+			first = 0;
+			complete_all(&msm_ipc_remote_router_up);
+		}
+		RR("HELLO message processed\n");
 		break;
 	case IPC_ROUTER_CTRL_CMD_RESUME_TX:
-		rc = process_resume_tx_msg(msg, pkt);
+		RR("o RESUME_TX id=%d:%08x\n",
+		   msg->cli.node_id, msg->cli.port_id);
+
+		rport_ptr = msm_ipc_router_lookup_remote_port(msg->cli.node_id,
+							msg->cli.port_id);
+		if (!rport_ptr) {
+			pr_err("%s: Unable to resume client\n", __func__);
+			break;
+		}
+		mutex_lock(&rport_ptr->quota_lock);
+		rport_ptr->tx_quota_cnt = 0;
+		mutex_unlock(&rport_ptr->quota_lock);
+		wake_up(&rport_ptr->quota_wait);
 		break;
+
 	case IPC_ROUTER_CTRL_CMD_NEW_SERVER:
-		rc = process_new_server_msg(xprt_info, msg, pkt);
+		if (msg->srv.instance == 0) {
+			pr_err(
+			"rpcrouter: Server create rejected, version = 0, "
+			"service = %08x\n", msg->srv.service);
+			break;
+		}
+
+		RR("o NEW_SERVER id=%d:%08x service=%08x:%08x\n",
+		   msg->srv.node_id, msg->srv.port_id,
+		   msg->srv.service, msg->srv.instance);
+
+		mutex_lock(&routing_table_lock);
+		rt_entry = lookup_routing_table(msg->srv.node_id);
+		if (!rt_entry) {
+			rt_entry = alloc_routing_table_entry(msg->srv.node_id);
+			if (!rt_entry) {
+				mutex_unlock(&routing_table_lock);
+				pr_err("%s: rt_entry allocation failed\n",
+					__func__);
+				return -ENOMEM;
+			}
+			mutex_lock(&rt_entry->lock);
+			rt_entry->neighbor_node_id = xprt_info->remote_node_id;
+			rt_entry->xprt_info = xprt_info;
+			mutex_unlock(&rt_entry->lock);
+			add_routing_table_entry(rt_entry);
+		}
+		mutex_unlock(&routing_table_lock);
+
+		server = msm_ipc_router_lookup_server(msg->srv.service,
+						      msg->srv.instance,
+						      msg->srv.node_id,
+						      msg->srv.port_id);
+		if (!server) {
+			server = msm_ipc_router_create_server(
+				msg->srv.service, msg->srv.instance,
+				msg->srv.node_id, msg->srv.port_id, xprt_info);
+			if (!server) {
+				pr_err("%s: Server Create failed\n", __func__);
+				return -ENOMEM;
+			}
+
+			if (!msm_ipc_router_lookup_remote_port(
+					msg->srv.node_id, msg->srv.port_id)) {
+				rport_ptr = msm_ipc_router_create_remote_port(
+					msg->srv.node_id, msg->srv.port_id);
+				if (!rport_ptr)
+					pr_err("%s: Remote port create "
+					       "failed\n", __func__);
+			}
+			wake_up(&newserver_wait);
+		}
+
+		relay_msg(xprt_info, pkt);
+		post_control_ports(pkt);
 		break;
 	case IPC_ROUTER_CTRL_CMD_REMOVE_SERVER:
-		rc = process_rmv_server_msg(xprt_info, msg, pkt);
+		RR("o REMOVE_SERVER service=%08x:%d\n",
+		   msg->srv.service, msg->srv.instance);
+		server = msm_ipc_router_lookup_server(msg->srv.service,
+						      msg->srv.instance,
+						      msg->srv.node_id,
+						      msg->srv.port_id);
+		if (server) {
+			msm_ipc_router_destroy_server(server,
+						      msg->srv.node_id,
+						      msg->srv.port_id);
+			relay_msg(xprt_info, pkt);
+			post_control_ports(pkt);
+		}
 		break;
 	case IPC_ROUTER_CTRL_CMD_REMOVE_CLIENT:
-		rc = process_rmv_client_msg(xprt_info, msg, pkt);
+		RR("o REMOVE_CLIENT id=%d:%08x\n",
+		    msg->cli.node_id, msg->cli.port_id);
+		rport_ptr = msm_ipc_router_lookup_remote_port(msg->cli.node_id,
+							msg->cli.port_id);
+		if (rport_ptr)
+			msm_ipc_router_destroy_remote_port(rport_ptr);
+
+		relay_msg(xprt_info, pkt);
+		post_control_ports(pkt);
 		break;
 	case IPC_ROUTER_CTRL_CMD_PING:
 		/* No action needed for ping messages received */
@@ -2083,17 +1343,19 @@
 		RR("o UNKNOWN(%08x)\n", msg->cmd);
 		rc = -ENOSYS;
 	}
-	kfree(msg);
+
 	return rc;
 }
 
 static void do_read_data(struct work_struct *work)
 {
-	struct rr_header_v1 *hdr;
+	struct rr_header *hdr;
 	struct rr_packet *pkt = NULL;
 	struct msm_ipc_port *port_ptr;
+	struct sk_buff *head_skb;
+	struct msm_ipc_port_addr *src_addr;
 	struct msm_ipc_router_remote_port *rport_ptr;
-	int ret;
+	uint32_t resume_tx, resume_tx_node_id, resume_tx_port_id;
 
 	struct msm_ipc_router_xprt_info *xprt_info =
 		container_of(work,
@@ -2101,21 +1363,30 @@
 			     read_data);
 
 	while ((pkt = rr_read(xprt_info)) != NULL) {
-		if (pkt->length < calc_rx_header_size(xprt_info) ||
+		if (pkt->length < IPC_ROUTER_HDR_SIZE ||
 		    pkt->length > MAX_IPC_PKT_SIZE) {
 			pr_err("%s: Invalid pkt length %d\n",
 				__func__, pkt->length);
 			goto fail_data;
 		}
 
-		ret = extract_header(pkt);
-		if (ret < 0)
+		head_skb = skb_peek(pkt->pkt_fragment_q);
+		if (!head_skb) {
+			pr_err("%s: head_skb is invalid\n", __func__);
+			goto fail_data;
+		}
+
+		hdr = (struct rr_header *)(head_skb->data);
+		RR("- ver=%d type=%d src=%d:%08x crx=%d siz=%d dst=%d:%08x\n",
+		   hdr->version, hdr->type, hdr->src_node_id, hdr->src_port_id,
+		   hdr->confirm_rx, hdr->size, hdr->dst_node_id,
+		   hdr->dst_port_id);
+
+		if (hdr->version != IPC_ROUTER_VERSION) {
+			pr_err("version %d != %d\n",
+				hdr->version, IPC_ROUTER_VERSION);
 			goto fail_data;
-		hdr = &(pkt->hdr);
-		RAW("ver=%d type=%d src=%d:%08x crx=%d siz=%d dst=%d:%08x\n",
-		     hdr->version, hdr->type, hdr->src_node_id,
-		     hdr->src_port_id, hdr->control_flag, hdr->size,
-		     hdr->dst_node_id, hdr->dst_port_id);
+		}
 
 		if ((hdr->dst_node_id != IPC_ROUTER_NID_LOCAL) &&
 		    ((hdr->type == IPC_ROUTER_CTRL_CMD_RESUME_TX) ||
@@ -2125,7 +1396,8 @@
 			continue;
 		}
 
-		if (hdr->type != IPC_ROUTER_CTRL_CMD_DATA) {
+		if ((hdr->dst_port_id == IPC_ROUTER_ADDRESS) ||
+		    (hdr->type == IPC_ROUTER_CTRL_CMD_HELLO)) {
 			process_control_msg(xprt_info, pkt);
 			release_pkt(pkt);
 			continue;
@@ -2134,31 +1406,35 @@
 #if defined(DEBUG)
 		if (msm_ipc_router_debug_mask & SMEM_LOG) {
 			smem_log_event((SMEM_LOG_PROC_ID_APPS |
-				SMEM_LOG_IPC_ROUTER_EVENT_BASE |
+				SMEM_LOG_RPC_ROUTER_EVENT_BASE |
 				IPC_ROUTER_LOG_EVENT_RX),
 				(hdr->src_node_id << 24) |
 				(hdr->src_port_id & 0xffffff),
 				(hdr->dst_node_id << 24) |
 				(hdr->dst_port_id & 0xffffff),
-				(hdr->type << 24) | (hdr->control_flag << 16) |
+				(hdr->type << 24) | (hdr->confirm_rx << 16) |
 				(hdr->size & 0xffff));
 		}
 #endif
 #endif
 
-		down_read(&local_ports_lock_lha2);
+		resume_tx = hdr->confirm_rx;
+		resume_tx_node_id = hdr->dst_node_id;
+		resume_tx_port_id = hdr->dst_port_id;
+
+		rport_ptr = msm_ipc_router_lookup_remote_port(hdr->src_node_id,
+						      hdr->src_port_id);
+
+		mutex_lock(&local_ports_lock);
 		port_ptr = msm_ipc_router_lookup_local_port(hdr->dst_port_id);
 		if (!port_ptr) {
 			pr_err("%s: No local port id %08x\n", __func__,
 				hdr->dst_port_id);
-			up_read(&local_ports_lock_lha2);
+			mutex_unlock(&local_ports_lock);
 			release_pkt(pkt);
-			return;
+			goto process_done;
 		}
 
-		down_read(&routing_table_lock_lha3);
-		rport_ptr = msm_ipc_router_lookup_remote_port(hdr->src_node_id,
-							hdr->src_port_id);
 		if (!rport_ptr) {
 			rport_ptr = msm_ipc_router_create_remote_port(
 							hdr->src_node_id,
@@ -2167,15 +1443,49 @@
 				pr_err("%s: Rmt Prt %08x:%08x create failed\n",
 					__func__, hdr->src_node_id,
 					hdr->src_port_id);
-				up_read(&routing_table_lock_lha3);
-				up_read(&local_ports_lock_lha2);
-				release_pkt(pkt);
-				return;
+				mutex_unlock(&local_ports_lock);
+				goto process_done;
+			}
+		}
+
+		if (!port_ptr->notify) {
+			mutex_lock(&port_ptr->port_rx_q_lock);
+			wake_lock(&port_ptr->port_rx_wake_lock);
+			list_add_tail(&pkt->list, &port_ptr->port_rx_q);
+			wake_up(&port_ptr->port_rx_wait_q);
+			mutex_unlock(&port_ptr->port_rx_q_lock);
+			mutex_unlock(&local_ports_lock);
+		} else {
+			mutex_lock(&port_ptr->port_rx_q_lock);
+			src_addr = kmalloc(sizeof(struct msm_ipc_port_addr),
+					   GFP_KERNEL);
+			if (src_addr) {
+				src_addr->node_id = hdr->src_node_id;
+				src_addr->port_id = hdr->src_port_id;
 			}
+			skb_pull(head_skb, IPC_ROUTER_HDR_SIZE);
+			mutex_unlock(&local_ports_lock);
+			port_ptr->notify(MSM_IPC_ROUTER_READ_CB,
+				pkt->pkt_fragment_q, src_addr, port_ptr->priv);
+			mutex_unlock(&port_ptr->port_rx_q_lock);
+			pkt->pkt_fragment_q = NULL;
+			src_addr = NULL;
+			release_pkt(pkt);
+		}
+
+process_done:
+		if (resume_tx) {
+			union rr_control_msg msg;
+
+			msg.cmd = IPC_ROUTER_CTRL_CMD_RESUME_TX;
+			msg.cli.node_id = resume_tx_node_id;
+			msg.cli.port_id = resume_tx_port_id;
+
+			RR("x RESUME_TX id=%d:%08x\n",
+			   msg.cli.node_id, msg.cli.port_id);
+			msm_ipc_router_send_control_msg(xprt_info, &msg);
 		}
-		up_read(&routing_table_lock_lha3);
-		post_pkt_to_port(port_ptr, pkt, 0);
-		up_read(&local_ports_lock_lha2);
+
 	}
 	return;
 
@@ -2197,13 +1507,11 @@
 	if (name->addrtype != MSM_IPC_ADDR_NAME)
 		return -EINVAL;
 
-	down_write(&server_list_lock_lha2);
 	server = msm_ipc_router_lookup_server(name->addr.port_name.service,
 					      name->addr.port_name.instance,
 					      IPC_ROUTER_NID_LOCAL,
 					      port_ptr->this_port.port_id);
 	if (server) {
-		up_write(&server_list_lock_lha2);
 		pr_err("%s: Server already present\n", __func__);
 		return -EINVAL;
 	}
@@ -2214,23 +1522,18 @@
 					      port_ptr->this_port.port_id,
 					      NULL);
 	if (!server) {
-		up_write(&server_list_lock_lha2);
 		pr_err("%s: Server Creation failed\n", __func__);
 		return -EINVAL;
 	}
 
-	memset(&ctl, 0, sizeof(ctl));
 	ctl.cmd = IPC_ROUTER_CTRL_CMD_NEW_SERVER;
 	ctl.srv.service = server->name.service;
 	ctl.srv.instance = server->name.instance;
 	ctl.srv.node_id = IPC_ROUTER_NID_LOCAL;
 	ctl.srv.port_id = port_ptr->this_port.port_id;
-	up_write(&server_list_lock_lha2);
 	broadcast_ctl_msg(&ctl);
-	broadcast_ctl_msg_locally(&ctl);
 	spin_lock_irqsave(&port_ptr->port_lock, flags);
 	port_ptr->type = SERVER_PORT;
-	port_ptr->mode_info.mode = MULTI_LINK_MODE;
 	port_ptr->port_name.service = server->name.service;
 	port_ptr->port_name.instance = server->name.instance;
 	spin_unlock_irqrestore(&port_ptr->port_lock, flags);
@@ -2258,28 +1561,23 @@
 		return -EINVAL;
 	}
 
-	down_write(&server_list_lock_lha2);
 	server = msm_ipc_router_lookup_server(port_ptr->port_name.service,
 					      port_ptr->port_name.instance,
 					      port_ptr->this_port.node_id,
 					      port_ptr->this_port.port_id);
 	if (!server) {
-		up_write(&server_list_lock_lha2);
 		pr_err("%s: Server lookup failed\n", __func__);
 		return -ENODEV;
 	}
 
-	memset(&ctl, 0, sizeof(ctl));
 	ctl.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_SERVER;
 	ctl.srv.service = server->name.service;
 	ctl.srv.instance = server->name.instance;
 	ctl.srv.node_id = IPC_ROUTER_NID_LOCAL;
 	ctl.srv.port_id = port_ptr->this_port.port_id;
+	broadcast_ctl_msg(&ctl);
 	msm_ipc_router_destroy_server(server, port_ptr->this_port.node_id,
 				      port_ptr->this_port.port_id);
-	up_write(&server_list_lock_lha2);
-	broadcast_ctl_msg(&ctl);
-	broadcast_ctl_msg_locally(&ctl);
 	spin_lock_irqsave(&port_ptr->port_lock, flags);
 	port_ptr->type = CLIENT_PORT;
 	spin_unlock_irqrestore(&port_ptr->port_lock, flags);
@@ -2290,12 +1588,10 @@
 			uint32_t port_id,
 			struct sk_buff_head *data)
 {
-	struct rr_header_v1 *hdr;
+	struct sk_buff *head_skb;
+	struct rr_header *hdr;
 	struct msm_ipc_port *port_ptr;
 	struct rr_packet *pkt;
-	int ret_len;
-	struct sk_buff *temp_skb;
-	int align_size;
 
 	if (!data) {
 		pr_err("%s: Invalid pkt pointer\n", __func__);
@@ -2307,156 +1603,156 @@
 		pr_err("%s: New pkt create failed\n", __func__);
 		return -ENOMEM;
 	}
-	hdr = &(pkt->hdr);
-	hdr->version = IPC_ROUTER_V1;
+
+	head_skb = skb_peek(pkt->pkt_fragment_q);
+	if (!head_skb) {
+		pr_err("%s: pkt_fragment_q is empty\n", __func__);
+		return -EINVAL;
+	}
+	hdr = (struct rr_header *)skb_push(head_skb, IPC_ROUTER_HDR_SIZE);
+	if (!hdr) {
+		pr_err("%s: Prepend Header failed\n", __func__);
+		release_pkt(pkt);
+		return -ENOMEM;
+	}
+	hdr->version = IPC_ROUTER_VERSION;
 	hdr->type = IPC_ROUTER_CTRL_CMD_DATA;
 	hdr->src_node_id = src->this_port.node_id;
 	hdr->src_port_id = src->this_port.port_id;
 	hdr->size = pkt->length;
-	hdr->control_flag = 0;
+	hdr->confirm_rx = 0;
 	hdr->dst_node_id = IPC_ROUTER_NID_LOCAL;
 	hdr->dst_port_id = port_id;
+	pkt->length += IPC_ROUTER_HDR_SIZE;
 
-	temp_skb = skb_peek_tail(pkt->pkt_fragment_q);
-	align_size = ALIGN_SIZE(pkt->length);
-	skb_put(temp_skb, align_size);
-	pkt->length += align_size;
-
-	down_read(&local_ports_lock_lha2);
+	mutex_lock(&local_ports_lock);
 	port_ptr = msm_ipc_router_lookup_local_port(port_id);
 	if (!port_ptr) {
 		pr_err("%s: Local port %d not present\n", __func__, port_id);
-		up_read(&local_ports_lock_lha2);
-		pkt->pkt_fragment_q = NULL;
+		mutex_unlock(&local_ports_lock);
 		release_pkt(pkt);
 		return -ENODEV;
 	}
 
-	ret_len = hdr->size;
-	post_pkt_to_port(port_ptr, pkt, 0);
-	update_comm_mode_info(&src->mode_info, NULL);
-	up_read(&local_ports_lock_lha2);
+	mutex_lock(&port_ptr->port_rx_q_lock);
+	wake_lock(&port_ptr->port_rx_wake_lock);
+	list_add_tail(&pkt->list, &port_ptr->port_rx_q);
+	wake_up(&port_ptr->port_rx_wait_q);
+	mutex_unlock(&port_ptr->port_rx_q_lock);
+	mutex_unlock(&local_ports_lock);
 
-	return ret_len;
+	return pkt->length;
 }
 
 static int msm_ipc_router_write_pkt(struct msm_ipc_port *src,
 				struct msm_ipc_router_remote_port *rport_ptr,
 				struct rr_packet *pkt)
 {
-	struct rr_header_v1 *hdr;
+	struct sk_buff *head_skb;
+	struct rr_header *hdr;
 	struct msm_ipc_router_xprt_info *xprt_info;
 	struct msm_ipc_routing_table_entry *rt_entry;
-	struct msm_ipc_resume_tx_port  *resume_tx_port;
-	struct sk_buff *temp_skb;
-	int xprt_option;
 	int ret;
-	int align_size;
+	DEFINE_WAIT(__wait);
 
 	if (!rport_ptr || !src || !pkt)
 		return -EINVAL;
 
-	hdr = &(pkt->hdr);
+	head_skb = skb_peek(pkt->pkt_fragment_q);
+	if (!head_skb) {
+		pr_err("%s: pkt_fragment_q is empty\n", __func__);
+		return -EINVAL;
+	}
+	hdr = (struct rr_header *)skb_push(head_skb, IPC_ROUTER_HDR_SIZE);
+	if (!hdr) {
+		pr_err("%s: Prepend Header failed\n", __func__);
+		return -ENOMEM;
+	}
+	hdr->version = IPC_ROUTER_VERSION;
 	hdr->type = IPC_ROUTER_CTRL_CMD_DATA;
 	hdr->src_node_id = src->this_port.node_id;
 	hdr->src_port_id = src->this_port.port_id;
 	hdr->size = pkt->length;
-	hdr->control_flag = 0;
+	hdr->confirm_rx = 0;
 	hdr->dst_node_id = rport_ptr->node_id;
 	hdr->dst_port_id = rport_ptr->port_id;
+	pkt->length += IPC_ROUTER_HDR_SIZE;
 
-	mutex_lock(&rport_ptr->quota_lock_lhb2);
-	if (rport_ptr->tx_quota_cnt == IPC_ROUTER_DEFAULT_RX_QUOTA) {
-		if (msm_ipc_router_lookup_resume_tx_port(
-			rport_ptr, src->this_port.port_id)) {
-			mutex_unlock(&rport_ptr->quota_lock_lhb2);
-			return -EAGAIN;
-		}
-		resume_tx_port =
-			kzalloc(sizeof(struct msm_ipc_resume_tx_port),
-							GFP_KERNEL);
-		if (!resume_tx_port) {
-			pr_err("%s: Resume_Tx port allocation failed\n",
-								__func__);
-			mutex_unlock(&rport_ptr->quota_lock_lhb2);
-			return -ENOMEM;
-		}
-		INIT_LIST_HEAD(&resume_tx_port->list);
-		resume_tx_port->port_id = src->this_port.port_id;
-		resume_tx_port->node_id = src->this_port.node_id;
-		list_add_tail(&resume_tx_port->list,
-				&rport_ptr->resume_tx_port_list);
-		mutex_unlock(&rport_ptr->quota_lock_lhb2);
-		return -EAGAIN;
+	for (;;) {
+		prepare_to_wait(&rport_ptr->quota_wait, &__wait,
+				TASK_INTERRUPTIBLE);
+		mutex_lock(&rport_ptr->quota_lock);
+		if (rport_ptr->restart_state != RESTART_NORMAL)
+			break;
+		if (rport_ptr->tx_quota_cnt <
+		     IPC_ROUTER_DEFAULT_RX_QUOTA)
+			break;
+		if (signal_pending(current))
+			break;
+		mutex_unlock(&rport_ptr->quota_lock);
+		schedule();
+	}
+	finish_wait(&rport_ptr->quota_wait, &__wait);
+
+	if (rport_ptr->restart_state != RESTART_NORMAL) {
+		mutex_unlock(&rport_ptr->quota_lock);
+		return -ENETRESET;
+	}
+	if (signal_pending(current)) {
+		mutex_unlock(&rport_ptr->quota_lock);
+		return -ERESTARTSYS;
 	}
 	rport_ptr->tx_quota_cnt++;
 	if (rport_ptr->tx_quota_cnt == IPC_ROUTER_DEFAULT_RX_QUOTA)
-		hdr->control_flag |= CONTROL_FLAG_CONFIRM_RX;
-	mutex_unlock(&rport_ptr->quota_lock_lhb2);
+		hdr->confirm_rx = 1;
+	mutex_unlock(&rport_ptr->quota_lock);
 
+	mutex_lock(&routing_table_lock);
 	rt_entry = lookup_routing_table(hdr->dst_node_id);
 	if (!rt_entry || !rt_entry->xprt_info) {
+		mutex_unlock(&routing_table_lock);
 		pr_err("%s: Remote node %d not up\n",
 			__func__, hdr->dst_node_id);
 		return -ENODEV;
 	}
-	down_read(&rt_entry->lock_lha4);
+	mutex_lock(&rt_entry->lock);
 	xprt_info = rt_entry->xprt_info;
-	ret = prepend_header(pkt, xprt_info);
-	if (ret < 0) {
-		up_read(&rt_entry->lock_lha4);
-		pr_err("%s: Prepend Header failed\n", __func__);
-		return ret;
-	}
-	xprt_option = xprt_info->xprt->get_option(xprt_info->xprt);
-	if (!(xprt_option & FRAG_PKT_WRITE_ENABLE)) {
-		ret = defragment_pkt(pkt);
-		if (ret < 0) {
-			up_read(&rt_entry->lock_lha4);
-			return ret;
-		}
-	}
-
-	temp_skb = skb_peek_tail(pkt->pkt_fragment_q);
-	align_size = ALIGN_SIZE(pkt->length);
-	skb_put(temp_skb, align_size);
-	pkt->length += align_size;
-	mutex_lock(&xprt_info->tx_lock_lhb2);
+	mutex_lock(&xprt_info->tx_lock);
 	ret = xprt_info->xprt->write(pkt, pkt->length, xprt_info->xprt);
-	mutex_unlock(&xprt_info->tx_lock_lhb2);
-	up_read(&rt_entry->lock_lha4);
+	mutex_unlock(&xprt_info->tx_lock);
+	mutex_unlock(&rt_entry->lock);
+	mutex_unlock(&routing_table_lock);
 
 	if (ret < 0) {
 		pr_err("%s: Write on XPRT failed\n", __func__);
 		return ret;
 	}
-	update_comm_mode_info(&src->mode_info, xprt_info);
 
 	RAW_HDR("[w rr_h] "
 		"ver=%i,type=%s,src_nid=%08x,src_port_id=%08x,"
-		"control_flag=%i,size=%3i,dst_pid=%08x,dst_cid=%08x\n",
+		"confirm_rx=%i,size=%3i,dst_pid=%08x,dst_cid=%08x\n",
 		hdr->version, type_to_str(hdr->type),
 		hdr->src_node_id, hdr->src_port_id,
-		hdr->control_flag, hdr->size,
+		hdr->confirm_rx, hdr->size,
 		hdr->dst_node_id, hdr->dst_port_id);
 
 #if defined(CONFIG_MSM_SMD_LOGGING)
 #if defined(DEBUG)
 	if (msm_ipc_router_debug_mask & SMEM_LOG) {
 		smem_log_event((SMEM_LOG_PROC_ID_APPS |
-			SMEM_LOG_IPC_ROUTER_EVENT_BASE |
+			SMEM_LOG_RPC_ROUTER_EVENT_BASE |
 			IPC_ROUTER_LOG_EVENT_TX),
 			(hdr->src_node_id << 24) |
 			(hdr->src_port_id & 0xffffff),
 			(hdr->dst_node_id << 24) |
 			(hdr->dst_port_id & 0xffffff),
-			(hdr->type << 24) | (hdr->control_flag << 16) |
+			(hdr->type << 24) | (hdr->confirm_rx << 16) |
 			(hdr->size & 0xffff));
 	}
 #endif
 #endif
 
-	return hdr->size;
+	return pkt->length;
 }
 
 int msm_ipc_router_send_to(struct msm_ipc_port *src,
@@ -2480,181 +1776,97 @@
 		dst_node_id = dest->addr.port_addr.node_id;
 		dst_port_id = dest->addr.port_addr.port_id;
 	} else if (dest->addrtype == MSM_IPC_ADDR_NAME) {
-		down_read(&server_list_lock_lha2);
 		server = msm_ipc_router_lookup_server(
 					dest->addr.port_name.service,
 					dest->addr.port_name.instance,
 					0, 0);
 		if (!server) {
-			up_read(&server_list_lock_lha2);
 			pr_err("%s: Destination not reachable\n", __func__);
 			return -ENODEV;
 		}
+		mutex_lock(&server_list_lock);
 		server_port = list_first_entry(&server->server_port_list,
 					       struct msm_ipc_server_port,
 					       list);
 		dst_node_id = server_port->server_addr.node_id;
 		dst_port_id = server_port->server_addr.port_id;
-		up_read(&server_list_lock_lha2);
+		mutex_unlock(&server_list_lock);
 	}
 	if (dst_node_id == IPC_ROUTER_NID_LOCAL) {
 		ret = loopback_data(src, dst_port_id, data);
 		return ret;
 	}
 
-	down_read(&routing_table_lock_lha3);
+	/* Achieve Flow control */
 	rport_ptr = msm_ipc_router_lookup_remote_port(dst_node_id,
 						      dst_port_id);
 	if (!rport_ptr) {
-		up_read(&routing_table_lock_lha3);
-		pr_err("%s: Remote port not found\n", __func__);
-		return -ENODEV;
-	}
-
-	if (src->check_send_permissions) {
-		ret = src->check_send_permissions(rport_ptr->sec_rule);
-		if (ret <= 0) {
-			up_read(&routing_table_lock_lha3);
-			pr_err("%s: permission failure for %s\n",
-				__func__, current->comm);
-			return -EPERM;
-		}
+		pr_err("%s: Could not create remote port\n", __func__);
+		return -ENOMEM;
 	}
 
 	pkt = create_pkt(data);
 	if (!pkt) {
-		up_read(&routing_table_lock_lha3);
 		pr_err("%s: Pkt creation failed\n", __func__);
 		return -ENOMEM;
 	}
 
 	ret = msm_ipc_router_write_pkt(src, rport_ptr, pkt);
-	up_read(&routing_table_lock_lha3);
-	if (ret < 0)
-		pkt->pkt_fragment_q = NULL;
 	release_pkt(pkt);
 
 	return ret;
 }
 
-int msm_ipc_router_send_msg(struct msm_ipc_port *src,
-			    struct msm_ipc_addr *dest,
-			    void *data, unsigned int data_len)
-{
-	struct sk_buff_head *out_skb_head;
-	int ret;
-
-	out_skb_head = msm_ipc_router_buf_to_skb(data, data_len);
-	if (!out_skb_head) {
-		pr_err("%s: SKB conversion failed\n", __func__);
-		return -EFAULT;
-	}
-
-	ret = msm_ipc_router_send_to(src, out_skb_head, dest);
-	if (ret < 0) {
-		if (ret != -EAGAIN)
-			pr_err("%s: msm_ipc_router_send_to failed - ret: %d\n",
-				__func__, ret);
-		msm_ipc_router_free_skb(out_skb_head);
-		return ret;
-	}
-	return 0;
-}
-
-/**
- * msm_ipc_router_send_resume_tx() - Send Resume_Tx message
- * @data: Pointer to received data packet that has confirm_rx bit set
- *
- * @return: On success, number of bytes transferred is returned, else
- *	    standard linux error code is returned.
- *
- * This function sends the Resume_Tx event to the remote node that
- * sent the data with confirm_rx field set. In case of a multi-hop
- * scenario also, this function makes sure that the destination node_id
- * to which the resume_tx event should reach is right.
- */
-static int msm_ipc_router_send_resume_tx(void *data)
-{
-	union rr_control_msg msg;
-	struct rr_header_v1 *hdr = (struct rr_header_v1 *)data;
-	struct msm_ipc_routing_table_entry *rt_entry;
-	int ret;
-
-	memset(&msg, 0, sizeof(msg));
-	msg.cmd = IPC_ROUTER_CTRL_CMD_RESUME_TX;
-	msg.cli.node_id = hdr->dst_node_id;
-	msg.cli.port_id = hdr->dst_port_id;
-	down_read(&routing_table_lock_lha3);
-	rt_entry = lookup_routing_table(hdr->src_node_id);
-	if (!rt_entry) {
-		pr_err("%s: %d Node is not present",
-				__func__, hdr->src_node_id);
-		up_read(&routing_table_lock_lha3);
-		return -ENODEV;
-	}
-	RR("x RESUME_TX id=%d:%08x\n",
-			msg.cli.node_id, msg.cli.port_id);
-	ret = msm_ipc_router_send_control_msg(rt_entry->xprt_info, &msg,
-						hdr->src_node_id);
-	up_read(&routing_table_lock_lha3);
-	if (ret < 0)
-		pr_err("%s: Send Resume_Tx Failed SRC_NODE: %d SRC_PORT: %d DEST_NODE: %d",
-			__func__, hdr->dst_node_id, hdr->dst_port_id,
-			hdr->src_node_id);
-
-	return ret;
-}
-
 int msm_ipc_router_read(struct msm_ipc_port *port_ptr,
-			struct rr_packet **read_pkt,
+			struct sk_buff_head **data,
 			size_t buf_len)
 {
 	struct rr_packet *pkt;
+	int ret;
 
-	if (!port_ptr || !read_pkt)
+	if (!port_ptr || !data)
 		return -EINVAL;
 
-	mutex_lock(&port_ptr->port_rx_q_lock_lhb3);
+	mutex_lock(&port_ptr->port_rx_q_lock);
 	if (list_empty(&port_ptr->port_rx_q)) {
-		mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
+		mutex_unlock(&port_ptr->port_rx_q_lock);
 		return -EAGAIN;
 	}
 
 	pkt = list_first_entry(&port_ptr->port_rx_q, struct rr_packet, list);
-	if ((buf_len) && (pkt->hdr.size > buf_len)) {
-		mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
+	if ((buf_len) && ((pkt->length - IPC_ROUTER_HDR_SIZE) > buf_len)) {
+		mutex_unlock(&port_ptr->port_rx_q_lock);
 		return -ETOOSMALL;
 	}
 	list_del(&pkt->list);
 	if (list_empty(&port_ptr->port_rx_q))
 		wake_unlock(&port_ptr->port_rx_wake_lock);
-	*read_pkt = pkt;
-	mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
-	if (pkt->hdr.control_flag & CONTROL_FLAG_CONFIRM_RX)
-		msm_ipc_router_send_resume_tx(&pkt->hdr);
+	*data = pkt->pkt_fragment_q;
+	ret = pkt->length;
+	kfree(pkt);
+	mutex_unlock(&port_ptr->port_rx_q_lock);
 
-	return pkt->length;
+	return ret;
 }
 
-/**
- * msm_ipc_router_rx_data_wait() - Wait for new message destined to a local port.
- * @port_ptr: Pointer to the local port
- * @timeout: < 0 timeout indicates infinite wait till a message arrives.
- *	     > 0 timeout indicates the wait time.
- *	     0 indicates that we do not wait.
- * @return: 0 if there are pending messages to read,
- *	    standard Linux error code otherwise.
- *
- * Checks for the availability of messages that are destined to a local port.
- * If no messages are present then waits as per @timeout.
- */
-int msm_ipc_router_rx_data_wait(struct msm_ipc_port *port_ptr, long timeout)
+int msm_ipc_router_recv_from(struct msm_ipc_port *port_ptr,
+			     struct sk_buff_head **data,
+			     struct msm_ipc_addr *src,
+			     unsigned long timeout)
 {
-	int ret = 0;
+	int ret, data_len, align_size;
+	struct sk_buff *temp_skb;
+	struct rr_header *hdr = NULL;
+
+	if (!port_ptr || !data) {
+		pr_err("%s: Invalid pointers being passed\n", __func__);
+		return -EINVAL;
+	}
 
-	mutex_lock(&port_ptr->port_rx_q_lock_lhb3);
+	*data = NULL;
+	mutex_lock(&port_ptr->port_rx_q_lock);
 	while (list_empty(&port_ptr->port_rx_q)) {
-		mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
+		mutex_unlock(&port_ptr->port_rx_q_lock);
 		if (timeout < 0) {
 			ret = wait_event_interruptible(
 					port_ptr->port_rx_wait_q,
@@ -2670,62 +1882,17 @@
 				return -EFAULT;
 		}
 		if (timeout == 0)
-			return -ENOMSG;
-		mutex_lock(&port_ptr->port_rx_q_lock_lhb3);
-	}
-	mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
-
-	return ret;
-}
-
-/**
- * msm_ipc_router_recv_from() - Recieve messages destined to a local port.
- * @port_ptr: Pointer to the local port
- * @pkt : Pointer to the router-to-router packet
- * @src: Pointer to local port address
- * @timeout: < 0 timeout indicates infinite wait till a message arrives.
- *	     > 0 timeout indicates the wait time.
- *	     0 indicates that we do not wait.
- * @return: = Number of bytes read(On successful read operation).
- *	    = -ENOMSG (If there are no pending messages and timeout is 0).
- *	    = -EINVAL (If either of the arguments, port_ptr or data is invalid)
- *	    = -EFAULT (If there are no pending messages when timeout is > 0
- *	      and the wait_event_interruptible_timeout has returned value > 0)
- *	    = -ERESTARTSYS (If there are no pending messages when timeout
- *	      is < 0 and wait_event_interruptible was interrupted by a signal)
- *
- * This function reads the messages that are destined for a local port. It
- * is used by modules that exist with-in the kernel and use IPC Router for
- * transport. The function checks if there are any messages that are already
- * received. If yes, it reads them, else it waits as per the timeout value.
- * On a successful read, the return value of the function indicates the number
- * of bytes that are read.
- */
-int msm_ipc_router_recv_from(struct msm_ipc_port *port_ptr,
-			     struct rr_packet **pkt,
-			     struct msm_ipc_addr *src,
-			     long timeout)
-{
-	int ret, data_len, align_size;
-	struct sk_buff *temp_skb;
-	struct rr_header_v1 *hdr = NULL;
-
-	if (!port_ptr || !pkt) {
-		pr_err("%s: Invalid pointers being passed\n", __func__);
-		return -EINVAL;
+			return -ETIMEDOUT;
+		mutex_lock(&port_ptr->port_rx_q_lock);
 	}
+	mutex_unlock(&port_ptr->port_rx_q_lock);
 
-	*pkt = NULL;
-
-	ret = msm_ipc_router_rx_data_wait(port_ptr, timeout);
-	if (ret)
-		return ret;
-
-	ret = msm_ipc_router_read(port_ptr, pkt, 0);
-	if (ret <= 0 || !(*pkt))
+	ret = msm_ipc_router_read(port_ptr, data, 0);
+	if (ret <= 0 || !(*data))
 		return ret;
 
-	hdr = &((*pkt)->hdr);
+	temp_skb = skb_peek(*data);
+	hdr = (struct rr_header *)(temp_skb->data);
 	if (src) {
 		src->addrtype = MSM_IPC_ADDR_ID;
 		src->addr.port_addr.node_id = hdr->src_node_id;
@@ -2733,51 +1900,20 @@
 	}
 
 	data_len = hdr->size;
+	skb_pull(temp_skb, IPC_ROUTER_HDR_SIZE);
 	align_size = ALIGN_SIZE(data_len);
 	if (align_size) {
-		temp_skb = skb_peek_tail((*pkt)->pkt_fragment_q);
+		temp_skb = skb_peek_tail(*data);
 		skb_trim(temp_skb, (temp_skb->len - align_size));
 	}
 	return data_len;
 }
 
-int msm_ipc_router_read_msg(struct msm_ipc_port *port_ptr,
-			    struct msm_ipc_addr *src,
-			    unsigned char **data,
-			    unsigned int *len)
-{
-	struct rr_packet *pkt;
-	int ret;
-
-	ret = msm_ipc_router_recv_from(port_ptr, &pkt, src, 0);
-	if (ret < 0) {
-		if (ret != -ENOMSG)
-			pr_err("%s: msm_ipc_router_recv_from failed - ret: %d\n",
-				__func__, ret);
-		return ret;
-	}
-
-	*data = msm_ipc_router_skb_to_buf(pkt->pkt_fragment_q, ret);
-	if (!(*data))
-		pr_err("%s: Buf conversion failed\n", __func__);
-
-	*len = ret;
-	release_pkt(pkt);
-	return 0;
-}
-
 struct msm_ipc_port *msm_ipc_router_create_port(
-	void (*notify)(unsigned event, void *priv),
+	void (*notify)(unsigned event, void *data, void *addr, void *priv),
 	void *priv)
 {
 	struct msm_ipc_port *port_ptr;
-	int ret;
-
-	ret = wait_for_completion_interruptible(&msm_ipc_local_router_up);
-	if (ret < 0) {
-		pr_err("%s: Error waiting for local router\n", __func__);
-		return NULL;
-	}
 
 	port_ptr = msm_ipc_router_create_raw_port(NULL, notify, priv);
 	if (!port_ptr)
@@ -2796,12 +1932,11 @@
 		return -EINVAL;
 
 	if (port_ptr->type == SERVER_PORT || port_ptr->type == CLIENT_PORT) {
-		down_write(&local_ports_lock_lha2);
+		mutex_lock(&local_ports_lock);
 		list_del(&port_ptr->list);
-		up_write(&local_ports_lock_lha2);
+		mutex_unlock(&local_ports_lock);
 
 		if (port_ptr->type == SERVER_PORT) {
-			memset(&msg, 0, sizeof(msg));
 			msg.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_SERVER;
 			msg.srv.service = port_ptr->port_name.service;
 			msg.srv.instance = port_ptr->port_name.instance;
@@ -2810,39 +1945,29 @@
 			RR("x REMOVE_SERVER Name=%d:%08x Id=%d:%08x\n",
 			   msg.srv.service, msg.srv.instance,
 			   msg.srv.node_id, msg.srv.port_id);
-			broadcast_ctl_msg(&msg);
-			broadcast_ctl_msg_locally(&msg);
+		} else if (port_ptr->type == CLIENT_PORT) {
+			msg.cmd = IPC_ROUTER_CTRL_CMD_REMOVE_CLIENT;
+			msg.cli.node_id = port_ptr->this_port.node_id;
+			msg.cli.port_id = port_ptr->this_port.port_id;
+			RR("x REMOVE_CLIENT id=%d:%08x\n",
+			   msg.cli.node_id, msg.cli.port_id);
 		}
-
-		/*
-		 * Server port could have been a client port earlier.
-		 * Send REMOVE_CLIENT message in either case.
-		 */
-		RR("x REMOVE_CLIENT id=%d:%08x\n",
-		   port_ptr->this_port.node_id, port_ptr->this_port.port_id);
-		msm_ipc_router_send_remove_client(&port_ptr->mode_info,
-			port_ptr->this_port.node_id,
-			port_ptr->this_port.port_id);
+		broadcast_ctl_msg(&msg);
+		broadcast_ctl_msg_locally(&msg);
 	} else if (port_ptr->type == CONTROL_PORT) {
-		down_write(&control_ports_lock_lha5);
+		mutex_lock(&control_ports_lock);
 		list_del(&port_ptr->list);
-		up_write(&control_ports_lock_lha5);
-	} else if (port_ptr->type == IRSC_PORT) {
-		down_write(&local_ports_lock_lha2);
-		list_del(&port_ptr->list);
-		up_write(&local_ports_lock_lha2);
-		signal_irsc_completion();
+		mutex_unlock(&control_ports_lock);
 	}
 
-	mutex_lock(&port_ptr->port_rx_q_lock_lhb3);
+	mutex_lock(&port_ptr->port_rx_q_lock);
 	list_for_each_entry_safe(pkt, temp_pkt, &port_ptr->port_rx_q, list) {
 		list_del(&pkt->list);
 		release_pkt(pkt);
 	}
-	mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
+	mutex_unlock(&port_ptr->port_rx_q_lock);
 
 	if (port_ptr->type == SERVER_PORT) {
-		down_write(&server_list_lock_lha2);
 		server = msm_ipc_router_lookup_server(
 				port_ptr->port_name.service,
 				port_ptr->port_name.instance,
@@ -2852,7 +1977,6 @@
 			msm_ipc_router_destroy_server(server,
 				port_ptr->this_port.node_id,
 				port_ptr->this_port.port_id);
-		up_write(&server_list_lock_lha2);
 	}
 
 	wake_lock_destroy(&port_ptr->port_rx_wake_lock);
@@ -2868,13 +1992,13 @@
 	if (!port_ptr)
 		return -EINVAL;
 
-	mutex_lock(&port_ptr->port_rx_q_lock_lhb3);
+	mutex_lock(&port_ptr->port_rx_q_lock);
 	if (!list_empty(&port_ptr->port_rx_q)) {
 		pkt = list_first_entry(&port_ptr->port_rx_q,
 					struct rr_packet, list);
 		rc = pkt->length;
 	}
-	mutex_unlock(&port_ptr->port_rx_q_lock_lhb3);
+	mutex_unlock(&port_ptr->port_rx_q_lock);
 
 	return rc;
 }
@@ -2884,13 +2008,13 @@
 	if (!port_ptr)
 		return -EINVAL;
 
-	down_write(&local_ports_lock_lha2);
+	mutex_lock(&local_ports_lock);
 	list_del(&port_ptr->list);
-	up_write(&local_ports_lock_lha2);
+	mutex_unlock(&local_ports_lock);
 	port_ptr->type = CONTROL_PORT;
-	down_write(&control_ports_lock_lha5);
+	mutex_lock(&control_ports_lock);
 	list_add_tail(&port_ptr->list, &control_ports);
-	up_write(&control_ports_lock_lha5);
+	mutex_unlock(&control_ports_lock);
 
 	return 0;
 }
@@ -2914,30 +2038,33 @@
 		return -EINVAL;
 	}
 
-	down_read(&server_list_lock_lha2);
+	mutex_lock(&server_list_lock);
 	if (!lookup_mask)
 		lookup_mask = 0xFFFFFFFF;
-	key = (srv_name->service & (SRV_HASH_SIZE - 1));
-	list_for_each_entry(server, &server_list[key], list) {
-		if ((server->name.service != srv_name->service) ||
-		    ((server->name.instance & lookup_mask) !=
-			srv_name->instance))
-			continue;
+	for (key = 0; key < SRV_HASH_SIZE; key++) {
+		list_for_each_entry(server, &server_list[key], list) {
+			if ((server->name.service != srv_name->service) ||
+			    ((server->name.instance & lookup_mask) !=
+				srv_name->instance))
+				continue;
 
-		list_for_each_entry(server_port,
-			&server->server_port_list, list) {
-			if (i < num_entries_in_array) {
-				srv_info[i].node_id =
+			list_for_each_entry(server_port,
+				&server->server_port_list, list) {
+				if (i < num_entries_in_array) {
+					srv_info[i].node_id =
 					  server_port->server_addr.node_id;
-				srv_info[i].port_id =
+					srv_info[i].port_id =
 					  server_port->server_addr.port_id;
-				srv_info[i].service = server->name.service;
-				srv_info[i].instance = server->name.instance;
+					srv_info[i].service =
+					  server->name.service;
+					srv_info[i].instance =
+					  server->name.instance;
+				}
+				i++;
 			}
-			i++;
 		}
 	}
-	up_read(&server_list_lock_lha2);
+	mutex_unlock(&server_list_lock);
 
 	return i;
 }
@@ -2946,14 +2073,14 @@
 {
 	struct msm_ipc_router_xprt_info *xprt_info, *tmp_xprt_info;
 
-	down_write(&xprt_info_list_lock_lha5);
+	mutex_lock(&xprt_info_list_lock);
 	list_for_each_entry_safe(xprt_info, tmp_xprt_info,
 				 &xprt_info_list, list) {
 		xprt_info->xprt->close(xprt_info->xprt);
 		list_del(&xprt_info->list);
 		kfree(xprt_info);
 	}
-	up_write(&xprt_info_list_lock_lha5);
+	mutex_unlock(&xprt_info_list_lock);
 	return 0;
 }
 
@@ -2964,12 +2091,12 @@
 	struct msm_ipc_routing_table_entry *rt_entry;
 
 	for (j = 0; j < RT_HASH_SIZE; j++) {
-		down_read(&routing_table_lock_lha3);
+		mutex_lock(&routing_table_lock);
 		list_for_each_entry(rt_entry, &routing_table[j], list) {
-			down_read(&rt_entry->lock_lha4);
+			mutex_lock(&rt_entry->lock);
 			i += scnprintf(buf + i, max - i,
 				       "Node Id: 0x%08x\n", rt_entry->node_id);
-			if (rt_entry->node_id == IPC_ROUTER_NID_LOCAL) {
+			if (j == IPC_ROUTER_NID_LOCAL) {
 				i += scnprintf(buf + i, max - i,
 				       "XPRT Name: Loopback\n");
 				i += scnprintf(buf + i, max - i,
@@ -2983,9 +2110,9 @@
 					rt_entry->xprt_info->remote_node_id);
 			}
 			i += scnprintf(buf + i, max - i, "\n");
-			up_read(&rt_entry->lock_lha4);
+			mutex_unlock(&rt_entry->lock);
 		}
-		up_read(&routing_table_lock_lha3);
+		mutex_unlock(&routing_table_lock);
 	}
 
 	return i;
@@ -2996,7 +2123,7 @@
 	int i = 0;
 	struct msm_ipc_router_xprt_info *xprt_info;
 
-	down_read(&xprt_info_list_lock_lha5);
+	mutex_lock(&xprt_info_list_lock);
 	list_for_each_entry(xprt_info, &xprt_info_list, list) {
 		i += scnprintf(buf + i, max - i, "XPRT Name: %s\n",
 			       xprt_info->xprt->name);
@@ -3008,7 +2135,7 @@
 			       xprt_info->remote_node_id);
 		i += scnprintf(buf + i, max - i, "\n");
 	}
-	up_read(&xprt_info_list_lock_lha5);
+	mutex_unlock(&xprt_info_list_lock);
 
 	return i;
 }
@@ -3019,7 +2146,7 @@
 	struct msm_ipc_server *server;
 	struct msm_ipc_server_port *server_port;
 
-	down_read(&server_list_lock_lha2);
+	mutex_lock(&server_list_lock);
 	for (j = 0; j < SRV_HASH_SIZE; j++) {
 		list_for_each_entry(server, &server_list[j], list) {
 			list_for_each_entry(server_port,
@@ -3039,7 +2166,7 @@
 			}
 		}
 	}
-	up_read(&server_list_lock_lha2);
+	mutex_unlock(&server_list_lock);
 
 	return i;
 }
@@ -3051,9 +2178,9 @@
 	struct msm_ipc_routing_table_entry *rt_entry;
 
 	for (j = 0; j < RT_HASH_SIZE; j++) {
-		down_read(&routing_table_lock_lha3);
+		mutex_lock(&routing_table_lock);
 		list_for_each_entry(rt_entry, &routing_table[j], list) {
-			down_read(&rt_entry->lock_lha4);
+			mutex_lock(&rt_entry->lock);
 			for (k = 0; k < RP_HASH_SIZE; k++) {
 				list_for_each_entry(rport_ptr,
 					&rt_entry->remote_port_list[k],
@@ -3070,9 +2197,9 @@
 				i += scnprintf(buf + i, max - i, "\n");
 				}
 			}
-			up_read(&rt_entry->lock_lha4);
+			mutex_unlock(&rt_entry->lock);
 		}
-		up_read(&routing_table_lock_lha3);
+		mutex_unlock(&routing_table_lock);
 	}
 
 	return i;
@@ -3083,7 +2210,7 @@
 	int i = 0;
 	struct msm_ipc_port *port_ptr;
 
-	down_read(&control_ports_lock_lha5);
+	mutex_lock(&control_ports_lock);
 	list_for_each_entry(port_ptr, &control_ports, list) {
 		i += scnprintf(buf + i, max - i, "Node_id: 0x%08x\n",
 			       port_ptr->this_port.node_id);
@@ -3091,7 +2218,7 @@
 			       port_ptr->this_port.port_id);
 		i += scnprintf(buf + i, max - i, "\n");
 	}
-	up_read(&control_ports_lock_lha5);
+	mutex_unlock(&control_ports_lock);
 
 	return i;
 }
@@ -3102,7 +2229,7 @@
 	unsigned long flags;
 	struct msm_ipc_port *port_ptr;
 
-	down_read(&local_ports_lock_lha2);
+	mutex_lock(&local_ports_lock);
 	for (j = 0; j < LP_HASH_SIZE; j++) {
 		list_for_each_entry(port_ptr, &local_ports[j], list) {
 			spin_lock_irqsave(&port_ptr->port_lock, flags);
@@ -3122,7 +2249,7 @@
 			i += scnprintf(buf + i, max - i, "\n");
 		}
 	}
-	up_read(&local_ports_lock_lha2);
+	mutex_unlock(&local_ports_lock);
 
 	return i;
 }
@@ -3196,8 +2323,8 @@
 	xprt_info->initialized = 0;
 	xprt_info->remote_node_id = -1;
 	INIT_LIST_HEAD(&xprt_info->pkt_list);
-	mutex_init(&xprt_info->rx_lock_lhb2);
-	mutex_init(&xprt_info->tx_lock_lhb2);
+	mutex_init(&xprt_info->rx_lock);
+	mutex_init(&xprt_info->tx_lock);
 	wake_lock_init(&xprt_info->wakelock,
 			WAKE_LOCK_SUSPEND, xprt->name);
 	xprt_info->need_len = 0;
@@ -3216,18 +2343,18 @@
 		xprt_info->initialized = 1;
 	}
 
-	down_write(&xprt_info_list_lock_lha5);
+	mutex_lock(&xprt_info_list_lock);
 	list_add_tail(&xprt_info->list, &xprt_info_list);
-	up_write(&xprt_info_list_lock_lha5);
+	mutex_unlock(&xprt_info_list_lock);
 
-	down_write(&routing_table_lock_lha3);
+	mutex_lock(&routing_table_lock);
 	if (!routing_table_inited) {
 		init_routing_table();
 		rt_entry = alloc_routing_table_entry(IPC_ROUTER_NID_LOCAL);
 		add_routing_table_entry(rt_entry);
 		routing_table_inited = 1;
 	}
-	up_write(&routing_table_lock_lha3);
+	mutex_unlock(&routing_table_lock);
 
 	xprt->priv = xprt_info;
 
@@ -3241,13 +2368,13 @@
 	if (xprt && xprt->priv) {
 		xprt_info = xprt->priv;
 
-		mutex_lock(&xprt_info->rx_lock_lhb2);
+		mutex_lock(&xprt_info->rx_lock);
 		xprt_info->abort_data_read = 1;
-		mutex_unlock(&xprt_info->rx_lock_lhb2);
+		mutex_unlock(&xprt_info->rx_lock);
 
-		down_write(&xprt_info_list_lock_lha5);
+		mutex_lock(&xprt_info_list_lock);
 		list_del(&xprt_info->list);
-		up_write(&xprt_info_list_lock_lha5);
+		mutex_unlock(&xprt_info_list_lock);
 
 		flush_workqueue(xprt_info->workqueue);
 		destroy_workqueue(xprt_info->workqueue);
@@ -3278,9 +2405,12 @@
 	struct msm_ipc_router_xprt_work *xprt_work =
 		container_of(work, struct msm_ipc_router_xprt_work, work);
 
-	msm_ipc_cleanup_routing_table(xprt_work->xprt->priv);
+	modem_reset_cleanup(xprt_work->xprt->priv);
 	msm_ipc_router_remove_xprt(xprt_work->xprt);
-	xprt_work->xprt->sft_close_done(xprt_work->xprt);
+
+	if (atomic_dec_return(&pending_close_count) == 0)
+		wake_up(&subsystem_restart_wait);
+
 	kfree(xprt_work);
 }
 
@@ -3307,28 +2437,19 @@
 		D("open event for '%s'\n", xprt->name);
 		xprt_work = kmalloc(sizeof(struct msm_ipc_router_xprt_work),
 				GFP_ATOMIC);
-		if (xprt_work) {
-			xprt_work->xprt = xprt;
-			INIT_WORK(&xprt_work->work, xprt_open_worker);
-			queue_work(msm_ipc_router_workqueue, &xprt_work->work);
-		} else {
-			pr_err("%s: malloc failure - Couldn't notify OPEN event",
-				__func__);
-		}
+		xprt_work->xprt = xprt;
+		INIT_WORK(&xprt_work->work, xprt_open_worker);
+		queue_work(msm_ipc_router_workqueue, &xprt_work->work);
 		break;
 
 	case IPC_ROUTER_XPRT_EVENT_CLOSE:
 		D("close event for '%s'\n", xprt->name);
+		atomic_inc(&pending_close_count);
 		xprt_work = kmalloc(sizeof(struct msm_ipc_router_xprt_work),
 				GFP_ATOMIC);
-		if (xprt_work) {
-			xprt_work->xprt = xprt;
-			INIT_WORK(&xprt_work->work, xprt_close_worker);
-			queue_work(msm_ipc_router_workqueue, &xprt_work->work);
-		} else {
-			pr_err("%s: malloc failure - Couldn't notify CLOSE event",
-				__func__);
-		}
+		xprt_work->xprt = xprt;
+		INIT_WORK(&xprt_work->work, xprt_close_worker);
+		queue_work(msm_ipc_router_workqueue, &xprt_work->work);
 		break;
 	}
 
@@ -3344,25 +2465,58 @@
 	if (!pkt)
 		return;
 
-	mutex_lock(&xprt_info->rx_lock_lhb2);
+	mutex_lock(&xprt_info->rx_lock);
 	list_add_tail(&pkt->list, &xprt_info->pkt_list);
 	wake_lock(&xprt_info->wakelock);
-	mutex_unlock(&xprt_info->rx_lock_lhb2);
+	mutex_unlock(&xprt_info->rx_lock);
 	queue_work(xprt_info->workqueue, &xprt_info->read_data);
 }
 
+static int modem_restart_notifier_cb(struct notifier_block *this,
+				unsigned long code,
+				void *data);
+static struct notifier_block msm_ipc_router_nb = {
+	.notifier_call = modem_restart_notifier_cb,
+};
+
+static int modem_restart_notifier_cb(struct notifier_block *this,
+				unsigned long code,
+				void *data)
+{
+	switch (code) {
+	case SUBSYS_BEFORE_SHUTDOWN:
+		D("%s: SUBSYS_BEFORE_SHUTDOWN\n", __func__);
+		break;
+
+	case SUBSYS_BEFORE_POWERUP:
+		D("%s: waiting for RPC restart to complete\n", __func__);
+		wait_event(subsystem_restart_wait,
+			atomic_read(&pending_close_count) == 0);
+		D("%s: finished restart wait\n", __func__);
+		break;
+
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static void *restart_notifier_handle;
+static __init int msm_ipc_router_modem_restart_late_init(void)
+{
+	restart_notifier_handle = subsys_notif_register_notifier("modem",
+							&msm_ipc_router_nb);
+	return 0;
+}
+late_initcall(msm_ipc_router_modem_restart_late_init);
+
 static int __init msm_ipc_router_init(void)
 {
 	int i, ret;
 	struct msm_ipc_routing_table_entry *rt_entry;
 
 	msm_ipc_router_debug_mask |= SMEM_LOG;
-	ipc_rtr_log_ctxt = ipc_log_context_create(IPC_RTR_LOG_PAGES,
-						  "ipc_router");
-	if (!ipc_rtr_log_ctxt)
-		pr_err("%s: Unable to create IPC logging for IPC RTR",
-			__func__);
-
 	msm_ipc_router_workqueue =
 		create_singlethread_workqueue("msm_ipc_router");
 	if (!msm_ipc_router_workqueue)
@@ -3376,23 +2530,21 @@
 	for (i = 0; i < LP_HASH_SIZE; i++)
 		INIT_LIST_HEAD(&local_ports[i]);
 
-	down_write(&routing_table_lock_lha3);
+	mutex_lock(&routing_table_lock);
 	if (!routing_table_inited) {
 		init_routing_table();
 		rt_entry = alloc_routing_table_entry(IPC_ROUTER_NID_LOCAL);
 		add_routing_table_entry(rt_entry);
 		routing_table_inited = 1;
 	}
-	up_write(&routing_table_lock_lha3);
+	mutex_unlock(&routing_table_lock);
 
+	init_waitqueue_head(&newserver_wait);
+	init_waitqueue_head(&subsystem_restart_wait);
 	ret = msm_ipc_router_init_sockets();
 	if (ret < 0)
 		pr_err("%s: Init sockets failed\n", __func__);
 
-	ret = msm_ipc_router_security_init();
-	if (ret < 0)
-		pr_err("%s: Security Init failed\n", __func__);
-
 	complete_all(&msm_ipc_local_router_up);
 	return ret;
 }
diff --unified -r mach-msm/ipc_router.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_router.h
--- mach-msm/ipc_router.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_router.h	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -18,23 +18,22 @@
 #include <linux/errno.h>
 #include <linux/mm.h>
 #include <linux/list.h>
+#include <linux/cdev.h>
 #include <linux/platform_device.h>
+#include <linux/wakelock.h>
 #include <linux/msm_ipc.h>
 
 #include <net/sock.h>
 
 /* definitions for the R2R wire protcol */
-#define IPC_ROUTER_V1		1
-/*
- * Ambiguous definition but will enable multiplexing IPC_ROUTER_V2 packets
- * with an existing alternate transport in user-space, if needed.
- */
-#define IPC_ROUTER_V2		3
+#define IPC_ROUTER_VERSION			1
+#define IPC_ROUTER_PROCESSORS_MAX		4
 
-#define IPC_ROUTER_ADDRESS			0x0000FFFF
+#define IPC_ROUTER_CLIENT_BCAST_ID		0xffffffff
+#define IPC_ROUTER_ADDRESS			0xfffffffe
 
 #define IPC_ROUTER_NID_LOCAL			1
-#define MAX_IPC_PKT_SIZE 66000
+#define IPC_ROUTER_NID_REMOTE			0
 
 #define IPC_ROUTER_CTRL_CMD_DATA		1
 #define IPC_ROUTER_CTRL_CMD_HELLO		2
@@ -52,48 +51,22 @@
 #define IPC_ROUTER_XPRT_EVENT_OPEN  2
 #define IPC_ROUTER_XPRT_EVENT_CLOSE 3
 
+#define NUM_NODES 2
+
 #define IPC_ROUTER_INFINITY -1
-#define DEFAULT_RCV_TIMEO 0
+#define DEFAULT_RCV_TIMEO IPC_ROUTER_INFINITY
 
 #define ALIGN_SIZE(x) ((4 - ((x) & 3)) & 3)
 
-#define ALL_SERVICE 0xFFFFFFFF
-#define ALL_INSTANCE 0xFFFFFFFF
-
-#define CONTROL_FLAG_CONFIRM_RX 0x1
-#define CONTROL_FLAG_OPT_HDR 0x2
-
-#define FRAG_PKT_WRITE_ENABLE 0x1
-
-enum {
-	CLIENT_PORT,
-	SERVER_PORT,
-	CONTROL_PORT,
-	IRSC_PORT,
-};
-
 enum {
-	NULL_MODE,
-	SINGLE_LINK_MODE,
-	MULTI_LINK_MODE,
+	MSM_IPC_ROUTER_READ_CB = 0,
+	MSM_IPC_ROUTER_WRITE_DONE,
 };
 
-/**
- * rr_control_msg - Control message structure
- * @cmd: Command identifier for HELLO message in Version 1.
- * @hello: Message structure for HELLO message in Version 2.
- * @srv: Message structure for NEW_SERVER/REMOVE_SERVER events.
- * @cli: Message structure for REMOVE_CLIENT event.
- */
 union rr_control_msg {
 	uint32_t cmd;
 	struct {
 		uint32_t cmd;
-		uint32_t magic;
-		uint32_t capability;
-	} hello;
-	struct {
-		uint32_t cmd;
 		uint32_t service;
 		uint32_t instance;
 		uint32_t node_id;
@@ -106,99 +79,79 @@
 	} cli;
 };
 
-/**
- * rr_header_v1 - IPC Router header version 1
- * @version: Version information.
- * @type: IPC Router Message Type.
- * @src_node_id: Source Node ID of the message.
- * @src_port_id: Source Port ID of the message.
- * @control_flag: Flag to indicate flow control.
- * @size: Size of the IPC Router payload.
- * @dst_node_id: Destination Node ID of the message.
- * @dst_port_id: Destination Port ID of the message.
- */
-struct rr_header_v1 {
+struct rr_header {
 	uint32_t version;
 	uint32_t type;
 	uint32_t src_node_id;
 	uint32_t src_port_id;
-	uint32_t control_flag;
+	uint32_t confirm_rx;
 	uint32_t size;
 	uint32_t dst_node_id;
 	uint32_t dst_port_id;
 };
 
-/**
- * rr_header_v2 - IPC Router header version 2
- * @version: Version information.
- * @type: IPC Router Message Type.
- * @control_flag: Flags to indicate flow control, optional header etc.
- * @size: Size of the IPC Router payload.
- * @src_node_id: Source Node ID of the message.
- * @src_port_id: Source Port ID of the message.
- * @dst_node_id: Destination Node ID of the message.
- * @dst_port_id: Destination Port ID of the message.
- */
-struct rr_header_v2 {
-	uint8_t version;
-	uint8_t type;
-	uint16_t control_flag;
-	uint32_t size;
-	uint16_t src_node_id;
-	uint16_t src_port_id;
-	uint16_t dst_node_id;
-	uint16_t dst_port_id;
-} __attribute__((__packed__));
-
-union rr_header {
-	struct rr_header_v1 hdr_v1;
-	struct rr_header_v2 hdr_v2;
-};
+#define IPC_ROUTER_HDR_SIZE sizeof(struct rr_header)
+#define MAX_IPC_PKT_SIZE 66000
+/* internals */
 
-#define IPC_ROUTER_HDR_SIZE sizeof(union rr_header)
+#define IPC_ROUTER_MAX_REMOTE_SERVERS		100
+#define MAX_WAKELOCK_NAME_SZ 32
 
-/**
- * rr_packet - Router to Router packet structure
- * @list: Pointer to prev & next packets in a port's rx list.
- * @hdr: Header information extracted from or prepended to a packet.
- * @pkt_fragment_q: Queue of SKBs containing payload.
- * @length: Length of data in the chain of SKBs
- */
 struct rr_packet {
 	struct list_head list;
-	struct rr_header_v1 hdr;
 	struct sk_buff_head *pkt_fragment_q;
 	uint32_t length;
 };
 
+struct msm_ipc_port {
+	struct list_head list;
+
+	struct msm_ipc_port_addr this_port;
+	struct msm_ipc_port_name port_name;
+	uint32_t type;
+	unsigned flags;
+	spinlock_t port_lock;
+
+	struct list_head incomplete;
+	struct mutex incomplete_lock;
+
+	struct list_head port_rx_q;
+	struct mutex port_rx_q_lock;
+	char rx_wakelock_name[MAX_WAKELOCK_NAME_SZ];
+	struct wake_lock port_rx_wake_lock;
+	wait_queue_head_t port_rx_wait_q;
+
+	int restart_state;
+	spinlock_t restart_lock;
+	wait_queue_head_t restart_wait;
+
+	void *endpoint;
+	void (*notify)(unsigned event, void *data, void *addr, void *priv);
+
+	uint32_t num_tx;
+	uint32_t num_rx;
+	unsigned long num_tx_bytes;
+	unsigned long num_rx_bytes;
+	void *priv;
+};
+
 struct msm_ipc_sock {
 	struct sock sk;
 	struct msm_ipc_port *port;
 	void *default_pil;
 };
 
-/**
- * msm_ipc_router_xprt - Structure to hold XPRT specific information
- * @name: Name of the XPRT.
- * @link_id: Network cluster ID to which the XPRT belongs to.
- * @priv: XPRT's private data.
- * @get_version: Method to get header version supported by the XPRT.
- * @get_option: Method to get XPRT specific options.
- * @read_avail: Method to get data size available to be read from the XPRT.
- * @read: Method to read data from the XPRT.
- * @write_avail: Method to get write space available in the XPRT.
- * @write: Method to write data to the XPRT.
- * @close: Method to close the XPRT.
- * @sft_close_done: Method to indicate to the XPRT that handling of reset
- *                  event is complete.
- */
+enum write_data_type {
+	HEADER = 1,
+	PACKMARK,
+	PAYLOAD,
+};
+
 struct msm_ipc_router_xprt {
 	char *name;
 	uint32_t link_id;
 	void *priv;
 
-	int (*get_version)(struct msm_ipc_router_xprt *xprt);
-	int (*get_option)(struct msm_ipc_router_xprt *xprt);
 	int (*read_avail)(struct msm_ipc_router_xprt *xprt);
 	int (*read)(void *data, uint32_t len,
 		    struct msm_ipc_router_xprt *xprt);
@@ -206,9 +159,10 @@
 	int (*write)(void *data, uint32_t len,
 		     struct msm_ipc_router_xprt *xprt);
 	int (*close)(struct msm_ipc_router_xprt *xprt);
-	void (*sft_close_done)(struct msm_ipc_router_xprt *xprt);
 };
 
+extern struct completion msm_ipc_remote_router_up;
+
 void msm_ipc_router_xprt_notify(struct msm_ipc_router_xprt *xprt,
 				unsigned event,
 				void *data);
@@ -219,33 +173,39 @@
 
 
 struct msm_ipc_port *msm_ipc_router_create_raw_port(void *endpoint,
-		void (*notify)(unsigned event, void *priv),
+		void (*notify)(unsigned event, void *data,
+			       void *addr, void *priv),
 		void *priv);
 int msm_ipc_router_send_to(struct msm_ipc_port *src,
 			   struct sk_buff_head *data,
 			   struct msm_ipc_addr *dest);
 int msm_ipc_router_read(struct msm_ipc_port *port_ptr,
-			struct rr_packet **pkt,
+			struct sk_buff_head **data,
 			size_t buf_len);
+int msm_ipc_router_get_curr_pkt_size(struct msm_ipc_port *port_ptr);
 int msm_ipc_router_bind_control_port(struct msm_ipc_port *port_ptr);
-
+int msm_ipc_router_lookup_server_name(struct msm_ipc_port_name *srv_name,
+				      struct msm_ipc_server_info *srv_info,
+				      int num_entries_in_array,
+				      uint32_t lookup_mask);
+int msm_ipc_router_close_port(struct msm_ipc_port *port_ptr);
+
+struct msm_ipc_port *msm_ipc_router_create_port(
+	void (*notify)(unsigned event, void *data,
+		       void *addr, void *priv),
+	void *priv);
 int msm_ipc_router_recv_from(struct msm_ipc_port *port_ptr,
-		      struct rr_packet **pkt,
+		      struct sk_buff_head **data,
 		      struct msm_ipc_addr *src_addr,
-		      long timeout);
+		      unsigned long timeout);
 int msm_ipc_router_register_server(struct msm_ipc_port *server_port,
 			    struct msm_ipc_addr *name);
 int msm_ipc_router_unregister_server(struct msm_ipc_port *server_port);
 
+
 int msm_ipc_router_init_sockets(void);
 void msm_ipc_router_exit_sockets(void);
 
-void msm_ipc_sync_sec_rule(uint32_t service, uint32_t instance, void *rule);
-
-void msm_ipc_sync_default_sec_rule(void *rule);
-
-int msm_ipc_router_rx_data_wait(struct msm_ipc_port *port_ptr, long timeout);
-
 #if defined CONFIG_MSM_IPC_ROUTER_SMD_XPRT
 extern void *msm_ipc_load_default_node(void);
 
@@ -257,5 +217,4 @@
 static inline void msm_ipc_unload_default_node(void *pil) { }
 #endif
 
-void msm_ipc_router_free_skb(struct sk_buff_head *skb_head);
 #endif
Only in mach-msm: ipc_router_hsic_xprt.c
diff --unified -r mach-msm/ipc_router_smd_xprt.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_router_smd_xprt.c
--- mach-msm/ipc_router_smd_xprt.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_router_smd_xprt.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -40,7 +40,7 @@
 
 #define MIN_FRAG_SZ (IPC_ROUTER_HDR_SIZE + sizeof(union rr_control_msg))
 
-#define NUM_SMD_XPRTS 4
+#define NUM_SMD_XPRTS 3
 #define XPRT_NAME_LEN (SMD_MAX_CH_NAME_LEN + 12)
 
 struct msm_ipc_router_smd_xprt {
@@ -54,9 +54,6 @@
 	spinlock_t ss_reset_lock;	/*Subsystem reset lock*/
 	int ss_reset;
 	void *pil;
-	struct completion sft_close_complete;
-	unsigned xprt_version;
-	unsigned xprt_option;
 };
 
 struct msm_ipc_router_smd_xprt_work {
@@ -73,14 +70,12 @@
 	char xprt_name[XPRT_NAME_LEN];
 	uint32_t edge;
 	uint32_t link_id;
-	unsigned xprt_version;
 };
 
 struct msm_ipc_router_smd_xprt_config smd_xprt_cfg[] = {
-	{"RPCRPY_CNTL", "ipc_rtr_smd_rpcrpy_cntl", SMD_APPS_MODEM, 1, 1},
-	{"IPCRTR", "ipc_rtr_smd_ipcrtr", SMD_APPS_MODEM, 1, 1},
-	{"IPCRTR", "ipc_rtr_q6_ipcrtr", SMD_APPS_QDSP, 1, 1},
-	{"IPCRTR", "ipc_rtr_wcnss_ipcrtr", SMD_APPS_WCNSS, 1, 1},
+	{"RPCRPY_CNTL", "ipc_rtr_smd_rpcrpy_cntl", SMD_APPS_MODEM, 1},
+	{"IPCRTR", "ipc_rtr_smd_ipcrtr", SMD_APPS_MODEM, 1},
+	{"IPCRTR", "ipc_rtr_q6_ipcrtr", SMD_APPS_QDSP, 1},
 };
 
 static struct msm_ipc_router_smd_xprt smd_remote_xprt[NUM_SMD_XPRTS];
@@ -98,28 +93,6 @@
 	return -ENODEV;
 }
 
-static int msm_ipc_router_smd_get_xprt_version(
-	struct msm_ipc_router_xprt *xprt)
-{
-	struct msm_ipc_router_smd_xprt *smd_xprtp;
-	if (!xprt)
-		return -EINVAL;
-	smd_xprtp = container_of(xprt, struct msm_ipc_router_smd_xprt, xprt);
-
-	return (int)smd_xprtp->xprt_version;
-}
-
-static int msm_ipc_router_smd_get_xprt_option(
-	struct msm_ipc_router_xprt *xprt)
-{
-	struct msm_ipc_router_smd_xprt *smd_xprtp;
-	if (!xprt)
-		return -EINVAL;
-	smd_xprtp = container_of(xprt, struct msm_ipc_router_smd_xprt, xprt);
-
-	return (int)smd_xprtp->xprt_option;
-}
-
 static int msm_ipc_router_smd_remote_write_avail(
 	struct msm_ipc_router_xprt *xprt)
 {
@@ -135,6 +108,7 @@
 {
 	struct rr_packet *pkt = (struct rr_packet *)data;
 	struct sk_buff *ipc_rtr_pkt;
+	int align_sz, align_data = 0;
 	int offset, sz_written = 0;
 	int ret, num_retries = 0;
 	unsigned long flags;
@@ -147,7 +121,9 @@
 	if (!len || pkt->length != len)
 		return -EINVAL;
 
-	while ((ret = smd_write_start(smd_xprtp->channel, len)) < 0) {
+	align_sz = ALIGN_SIZE(pkt->length);
+	while ((ret = smd_write_start(smd_xprtp->channel,
+				      (len + align_sz))) < 0) {
 		spin_lock_irqsave(&smd_xprtp->ss_reset_lock, flags);
 		if (smd_xprtp->ss_reset) {
 			spin_unlock_irqrestore(&smd_xprtp->ss_reset_lock,
@@ -165,7 +141,7 @@
 		num_retries++;
 	}
 
-	D("%s: Ready to write %d bytes\n", __func__, len);
+	D("%s: Ready to write\n", __func__);
 	skb_queue_walk(pkt->pkt_fragment_q, ipc_rtr_pkt) {
 		offset = 0;
 		while (offset < ipc_rtr_pkt->len) {
@@ -197,6 +173,30 @@
 		  __func__, offset, xprt->name);
 	}
 
+	if (align_sz) {
+		if (smd_write_avail(smd_xprtp->channel) < align_sz)
+			smd_enable_read_intr(smd_xprtp->channel);
+
+		wait_event(smd_xprtp->write_avail_wait_q,
+			((smd_write_avail(smd_xprtp->channel) >=
+			 align_sz) || smd_xprtp->ss_reset));
+		smd_disable_read_intr(smd_xprtp->channel);
+		spin_lock_irqsave(&smd_xprtp->ss_reset_lock, flags);
+		if (smd_xprtp->ss_reset) {
+			spin_unlock_irqrestore(
+				&smd_xprtp->ss_reset_lock, flags);
+			pr_err("%s: %s chnl reset\n",
+				__func__, xprt->name);
+			return -ENETRESET;
+		}
+		spin_unlock_irqrestore(&smd_xprtp->ss_reset_lock,
+					flags);
+
+		smd_write_segment(smd_xprtp->channel,
+				  &align_data, align_sz, 0);
+		D("%s: Wrote %d align bytes over %s\n",
+		  __func__, align_sz, xprt->name);
+	}
 	if (!smd_write_end(smd_xprtp->channel))
 		D("%s: Finished writing\n", __func__);
 	return len;
@@ -216,14 +216,6 @@
 	return rc;
 }
 
-static void smd_xprt_sft_close_done(struct msm_ipc_router_xprt *xprt)
-{
-	struct msm_ipc_router_smd_xprt *smd_xprtp =
-		container_of(xprt, struct msm_ipc_router_smd_xprt, xprt);
-
-	complete_all(&smd_xprtp->sft_close_complete);
-}
-
 static void smd_xprt_read_data(struct work_struct *work)
 {
 	int pkt_size, sz_read, sz;
@@ -329,14 +321,7 @@
 {
 	struct msm_ipc_router_smd_xprt_work *xprt_work =
 		container_of(work, struct msm_ipc_router_smd_xprt_work, work);
-	struct msm_ipc_router_smd_xprt *smd_xprtp =
-		container_of(xprt_work->xprt,
-			     struct msm_ipc_router_smd_xprt, xprt);
-	unsigned long flags;
 
-	spin_lock_irqsave(&smd_xprtp->ss_reset_lock, flags);
-	smd_xprtp->ss_reset = 0;
-	spin_unlock_irqrestore(&smd_xprtp->ss_reset_lock, flags);
 	msm_ipc_router_xprt_notify(xprt_work->xprt,
 				IPC_ROUTER_XPRT_EVENT_OPEN, NULL);
 	D("%s: Notified IPC Router of %s OPEN\n",
@@ -348,16 +333,11 @@
 {
 	struct msm_ipc_router_smd_xprt_work *xprt_work =
 		container_of(work, struct msm_ipc_router_smd_xprt_work, work);
-	struct msm_ipc_router_smd_xprt *smd_xprtp =
-		container_of(xprt_work->xprt,
-			     struct msm_ipc_router_smd_xprt, xprt);
 
-	init_completion(&smd_xprtp->sft_close_complete);
 	msm_ipc_router_xprt_notify(xprt_work->xprt,
 				IPC_ROUTER_XPRT_EVENT_CLOSE, NULL);
 	D("%s: Notified IPC Router of %s CLOSE\n",
 	   __func__, xprt_work->xprt->name);
-	wait_for_completion(&smd_xprtp->sft_close_complete);
 	kfree(xprt_work);
 }
 
@@ -381,6 +361,9 @@
 		break;
 
 	case SMD_EVENT_OPEN:
+		spin_lock_irqsave(&smd_xprtp->ss_reset_lock, flags);
+		smd_xprtp->ss_reset = 0;
+		spin_unlock_irqrestore(&smd_xprtp->ss_reset_lock, flags);
 		xprt_work = kmalloc(sizeof(struct msm_ipc_router_smd_xprt_work),
 				    GFP_ATOMIC);
 		if (!xprt_work) {
@@ -451,17 +434,12 @@
 
 	smd_remote_xprt[id].xprt.name = smd_xprt_cfg[id].xprt_name;
 	smd_remote_xprt[id].xprt.link_id = smd_xprt_cfg[id].link_id;
-	smd_remote_xprt[id].xprt.get_version =
-		msm_ipc_router_smd_get_xprt_version;
-	smd_remote_xprt[id].xprt.get_option =
-		msm_ipc_router_smd_get_xprt_option;
 	smd_remote_xprt[id].xprt.read_avail = NULL;
 	smd_remote_xprt[id].xprt.read = NULL;
 	smd_remote_xprt[id].xprt.write_avail =
 		msm_ipc_router_smd_remote_write_avail;
 	smd_remote_xprt[id].xprt.write = msm_ipc_router_smd_remote_write;
 	smd_remote_xprt[id].xprt.close = msm_ipc_router_smd_remote_close;
-	smd_remote_xprt[id].xprt.sft_close_done = smd_xprt_sft_close_done;
 	smd_remote_xprt[id].xprt.priv = NULL;
 
 	init_waitqueue_head(&smd_remote_xprt[id].write_avail_wait_q);
@@ -470,8 +448,6 @@
 	INIT_DELAYED_WORK(&smd_remote_xprt[id].read_work, smd_xprt_read_data);
 	spin_lock_init(&smd_remote_xprt[id].ss_reset_lock);
 	smd_remote_xprt[id].ss_reset = 0;
-	smd_remote_xprt[id].xprt_version = smd_xprt_cfg[id].xprt_version;
-	smd_remote_xprt[id].xprt_option = FRAG_PKT_WRITE_ENABLE;
 
 	smd_remote_xprt[id].pil = msm_ipc_load_subsystem(
 					smd_xprt_cfg[id].edge);
diff --unified -r mach-msm/ipc_socket.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_socket.c
--- mach-msm/ipc_socket.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/ipc_socket.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -20,107 +20,40 @@
 #include <linux/fcntl.h>
 #include <linux/gfp.h>
 #include <linux/msm_ipc.h>
-#include <linux/sched.h>
-#include <linux/thread_info.h>
-#include <linux/qmi_encdec.h>
+#include <linux/ratelimit.h>
+
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
 
 #include <asm/string.h>
 #include <asm/atomic.h>
 
 #include <net/sock.h>
 
-#include <mach/msm_ipc_router.h>
-#include <mach/msm_ipc_logging.h>
-
 #include "ipc_router.h"
-#include "msm_ipc_router_security.h"
 
 #define msm_ipc_sk(sk) ((struct msm_ipc_sock *)(sk))
 #define msm_ipc_sk_port(sk) ((struct msm_ipc_port *)(msm_ipc_sk(sk)->port))
-#define REQ_RESP_IPC_LOG_PAGES 5
-#define IND_IPC_LOG_PAGES 5
-#define IPC_SEND 1
-#define IPC_RECV 2
-#define IPC_REQ_RESP_LOG(level, buf...) \
-do { \
-	if (ipc_req_resp_log_txt) { \
-		ipc_log_string(ipc_req_resp_log_txt, buf); \
-	} \
-} while (0) \
-
-#define IPC_IND_LOG(level, buf...) \
-do { \
-	if (ipc_ind_log_txt) { \
-		ipc_log_string(ipc_ind_log_txt, buf); \
-	} \
-} while (0) \
-
-#ifndef SIZE_MAX
-#define SIZE_MAX ((size_t)-1)
-#endif
 
 static int sockets_enabled;
 static struct proto msm_ipc_proto;
 static const struct proto_ops msm_ipc_proto_ops;
-static void *ipc_req_resp_log_txt;
-static void *ipc_ind_log_txt;
-
-/**
- * msm_ipc_router_ipc_log() - Pass log data to IPC logging framework
- * @tran:	Identifies the data to be a receive or send.
- * @ipc_buf:	Buffer to extract the log data.
- * @port_ptr:	IPC Router port corresponding to the current log data.
- *
- * This function builds the data the would be passed on to the IPC logging
- * framework. The data that would be passed corresponds to the information
- * that is exchanged between the IPC Router and user space modules during
- * request/response/indication transactions.
- */
 
-static void msm_ipc_router_ipc_log(uint8_t tran,
-			struct sk_buff *ipc_buf, struct msm_ipc_port *port_ptr)
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+static inline int check_permissions(void)
 {
-	struct qmi_header *hdr = (struct qmi_header *)ipc_buf->data;
-
-	/*
-	 * IPC Logging format is as below:-
-	 * <Name>(Name of the User Space Process):
-	 * <PID> (PID of the user space process) :
-	 * <TID> (TID of the user space thread)  :
-	 * <User Space Module>(CLNT or  SERV)    :
-	 * <Opertaion Type> (Transmit)		 :
-	 * <Control Flag> (Req/Resp/Ind)	 :
-	 * <Transaction ID>			 :
-	 * <Message ID>				 :
-	 * <Message Length>			 :
-	 */
-	if (ipc_req_resp_log_txt &&
-		(((uint8_t) hdr->cntl_flag == QMI_REQUEST_CONTROL_FLAG) ||
-		((uint8_t) hdr->cntl_flag == QMI_RESPONSE_CONTROL_FLAG)) &&
-		(port_ptr->type == CLIENT_PORT ||
-					port_ptr->type == SERVER_PORT)) {
-		IPC_REQ_RESP_LOG(KERN_DEBUG,
-			"%s %d %d %s %s CF:%x TI:%x MI:%x ML:%x",
-			current->comm, current->tgid, current->pid,
-			(port_ptr->type == CLIENT_PORT ? "QCCI" : "QCSI"),
-			(tran == IPC_RECV ? "RX" :
-			(tran == IPC_SEND ? "TX" : "ERR")),
-			(uint8_t)hdr->cntl_flag, hdr->txn_id, hdr->msg_id,
-			hdr->msg_len);
-	} else if (ipc_ind_log_txt &&
-		((uint8_t)hdr->cntl_flag == QMI_INDICATION_CONTROL_FLAG) &&
-		(port_ptr->type == CLIENT_PORT ||
-					port_ptr->type == SERVER_PORT)) {
-		IPC_IND_LOG(KERN_DEBUG,
-			"%s %d %d %s %s CF:%x TI:%x MI:%x ML:%x",
-			current->comm, current->tgid, current->pid,
-			(port_ptr->type == CLIENT_PORT ? "QCCI" : "QCSI"),
-			(tran == IPC_RECV ? "RX" :
-			(tran == IPC_SEND ? "TX" : "ERR")),
-			(uint8_t)hdr->cntl_flag, hdr->txn_id, hdr->msg_id,
-			hdr->msg_len);
-	}
+	int rc = 0;
+	if (!current_euid() || in_egroup_p(AID_NET_RAW))
+		rc = 1;
+	return rc;
+}
+# else
+static inline int check_permissions(void)
+{
+	return 1;
 }
+#endif
 
 static struct sk_buff_head *msm_ipc_router_build_msg(unsigned int num_sect,
 					  struct iovec const *msg_sect,
@@ -131,15 +64,12 @@
 	int i, copied, first = 1;
 	int data_size = 0, request_size, offset;
 	void *data;
-	int last = 0;
-	int align_size;
 
 	for (i = 0; i < num_sect; i++)
 		data_size += msg_sect[i].iov_len;
 
 	if (!data_size)
 		return NULL;
-	align_size = ALIGN_SIZE(data_size);
 
 	msg_head = kmalloc(sizeof(struct sk_buff_head), GFP_KERNEL);
 	if (!msg_head) {
@@ -151,14 +81,10 @@
 	for (copied = 1, i = 0; copied && (i < num_sect); i++) {
 		data_size = msg_sect[i].iov_len;
 		offset = 0;
-		if (i == (num_sect - 1))
-			last = 1;
 		while (offset != msg_sect[i].iov_len) {
 			request_size = data_size;
 			if (first)
 				request_size += IPC_ROUTER_HDR_SIZE;
-			if (last)
-				request_size += align_size;
 
 			msg = alloc_skb(request_size, GFP_KERNEL);
 			if (!msg) {
@@ -168,7 +94,6 @@
 					goto msg_build_failure;
 				}
 				data_size = data_size / 2;
-				last = 0;
 				continue;
 			}
 
@@ -190,8 +115,6 @@
 			skb_queue_tail(msg_head, msg);
 			offset += data_size;
 			data_size = msg_sect[i].iov_len - offset;
-			if (i == (num_sect - 1))
-				last = 1;
 		}
 	}
 	return msg_head;
@@ -206,32 +129,21 @@
 }
 
 static int msm_ipc_router_extract_msg(struct msghdr *m,
-				      struct rr_packet *pkt)
+				      struct sk_buff_head *msg_head)
 {
-	struct sockaddr_msm_ipc *addr;
-	struct rr_header_v1 *hdr;
+	struct sockaddr_msm_ipc *addr = (struct sockaddr_msm_ipc *)m->msg_name;
+	struct rr_header *hdr;
 	struct sk_buff *temp;
-	union rr_control_msg *ctl_msg;
 	int offset = 0, data_len = 0, copy_len;
 
-	if (!m || !pkt) {
+	if (!m || !msg_head) {
 		pr_err("%s: Invalid pointers passed\n", __func__);
 		return -EINVAL;
 	}
-	addr = (struct sockaddr_msm_ipc *)m->msg_name;
 
-	hdr = &(pkt->hdr);
-	if (addr && (hdr->type == IPC_ROUTER_CTRL_CMD_RESUME_TX)) {
-		temp = skb_peek(pkt->pkt_fragment_q);
-		ctl_msg = (union rr_control_msg *)(temp->data);
-		addr->family = AF_MSM_IPC;
-		addr->address.addrtype = MSM_IPC_ADDR_ID;
-		addr->address.addr.port_addr.node_id = ctl_msg->cli.node_id;
-		addr->address.addr.port_addr.port_id = ctl_msg->cli.port_id;
-		m->msg_namelen = sizeof(struct sockaddr_msm_ipc);
-		return offset;
-	}
-	if (addr && (hdr->type == IPC_ROUTER_CTRL_CMD_DATA)) {
+	temp = skb_peek(msg_head);
+	hdr = (struct rr_header *)(temp->data);
+	if (addr || (hdr->src_port_id != IPC_ROUTER_ADDRESS)) {
 		addr->family = AF_MSM_IPC;
 		addr->address.addrtype = MSM_IPC_ADDR_ID;
 		addr->address.addr.port_addr.node_id = hdr->src_node_id;
@@ -240,7 +152,8 @@
 	}
 
 	data_len = hdr->size;
-	skb_queue_walk(pkt->pkt_fragment_q, temp) {
+	skb_pull(temp, IPC_ROUTER_HDR_SIZE);
+	skb_queue_walk(msg_head, temp) {
 		copy_len = data_len < temp->len ? data_len : temp->len;
 		if (copy_to_user(m->msg_iov->iov_base + offset, temp->data,
 				 copy_len)) {
@@ -253,6 +166,22 @@
 	return offset;
 }
 
+static void msm_ipc_router_release_msg(struct sk_buff_head *msg_head)
+{
+	struct sk_buff *temp;
+
+	if (!msg_head) {
+		pr_err("%s: Invalid msg pointer\n", __func__);
+		return;
+	}
+
+	while (!skb_queue_empty(msg_head)) {
+		temp = skb_dequeue(msg_head);
+		kfree_skb(temp);
+	}
+	kfree(msg_head);
+}
+
 static int msm_ipc_router_create(struct net *net,
 				 struct socket *sock,
 				 int protocol,
@@ -260,6 +189,14 @@
 {
 	struct sock *sk;
 	struct msm_ipc_port *port_ptr;
+	void *pil;
+	static DEFINE_RATELIMIT_STATE(rl, 5*HZ, 1);
+
+	if (!check_permissions()) {
+		if (__ratelimit(&rl))
+			pr_err("%s: Do not have permissions\n", __func__);
+		return -EPERM;
+	}
 
 	if (unlikely(protocol != 0)) {
 		pr_err("%s: Protocol not supported\n", __func__);
@@ -287,12 +224,13 @@
 		return -ENOMEM;
 	}
 
-	port_ptr->check_send_permissions = msm_ipc_check_send_permissions;
 	sock->ops = &msm_ipc_proto_ops;
 	sock_init_data(sock, sk);
 	sk->sk_rcvtimeo = DEFAULT_RCV_TIMEO;
 
+	pil = msm_ipc_load_default_node();
 	msm_ipc_sk(sk)->port = port_ptr;
+	msm_ipc_sk(sk)->default_pil = pil;
 
 	return 0;
 }
@@ -304,17 +242,10 @@
 	struct sock *sk = sock->sk;
 	struct msm_ipc_port *port_ptr;
 	int ret;
-	void *pil;
 
 	if (!sk)
 		return -EINVAL;
 
-	if (!check_permissions()) {
-		pr_err("%s: %s Do not have permissions\n",
-			__func__, current->comm);
-		return -EPERM;
-	}
-
 	if (!uaddr_len) {
 		pr_err("%s: Invalid address length\n", __func__);
 		return -EINVAL;
@@ -334,8 +265,6 @@
 	if (!port_ptr)
 		return -ENODEV;
 
-	pil = msm_ipc_load_default_node();
-	msm_ipc_sk(sk)->default_pil = pil;
 	lock_sock(sk);
 
 	ret = msm_ipc_router_register_server(port_ptr, &addr->address);
@@ -351,7 +280,6 @@
 	struct msm_ipc_port *port_ptr = msm_ipc_sk_port(sk);
 	struct sockaddr_msm_ipc *dest = (struct sockaddr_msm_ipc *)m->msg_name;
 	struct sk_buff_head *msg;
-	struct sk_buff *ipc_buf;
 	int ret;
 
 	if (!dest)
@@ -371,22 +299,9 @@
 		goto out_sendmsg;
 	}
 
-	if (port_ptr->type == CLIENT_PORT)
-		wait_for_irsc_completion();
-	ipc_buf = skb_peek(msg);
-	if (ipc_buf)
-		msm_ipc_router_ipc_log(IPC_SEND, ipc_buf, port_ptr);
 	ret = msm_ipc_router_send_to(port_ptr, msg, &dest->address);
-	if (ret != total_len) {
-		if (ret < 0) {
-			if (ret != -EAGAIN)
-				pr_err("%s: Send_to failure %d\n",
-							__func__, ret);
-			msm_ipc_router_free_skb(msg);
-		} else if (ret >= 0) {
-			ret = -EFAULT;
-		}
-	}
+	if (ret == (IPC_ROUTER_HDR_SIZE + total_len))
+		ret = total_len;
 
 out_sendmsg:
 	release_sock(sk);
@@ -398,8 +313,7 @@
 {
 	struct sock *sk = sock->sk;
 	struct msm_ipc_port *port_ptr = msm_ipc_sk_port(sk);
-	struct rr_packet *pkt;
-	struct sk_buff *ipc_buf;
+	struct sk_buff_head *msg;
 	long timeout;
 	int ret;
 
@@ -411,26 +325,41 @@
 
 	lock_sock(sk);
 	timeout = sk->sk_rcvtimeo;
-
-	ret = msm_ipc_router_rx_data_wait(port_ptr, timeout);
-	if (ret) {
+	mutex_lock(&port_ptr->port_rx_q_lock);
+	while (list_empty(&port_ptr->port_rx_q)) {
+		mutex_unlock(&port_ptr->port_rx_q_lock);
 		release_sock(sk);
-		if (ret == -ENOMSG)
-			m->msg_namelen = 0;
-		return ret;
+		if (timeout < 0) {
+			ret = wait_event_interruptible(
+					port_ptr->port_rx_wait_q,
+					!list_empty(&port_ptr->port_rx_q));
+			if (ret)
+				return ret;
+		} else if (timeout > 0) {
+			timeout = wait_event_interruptible_timeout(
+					port_ptr->port_rx_wait_q,
+					!list_empty(&port_ptr->port_rx_q),
+					timeout);
+			if (timeout < 0)
+				return -EFAULT;
+		}
+
+		if (timeout == 0)
+			return -ETIMEDOUT;
+		lock_sock(sk);
+		mutex_lock(&port_ptr->port_rx_q_lock);
 	}
+	mutex_unlock(&port_ptr->port_rx_q_lock);
 
-	ret = msm_ipc_router_read(port_ptr, &pkt, buf_len);
-	if (ret <= 0 || !pkt) {
+	ret = msm_ipc_router_read(port_ptr, &msg, buf_len);
+	if (ret <= 0 || !msg) {
 		release_sock(sk);
 		return ret;
 	}
 
-	ret = msm_ipc_router_extract_msg(m, pkt);
-	ipc_buf = skb_peek(pkt->pkt_fragment_q);
-	if (ipc_buf)
-		msm_ipc_router_ipc_log(IPC_RECV, ipc_buf, port_ptr);
-	release_pkt(pkt);
+	ret = msm_ipc_router_extract_msg(m, msg);
+	msm_ipc_router_release_msg(msg);
+	msg = NULL;
 	release_sock(sk);
 	return ret;
 }
@@ -442,10 +371,8 @@
 	struct msm_ipc_port *port_ptr;
 	struct server_lookup_args server_arg;
 	struct msm_ipc_server_info *srv_info = NULL;
-	unsigned int n;
-	size_t srv_info_sz = 0;
+	unsigned int n, srv_info_sz = 0;
 	int ret;
-	void *pil;
 
 	if (!sk)
 		return -EINVAL;
@@ -459,7 +386,7 @@
 
 	switch (cmd) {
 	case IPC_ROUTER_IOCTL_GET_VERSION:
-		n = IPC_ROUTER_V1;
+		n = IPC_ROUTER_VERSION;
 		ret = put_user(n, (unsigned int *)arg);
 		break;
 
@@ -473,8 +400,6 @@
 		break;
 
 	case IPC_ROUTER_IOCTL_LOOKUP_SERVER:
-		pil = msm_ipc_load_default_node();
-		msm_ipc_sk(sk)->default_pil = pil;
 		ret = copy_from_user(&server_arg, (void *)arg,
 				     sizeof(server_arg));
 		if (ret) {
@@ -487,14 +412,6 @@
 			break;
 		}
 		if (server_arg.num_entries_in_array) {
-			if (server_arg.num_entries_in_array >
-				(SIZE_MAX / sizeof(*srv_info))) {
-				pr_err("%s: Integer Overflow %d * %d\n",
-					__func__, sizeof(*srv_info),
-					server_arg.num_entries_in_array);
-				ret = -EINVAL;
-				break;
-			}
 			srv_info_sz = server_arg.num_entries_in_array *
 					sizeof(*srv_info);
 			srv_info = kmalloc(srv_info_sz, GFP_KERNEL);
@@ -529,12 +446,6 @@
 		ret = msm_ipc_router_bind_control_port(port_ptr);
 		break;
 
-	case IPC_ROUTER_IOCTL_CONFIG_SEC_RULES:
-		ret = msm_ipc_config_sec_rules((void *)arg);
-		if (ret != -EPERM)
-			port_ptr->type = IRSC_PORT;
-		break;
-
 	default:
 		ret = -EINVAL;
 	}
@@ -573,8 +484,7 @@
 
 	lock_sock(sk);
 	ret = msm_ipc_router_close_port(port_ptr);
-	if (pil)
-		msm_ipc_unload_default_node(pil);
+	msm_ipc_unload_default_node(pil);
 	release_sock(sk);
 	sock_put(sk);
 	sock->sk = NULL;
@@ -608,30 +518,6 @@
 	.obj_size       = sizeof(struct msm_ipc_sock),
 };
 
-/**
- * msm_ipc_router_ipc_log_init() - Init function for IPC Logging
- *
- * Initialize the buffers to be used to provide the log information
- * pertaining to the request, response and indication data flow that
- * happens between user and kernel spaces.
- */
-void msm_ipc_router_ipc_log_init(void)
-{
-	ipc_req_resp_log_txt =
-		ipc_log_context_create(REQ_RESP_IPC_LOG_PAGES,
-			"ipc_rtr_req_resp");
-	if (!ipc_req_resp_log_txt) {
-		pr_err("%s: Unable to create IPC logging for Req/Resp",
-			__func__);
-	}
-	ipc_ind_log_txt =
-		ipc_log_context_create(IND_IPC_LOG_PAGES, "ipc_rtr_ind");
-	if (!ipc_ind_log_txt) {
-		pr_err("%s: Unable to create IPC logging for Indications",
-			__func__);
-	}
-}
-
 int msm_ipc_router_init_sockets(void)
 {
 	int ret;
@@ -650,7 +536,6 @@
 	}
 
 	sockets_enabled = 1;
-	msm_ipc_router_ipc_log_init();
 out_init_sockets:
 	return ret;
 }
diff --unified -r mach-msm/jtag.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/jtag.c
--- mach-msm/jtag.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/jtag.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1105,6 +1105,9 @@
 	int ret;
 	uint32_t dbgdidr;
 
+	if (msm_jtag_fuse_apps_access_disabled())
+		return -EPERM;
+
 	/* This will run on core0 so use it to populate parameters */
 
 	/* Populate dbg_ctx data */
@@ -1146,6 +1149,9 @@
 	uint32_t etmidr;
 	uint32_t etmccr;
 
+	if (msm_jtag_fuse_apps_access_disabled())
+		return -EPERM;
+
 	/* Vote for ETM power/clock enable */
 	etm_clk_enable();
 
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm: jtag-fuse.c
Only in mach-msm: jtag-mm.c
diff --unified -r mach-msm/Kconfig /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/Kconfig
--- mach-msm/Kconfig	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/Kconfig	2013-12-17 17:08:05.606151173 -0800
@@ -159,10 +159,8 @@
 	select MSM_NATIVE_RESTART
 	select DONT_MAP_HOLE_AFTER_MEMBANK0
 	select MSM_REMOTE_SPINLOCK_SFPB
-	select ARCH_SPARSEMEM_ENABLE
 	select ARCH_HAS_HOLES_MEMORYMODEL
 	select CLEANCACHE
-	select QCACHE
 	select MSM_MULTIMEDIA_USE_ION
 	select MULTI_IRQ_HANDLER
 	select MSM_PM8X60 if PM
@@ -172,6 +170,10 @@
 	select MSM_KRAIT_WFE_FIXUP
 	select MSM_IOMMU_GPU_SYNC
 	select MSM_CPU_PWRCTL
+	select GENERIC_TIME_VSYSCALL
+	select USE_USER_ACCESSIBLE_TIMERS
+	select ARM_USE_USER_ACCESSIBLE_TIMERS
+	select MSM_USE_USER_ACCESSIBLE_TIMERS
 
 config ARCH_MSM8930
 	bool "MSM8930"
@@ -196,7 +198,6 @@
 	select MSM_NATIVE_RESTART
 	select DONT_MAP_HOLE_AFTER_MEMBANK0
 	select MSM_REMOTE_SPINLOCK_SFPB
-	select ARCH_SPARSEMEM_ENABLE
 	select ARCH_HAS_HOLES_MEMORYMODEL
 	select MSM_ULTRASOUND
 	select MULTI_IRQ_HANDLER
@@ -206,6 +207,10 @@
 	select MSM_KRAIT_WFE_FIXUP
 	select MSM_IOMMU_GPU_SYNC
 	select MSM_CPU_PWRCTL
+	select GENERIC_TIME_VSYSCALL
+	select USE_USER_ACCESSIBLE_TIMERS
+	select ARM_USE_USER_ACCESSIBLE_TIMERS
+	select MSM_USE_USER_ACCESSIBLE_TIMERS
 
 config ARCH_APQ8064
 	bool "APQ8064"
@@ -228,7 +233,6 @@
 	select CPU_HAS_L2_PMU
 	select HOLES_IN_ZONE if SPARSEMEM
 	select CLEANCACHE
-	select QCACHE
 	select MIGHT_HAVE_PCI
 	select ARCH_SUPPORTS_MSI
 	select ARM_HAS_SG_CHAIN
@@ -236,6 +240,10 @@
 	select SPARSEMEM_ALLOC_MEM_MAP_TOGETHER if SPARSEMEM
 	select MSM_IOMMU_GPU_SYNC
 	select MSM_CPU_PWRCTL
+	select GENERIC_TIME_VSYSCALL
+	select USE_USER_ACCESSIBLE_TIMERS
+	select ARM_USE_USER_ACCESSIBLE_TIMERS
+	select MSM_USE_USER_ACCESSIBLE_TIMERS
 
 config ARCH_MSM8974
 	bool "MSM8974"
@@ -261,6 +269,7 @@
 	select MSM_RPM_REGULATOR_SMD
 	select ARM_HAS_SG_CHAIN
 	select MSM_RUN_QUEUE_STATS
+	select DONT_MAP_HOLE_AFTER_MEMBANK0
 
 config ARCH_MPQ8092
 	bool "MPQ8092"
@@ -400,14 +409,13 @@
 	select ARCH_MSM_SCORPION
 	select MSM_SMP
 	select HAVE_ARCH_HAS_CURRENT_TIMER
-	select MSM_JTAG if CORESIGHT_ETM
+	select MSM_JTAG if MSM_QDSS
 	bool
 
 config  ARCH_MSM_KRAITMP
 	select ARCH_MSM_KRAIT
 	select MSM_SMP
 	select HAVE_ARCH_HAS_CURRENT_TIMER
-	select MSM_JTAG if CORESIGHT_ETM
 	bool
 
 config  ARCH_MSM_CORTEXMP
@@ -829,12 +837,6 @@
 	help
 	  Support for the Qualcomm MSM8930 FLUID device.
 
-config MACH_MSM8930_EVT
-	depends on ARCH_MSM8930
-	bool "MSM8930 QRD EVT"
-	help
-	  Support for the Qualcomm Reference Design 8930 EVT device.
-
 config MACH_MSM8627_CDP
 	depends on ARCH_MSM8930
 	bool "MSM8627 CDP"
@@ -1073,13 +1075,6 @@
 	help
 	  Support for the Samsung JF device.
 
-config MACH_JF_CMCCCSFB
-	depends on ARCH_APQ8064
-	default n
-	bool "APQ8064 Samsung JF_CMCC_CSFB"
-	help
-	  Support for the Samsung JF device.
-
 config PHYS_OFFSET
 	hex
 	default "0x40800000" if ARCH_MSM9615
@@ -1097,6 +1092,13 @@
 	default "0x40200000" if ARCH_MSM8X60
 	default "0x10000000"
 
+config HAVE_END_MEM
+	bool "Specify highest physical RAM address at compile time"
+
+config END_MEM
+	hex "Highest physical address where system RAM resides"
+	depends on HAVE_END_MEM
+
 config KERNEL_MSM_CONTIG_MEM_REGION
 	bool "Enable in-kernel contiguous memory region"
 	default y if ARCH_MSM8X60
@@ -1640,26 +1642,6 @@
 	help
 	  SMD Transport Layer for IPC Router
 
-config MSM_IPC_ROUTER_HSIC_XPRT
-	depends on USB_QCOM_IPC_BRIDGE
-	depends on MSM_IPC_ROUTER
-	bool "MSM HSIC XPRT Layer"
-	help
-	  HSIC Transport Layer that enables off-chip communication of
-	  IPC Router. When the HSIC endpoint becomes available, this layer
-	  registers the transport with IPC Router and enable message
-	  exchange.
-
-config MSM_IPC_ROUTER_SECURITY
-	depends on MSM_IPC_ROUTER
-	bool "MSM IPC Router Security support"
-	help
-	  This feature of IPC Router will enforce security rules
-	  configured by a security script from the user-space. IPC Router
-	  once configured with the security rules will ensure that the
-	  sender of the message to a service belongs to the relevant
-	  Linux group as configured by the security script.
-
 config MSM_ONCRPCROUTER_DEBUG
 	depends on MSM_ONCRPCROUTER
 	default y
@@ -2353,34 +2335,20 @@
 		enabled via another mechanism.
 
 config MSM_JTAG
-	bool "Debug and ETM trace support across power collapse"
-	help
-	  Enables support for debugging (specifically breakpoints) and ETM
-	  processor tracing across power collapse both for JTag and OS hosted
-	  software running on the target. Enabling this will ensure debug
-	  and ETM registers are saved and restored across power collapse.
-
-	  If unsure, say 'N' here to avoid potential power, performance and
-	  memory penalty.
-
-config MSM_JTAG_MM
-	bool "Debug and ETM trace support across power collapse using memory mapped access"
+	bool "JTAG and kernel debug and trace support across power collapse"
+	default y
 	help
-	  Enables support for debugging (specifically breakpoints) and ETM
+	  Enables support for kernel debugging (specifically breakpoints) and
 	  processor tracing across power collapse both for JTag and OS hosted
 	  software running on the target. Enabling this will ensure debug
 	  and ETM registers are saved and restored across power collapse.
 
-	  Required on targets on which cp14 access to debug and ETM registers is
-	  not permitted and so memory mapped access is necessary.
-
-	  If unsure, say 'N' here to avoid potential power, performance and
-	  memory penalty.
+	  For production builds, you should probably say 'N' here to avoid
+	  potential power, performance and memory penalty.
 
 config MSM_ETM
 	tristate "Enable MSM ETM and ETB"
 	depends on ARCH_MSM8X60
-	select MSM_JTAG
 	help
 	  Enables embedded trace collection on MSM8660
 
@@ -2823,4 +2791,12 @@
 	default n
 	help
 	  Enable Features only For FACTORY BINARY.
+
+config MSM_USE_USER_ACCESSIBLE_TIMERS
+	bool "Enables mapping an MSM timer counter page to user space."
+	depends on ARM_USE_USER_ACCESSIBLE_TIMERS
+	help
+	  Enables MSM-specific user accessible timers via a shared
+	  memory page containing the cycle counter.
+
 endif
Only in mach-msm: lge
diff --unified -r mach-msm/Makefile /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/Makefile
--- mach-msm/Makefile	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/Makefile	2013-12-17 17:08:05.606151173 -0800
@@ -6,7 +6,6 @@
 endif
 obj-y += clock.o clock-voter.o clock-dummy.o
 obj-y += modem_notifier.o subsystem_map.o
-obj-$(CONFIG_CPU_FREQ_MSM) += cpufreq.o
 obj-$(CONFIG_DEBUG_FS) += nohlt.o clock-debug.o
 obj-$(CONFIG_KEXEC) += msm_kexec.o
 
@@ -53,8 +52,7 @@
 obj-$(CONFIG_MSM_AVS_HW) += avs.o
 obj-$(CONFIG_CPU_V6) += idle-v6.o
 obj-$(CONFIG_CPU_V7) += idle-v7.o
-obj-$(CONFIG_MSM_JTAG) += jtag.o
-obj-$(CONFIG_MSM_JTAG_MM) +=  jtag-mm.o
+obj-$(CONFIG_MSM_JTAG) += jtag-fuse.o jtag.o
 
 msm-etm-objs := etm.o
 obj-$(CONFIG_MSM_ETM) += msm-etm.o
@@ -134,12 +132,10 @@
 obj-$(CONFIG_MSM_SMD_NMEA) += smd_nmea.o
 obj-$(CONFIG_MSM_RESET_MODEM) += reset_modem.o
 obj-$(CONFIG_MSM_IPC_ROUTER_SMD_XPRT) += ipc_router_smd_xprt.o
-obj-$(CONFIG_MSM_IPC_ROUTER_HSIC_XPRT) += ipc_router_hsic_xprt.o
 obj-$(CONFIG_MSM_ONCRPCROUTER) += smd_rpcrouter.o
 obj-$(CONFIG_MSM_ONCRPCROUTER) += smd_rpcrouter_device.o
 obj-$(CONFIG_MSM_IPC_ROUTER) += ipc_router.o
 obj-$(CONFIG_MSM_IPC_ROUTER)+= ipc_socket.o
-obj-$(CONFIG_MSM_IPC_ROUTER_SECURITY)+= msm_ipc_router_security.o
 obj-$(CONFIG_DEBUG_FS) += smd_rpc_sym.o
 obj-$(CONFIG_MSM_ONCRPCROUTER) += smd_rpcrouter_servers.o
 obj-$(CONFIG_MSM_ONCRPCROUTER) += smd_rpcrouter_clients.o
@@ -157,7 +153,10 @@
 obj-$(CONFIG_MSM_DALRPC_TEST) += dal_remotetest.o
 obj-$(CONFIG_ARCH_MSM7X30) += dal_axi.o
 obj-$(CONFIG_ARCH_MSM7X27A) += dal_axi.o
+obj-$(CONFIG_MSM_ADSP) += qdsp5/
+obj-$(CONFIG_MSM7KV2_AUDIO) += qdsp5v2/
 obj-$(CONFIG_MSM_RPCSERVER_HANDSET) += rpc_server_handset.o
+obj-$(CONFIG_MSM_QDSP6) += qdsp6/
 obj-$(CONFIG_MSM8X60_AUDIO) += qdsp6v2/
 obj-$(CONFIG_MSM_AUDIO_QDSP6) += qdsp6v2/
 obj-$(CONFIG_MSM_AUDIO_QDSP6V2) += qdsp6v2/
@@ -282,8 +281,7 @@
 obj-$(CONFIG_MACH_MSM8930_CDP) += board-8930-all.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o
 obj-$(CONFIG_MACH_MSM8930_MTP) += board-8930-all.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o
 obj-$(CONFIG_MACH_MSM8930_FLUID) += board-8930-all.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o
-obj-$(CONFIG_MACH_MSM8930_EVT) += board-8930-all.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o
-obj-$(CONFIG_PM8921_BMS) += bms-batterydata.o bms-batterydata-desay.o batterydata-lib.o
+obj-$(CONFIG_PM8921_BMS) += bms-batterydata.o bms-batterydata-desay.o
 obj-$(CONFIG_MACH_APQ8064_CDP) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_APQ8064_MTP) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_APQ8064_LIQUID) += board-8064-all.o board-8064-regulator.o
@@ -419,14 +417,15 @@
 obj-$(CONFIG_MSM_CPR) += msm_cpr.o
 obj-$(CONFIG_MSM_VP_REGULATOR) += msm_vp.o
 
+obj-$(CONFIG_MSM_USE_USER_ACCESSIBLE_TIMERS) += timer_page.o
+
 ifdef CONFIG_MSM_CPR
 obj-$(CONFIG_DEBUG_FS) += msm_cpr-debug.o
 endif
 obj-$(CONFIG_MSM_CPU_PWRCTL) +=  msm_cpu_pwrctl.o
-
-obj-$(CONFIG_ARCH_RANDOM) += early_random.o
 ifdef CONFIG_SEC_THERMISTOR
 obj-$(CONFIG_SEC_THERMISTOR) += sec_thermistor.o fusion3-thermistor.o
 endif
 
 obj-$(CONFIG_BT_BCM4335) += board-bluetooth-bcm4335.o
+obj-$(CONFIG_CPU_FREQ_MSM) += cpufreq.o
diff --unified -r mach-msm/Makefile.boot /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/Makefile.boot
--- mach-msm/Makefile.boot	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/Makefile.boot	2013-12-17 17:08:05.606151173 -0800
@@ -38,12 +38,14 @@
 
 # MSM8960
    zreladdr-$(CONFIG_ARCH_MSM8960)	:= 0x80208000
+params_phys-$(CONFIG_ARCH_MSM8960)	:= 0x80200100
 
 # MSM8930
    zreladdr-$(CONFIG_ARCH_MSM8930)	:= 0x80208000
 
 # APQ8064
    zreladdr-$(CONFIG_ARCH_APQ8064)	:= 0x80208000
+params_phys-$(CONFIG_ARCH_APQ8064)	:= 0x80200100
 
 # MSM8974
    zreladdr-$(CONFIG_ARCH_MSM8974)	:= 0x00008000
diff --unified -r mach-msm/mdm2.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/mdm2.c
--- mach-msm/mdm2.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/mdm2.c	2013-12-17 17:08:05.650151095 -0800
@@ -28,7 +28,6 @@
 #include <linux/debugfs.h>
 #include <linux/completion.h>
 #include <linux/workqueue.h>
-#include <linux/clk.h>
 #include <linux/mfd/pmic8058.h>
 #include <asm/mach-types.h>
 #include <asm/uaccess.h>
@@ -39,24 +38,26 @@
 #include <linux/msm_charm.h>
 #include "msm_watchdog.h"
 #include "devices.h"
-#include "clock.h"
 #include "mdm_private.h"
 #define MDM_PBLRDY_CNT		20
 
-static int mdm_debug_mask;
+static int mdm_debug_mask = 0xFF;
+static int power_on_count;
+static int hsic_peripheral_status;
+static DEFINE_MUTEX(hsic_status_lock);
 
 static void mdm_peripheral_connect(struct mdm_modem_drv *mdm_drv)
 {
 	if (!mdm_drv->pdata->peripheral_platform_device)
 		return;
 
-	mutex_lock(&mdm_drv->peripheral_status_lock);
-	if (mdm_drv->peripheral_status)
+	mutex_lock(&hsic_status_lock);
+	if (hsic_peripheral_status)
 		goto out;
 	platform_device_add(mdm_drv->pdata->peripheral_platform_device);
-	mdm_drv->peripheral_status = 1;
+	hsic_peripheral_status = 1;
 out:
-	mutex_unlock(&mdm_drv->peripheral_status_lock);
+	mutex_unlock(&hsic_status_lock);
 }
 
 static void mdm_peripheral_disconnect(struct mdm_modem_drv *mdm_drv)
@@ -64,13 +65,13 @@
 	if (!mdm_drv->pdata->peripheral_platform_device)
 		return;
 
-	mutex_lock(&mdm_drv->peripheral_status_lock);
-	if (!mdm_drv->peripheral_status)
+	mutex_lock(&hsic_status_lock);
+	if (!hsic_peripheral_status)
 		goto out;
 	platform_device_del(mdm_drv->pdata->peripheral_platform_device);
-	mdm_drv->peripheral_status = 0;
+	hsic_peripheral_status = 0;
 out:
-	mutex_unlock(&mdm_drv->peripheral_status_lock);
+	mutex_unlock(&hsic_status_lock);
 }
 
 /* This function can be called from atomic context. */
@@ -105,55 +106,65 @@
 	int soft_reset_direction =
 		mdm_drv->pdata->soft_reset_inverted ? 1 : 0;
 
+	if (mdm_debug_mask & MDM_DEBUG_MASK_SHDN_LOG)
+		pr_info("%s: Start mdm power down\n", __func__);
+
 	mdm_peripheral_disconnect(mdm_drv);
 
 	/* Wait for the modem to complete its power down actions. */
 	for (i = 20; i > 0; i--) {
 		if (gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 0) {
 			if (mdm_debug_mask & MDM_DEBUG_MASK_SHDN_LOG)
-				pr_info("%s:id %d: mdm2ap_statuswent low, i=%d\n",
-					__func__, mdm_drv->device_id, i);
+				pr_info("%s: mdm2ap_status went low, i = %d\n",
+					__func__, i);
 			break;
 		}
 		msleep(100);
 	}
 
-	/* Assert the soft reset line whether mdm2ap_status went low or not */
-	gpio_direction_output(mdm_drv->ap2mdm_soft_reset_gpio,
-					soft_reset_direction);
-	if (i == 0) {
-		pr_err("%s: MDM2AP_STATUS never went low. Doing a hard reset\n",
-			   __func__);
-		/*
-		* Currently, there is a debounce timer on the charm PMIC. It is
-		* necessary to hold the PMIC RESET low for ~3.5 seconds
-		* for the reset to fully take place. Sleep here to ensure the
-		* reset has occured before the function exits.
-		*/
-		msleep(4000);
+	if (i != 0) {
+		pr_err("%s: MDM2AP_STATUS went low successfully.\n", __func__);
+		return;
 	}
+
+	/* Shutdown the MDM9K gracefully.
+	 * It seems that the MDM9K does not shutdown properly
+	 * with shutdown command sent by system monitor via HSIC channel.
+	 * The GPIO_27 of APQ named AP2MDM_PON_RESET_N is connected
+	 * to PON_TRIG of PMIC8018 and PS_HOLD of PMIC8018 with a diode and
+	 * a registor. So if GPIO_27 is pulled low the PS_HOLD input of
+	 * PMIC8018 is low. The full powerdown sequence will be executed.*/
+
+	pr_err("%s: MDM2AP_STATUS never went low. Doing a hard reset\n",
+			__func__);
+	pr_info("Hold PS_HOLD of MDM9K low for the reset to fully take place.\n");
+
+	/* Q : Why we should hold the PS_HOLD low of PMIC 8018 for 1500ms?
+	 * A : To overcome WDOG, we must hold PS_HOLD low for longer than the
+	 * t(pshold) timer. This timer is 300ms MAX. To overcome SMPL, we must
+	 * hold PS_HOLD low for longer thatn the SMPL timer setting. Since the
+	 * SMPL timer is 1000ms which is greater thant the maximum t(pshold)
+	 * timer, we just need to hold PS_HOLD low for longer than the SMPL
+	 * timer to shut down the device with WDOG and SMPL.
+	 * We added 500ms duration for margin of safety.
+	 */
+	gpio_direction_output(mdm_drv->ap2mdm_soft_reset_gpio,
+				soft_reset_direction);
+	msleep(1500);
+
 }
 
 static void mdm_do_first_power_on(struct mdm_modem_drv *mdm_drv)
 {
 	int i;
 	int pblrdy;
-	int kpd_direction_assert = 1,
-		kpd_direction_de_assert = 0;
-
-	if (mdm_drv->pdata->kpd_not_inverted) {
-		kpd_direction_assert = 0;
-		kpd_direction_de_assert = 1;
-	}
-
-	if (mdm_drv->power_on_count != 1) {
-		pr_err("%s:id %d: Calling fn when power_on_count != 1\n",
-			   __func__, mdm_drv->device_id);
+	if (power_on_count != 1) {
+		pr_err("%s: Calling fn when power_on_count != 1\n",
+			   __func__);
 		return;
 	}
 
-	pr_err("%s:id %d: Powering on modem for the first time\n",
-		   __func__, mdm_drv->device_id);
+	pr_err("%s: Powering on modem for the first time\n", __func__);
 	mdm_peripheral_disconnect(mdm_drv);
 
 	/* If this is the first power-up after a panic, the modem may still
@@ -161,9 +172,7 @@
 	 * instead of just de-asserting it. No harm done if the modem was
 	 * powered down.
 	 */
-	if (!mdm_drv->pdata->no_reset_on_first_powerup)
-		mdm_toggle_soft_reset(mdm_drv);
-
+	mdm_toggle_soft_reset(mdm_drv);
 	/* If the device has a kpd pwr gpio then toggle it. */
 	if (GPIO_IS_VALID(mdm_drv->ap2mdm_kpdpwr_n_gpio)) {
 		/* Pull AP2MDM_KPDPWR gpio high and wait for PS_HOLD to settle,
@@ -171,11 +180,9 @@
 		 */
 		pr_debug("%s: Pulling AP2MDM_KPDPWR gpio high\n", __func__);
 		gpio_direction_output(mdm_drv->ap2mdm_kpdpwr_n_gpio, 1);
-		gpio_direction_output(mdm_drv->ap2mdm_status_gpio, 1);
 		msleep(1000);
 		gpio_direction_output(mdm_drv->ap2mdm_kpdpwr_n_gpio, 0);
-	} else
-		gpio_direction_output(mdm_drv->ap2mdm_status_gpio, 1);
+	}
 
 	if (!GPIO_IS_VALID(mdm_drv->mdm2ap_pblrdy))
 		goto start_mdm_peripheral;
@@ -186,8 +193,7 @@
 			break;
 		usleep_range(5000, 5000);
 	}
-	pr_debug("%s: id %d: pblrdy i:%d\n", __func__,
-			 mdm_drv->device_id, i);
+	pr_debug("%s: i:%d\n", __func__, i);
 
 start_mdm_peripheral:
 	mdm_peripheral_connect(mdm_drv);
@@ -199,8 +205,7 @@
 	int i;
 	int pblrdy;
 
-	pr_err("%s: id %d:  soft resetting mdm modem\n",
-		   __func__, mdm_drv->device_id);
+	pr_err("%s: soft resetting mdm modem\n", __func__);
 	mdm_peripheral_disconnect(mdm_drv);
 	mdm_toggle_soft_reset(mdm_drv);
 
@@ -214,8 +219,7 @@
 		usleep_range(5000, 5000);
 	}
 
-	pr_debug("%s: id %d: pblrdy i:%d\n", __func__,
-			 mdm_drv->device_id, i);
+	pr_debug("%s: i:%d\n", __func__, i);
 
 start_mdm_peripheral:
 	mdm_peripheral_connect(mdm_drv);
@@ -224,7 +228,7 @@
 
 static void mdm_power_on_common(struct mdm_modem_drv *mdm_drv)
 {
-	mdm_drv->power_on_count++;
+	power_on_count++;
 
 	/* this gpio will be used to indicate apq readiness,
 	 * de-assert it now so that it can be asserted later.
@@ -239,10 +243,10 @@
 	 * user space but we're already powered on. Ignore it.
 	 */
 	if (mdm_drv->pdata->early_power_on &&
-			(mdm_drv->power_on_count == 2))
+			(power_on_count == 2))
 		return;
 
-	if (mdm_drv->power_on_count == 1)
+	if (power_on_count == 1)
 		mdm_do_first_power_on(mdm_drv);
 	else
 		mdm_do_soft_power_on(mdm_drv);
@@ -255,8 +259,7 @@
 
 static void mdm_status_changed(struct mdm_modem_drv *mdm_drv, int value)
 {
-	pr_debug("%s: id %d: value:%d\n", __func__,
-			 value, mdm_drv->device_id);
+	pr_debug("%s: value:%d\n", __func__, value);
 
 	if (value) {
 		mdm_peripheral_disconnect(mdm_drv);
@@ -270,15 +273,13 @@
 {
 	switch (type) {
 	case APQ_CONTROLLED_UPGRADE:
-		pr_debug("%s: id %d: APQ controlled modem image upgrade\n",
-				 __func__, mdm_drv->device_id);
-		atomic_set(&mdm_drv->mdm_ready, 0);
+		pr_debug("%s APQ controlled modem image upgrade\n", __func__);
+		mdm_drv->mdm_ready = 0;
 		mdm_toggle_soft_reset(mdm_drv);
 		break;
 	case MDM_CONTROLLED_UPGRADE:
-		pr_debug("%s: id %d: MDM controlled modem image upgrade\n",
-				 __func__, mdm_drv->device_id);
-		atomic_set(&mdm_drv->mdm_ready, 0);
+		pr_debug("%s MDM controlled modem image upgrade\n", __func__);
+		mdm_drv->mdm_ready = 0;
 		/*
 		 * If we have no image currently present on the modem, then we
 		 * would be in PBL, in which case the status gpio would not go
@@ -286,19 +287,15 @@
 		 */
 		mdm_drv->disable_status_check = 1;
 		if (GPIO_IS_VALID(mdm_drv->usb_switch_gpio)) {
-			pr_info("%s: id %d: Switching usb control to MDM\n",
-					__func__, mdm_drv->device_id);
+			pr_info("%s Switching usb control to MDM\n", __func__);
 			gpio_direction_output(mdm_drv->usb_switch_gpio, 1);
 		} else
-			pr_err("%s: id %d: usb switch gpio unavailable\n",
-				   __func__, mdm_drv->device_id);
+			pr_err("%s usb switch gpio unavailable\n", __func__);
 		break;
 	default:
-		pr_err("%s: id %d: invalid upgrade type\n",
-			   __func__, mdm_drv->device_id);
+		pr_err("%s invalid upgrade type\n", __func__);
 	}
 }
-
 static struct mdm_ops mdm_cb = {
 	.power_on_mdm_cb = mdm_power_on_common,
 	.reset_mdm_cb = mdm_power_on_common,
@@ -309,10 +306,51 @@
 	.image_upgrade_cb = mdm_image_upgrade,
 };
 
-int mdm_get_ops(struct mdm_ops **mdm_ops)
+static int __init mdm_modem_probe(struct platform_device *pdev)
+{
+	return mdm_common_create(pdev, &mdm_cb);
+}
+
+static int __devexit mdm_modem_remove(struct platform_device *pdev)
+{
+	return mdm_common_modem_remove(pdev);
+}
+
+static void mdm_modem_shutdown(struct platform_device *pdev)
+{
+	mdm_common_modem_shutdown(pdev);
+}
+
+static struct platform_driver mdm_modem_driver = {
+	.remove         = mdm_modem_remove,
+	.shutdown	= mdm_modem_shutdown,
+	.driver         = {
+		.name = "mdm2_modem",
+		.owner = THIS_MODULE
+	},
+};
+
+static int __init mdm_modem_init(void)
 {
-	*mdm_ops = &mdm_cb;
+#ifdef CONFIG_SAMSUNG_LPM_MODE
+	if (poweroff_charging)
+		return 0;
+#endif
+#ifdef CONFIG_WIFI_NOMODEM
 	return 0;
+#endif
+	return platform_driver_probe(&mdm_modem_driver, mdm_modem_probe);
+}
+
+static void __exit mdm_modem_exit(void)
+{
+	platform_driver_unregister(&mdm_modem_driver);
 }
 
+module_init(mdm_modem_init);
+module_exit(mdm_modem_exit);
 
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("mdm modem driver");
+MODULE_VERSION("2.0");
+MODULE_ALIAS("mdm_modem");
diff --unified -r mach-msm/mdm_common.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/mdm_common.c
--- mach-msm/mdm_common.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/mdm_common.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -42,6 +42,7 @@
 #include "msm_watchdog.h"
 #include "mdm_private.h"
 #include "sysmon.h"
+#include <mach/diag_bridge.h>
 #ifdef CONFIG_SEC_DEBUG
 #include <mach/sec_debug.h>
 #endif
@@ -52,15 +53,22 @@
 #define MDM_RDUMP_TIMEOUT	120000L
 #define MDM2AP_STATUS_TIMEOUT_MS 60000L
 
-/* Allow a maximum device id of this many digits */
-#define MAX_DEVICE_DIGITS  10
+static unsigned int mdm_debug_mask = 0xFF;
+static struct workqueue_struct *mdm_queue;
+static struct workqueue_struct *mdm_sfr_queue;
+static unsigned int dump_timeout_ms;
+static int vddmin_gpios_sent;
+
 #define EXTERNAL_MODEM "external_modem"
-#define SUBSYS_NAME_LENGTH \
-	(sizeof(EXTERNAL_MODEM) + MAX_DEVICE_DIGITS)
 
-#define DEVICE_BASE_NAME "mdm"
-#define DEVICE_NAME_LENGTH \
-	(sizeof(DEVICE_BASE_NAME) + MAX_DEVICE_DIGITS)
+static struct mdm_modem_drv *mdm_drv;
+static struct subsys_device *mdm_subsys_dev;
+
+DECLARE_COMPLETION(mdm_needs_reload);
+DECLARE_COMPLETION(mdm_boot);
+DECLARE_COMPLETION(mdm_ram_dumps);
+
+static int first_boot = 1;
 
 #define RD_BUF_SIZE			100
 #define SFR_MAX_RETRIES		10
@@ -70,242 +78,73 @@
 	GPIO_UPDATE_BOOTING_CONFIG = 1,
 	GPIO_UPDATE_RUNNING_CONFIG,
 };
+static int mdm2ap_status_valid_old_config;
+static struct gpiomux_setting mdm2ap_status_old_config;
 
-struct mdm_device {
-	struct list_head		link;
-	struct mdm_modem_drv	mdm_data;
-
-	int mdm2ap_status_valid_old_config;
-	struct gpiomux_setting mdm2ap_status_old_config;
-	int first_boot;
-	struct workqueue_struct *mdm_queue;
-	struct workqueue_struct *mdm_sfr_queue;
-	unsigned int dump_timeout_ms;
-
-	char subsys_name[SUBSYS_NAME_LENGTH];
-	struct subsys_desc mdm_subsys;
-	struct subsys_device *mdm_subsys_dev;
-
-	char device_name[DEVICE_NAME_LENGTH];
-	struct miscdevice misc_device;
-
-	struct completion mdm_needs_reload;
-	struct completion mdm_boot;
-	struct completion mdm_ram_dumps;
-	int mdm_errfatal_irq;
-	int mdm_status_irq;
-	int mdm_pblrdy_irq;
-
-	struct delayed_work mdm2ap_status_check_work;
-	struct work_struct mdm_status_work;
-	struct work_struct sfr_reason_work;
-
-	struct notifier_block mdm_panic_blk;
-	struct notifier_block ssr_notifier_blk;
-
-	int ssr_started_internally;
-};
-
-static struct list_head	mdm_devices;
-static DEFINE_SPINLOCK(mdm_devices_lock);
-static int disable_boot_timeout = 0;
-
-static int ssr_count;
-static DEFINE_SPINLOCK(ssr_lock);
-
-static unsigned int mdm_debug_mask;
-int vddmin_gpios_sent;
-static struct mdm_ops *mdm_ops;
-
-static void mdm_device_list_add(struct mdm_device *mdev)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdm_devices_lock, flags);
-	list_add_tail(&mdev->link, &mdm_devices);
-	spin_unlock_irqrestore(&mdm_devices_lock, flags);
-}
-
-static void mdm_device_list_remove(struct mdm_device *mdev)
-{
-	unsigned long flags;
-	struct mdm_device *lmdev, *tmp;
-
-	spin_lock_irqsave(&mdm_devices_lock, flags);
-	list_for_each_entry_safe(lmdev, tmp, &mdm_devices, link) {
-		if (mdev && mdev == lmdev) {
-			pr_debug("%s: removing device id %d\n",
-			  __func__, mdev->mdm_data.device_id);
-			list_del(&mdev->link);
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&mdm_devices_lock, flags);
-}
-
-static int param_set_disable_boot_timeout(const char *val,
-		const struct kernel_param *kp)
-{
-	int rcode;
-	pr_info("%s called\n",__func__);
-	rcode = param_set_bool(val, kp);
-	if (rcode)
-		pr_err("%s: Failed to set boot_timout_disabled flag\n",
-				__func__);
-	pr_info("%s: disable_boot_timeout is now %d\n",
-			__func__, disable_boot_timeout);
-	return rcode;
-}
-
-static struct kernel_param_ops disable_boot_timeout_ops = {
-	.set = param_set_disable_boot_timeout,
-	.get = param_get_bool,
-};
-module_param_cb(disable_boot_timeout, &disable_boot_timeout_ops,
-		&disable_boot_timeout, 0644);
-MODULE_PARM_DESC(disable_boot_timeout, "Disable panic on mdm bootup timeout");
-/* If the platform's cascading_ssr flag is set, the subsystem
- * restart module will restart the other modems so stop
- * monitoring them as well.
- * This function can be called from interrupt context.
- */
-static void mdm_start_ssr(struct mdm_device *mdev)
+static irqreturn_t mdm_vddmin_change(int irq, void *dev_id)
 {
-	unsigned long flags;
-	int start_ssr = 1;
+	int value = gpio_get_value(
+		mdm_drv->pdata->vddmin_resource->mdm2ap_vddmin_gpio);
 
-	spin_lock_irqsave(&ssr_lock, flags);
-	if (mdev->mdm_data.pdata->cascading_ssr &&
-			ssr_count > 0) {
-		start_ssr = 0;
-	} else {
-		ssr_count++;
-		mdev->ssr_started_internally = 1;
-	}
-	spin_unlock_irqrestore(&ssr_lock, flags);
-
-	if (start_ssr) {
-		atomic_set(&mdev->mdm_data.mdm_ready, 0);
-		pr_info("%s: Resetting mdm id %d due to mdm error\n",
-				__func__, mdev->mdm_data.device_id);
-		subsystem_restart_dev(mdev->mdm_subsys_dev);
-	} else {
-		pr_info("%s: Another modem is already in SSR\n",
-				__func__);
-	}
-}
-
-/* Increment the reference count to handle the case where
- * subsystem restart is initiated by the SSR service.
- */
-static void mdm_ssr_started(struct mdm_device *mdev)
-{
-	unsigned long flags;
+	if (value == 0)
+		pr_debug("External Modem entered Vddmin\n");
+	else
+		pr_debug("External Modem exited Vddmin\n");
 
-	spin_lock_irqsave(&ssr_lock, flags);
-	ssr_count++;
-	atomic_set(&mdev->mdm_data.mdm_ready, 0);
-	spin_unlock_irqrestore(&ssr_lock, flags);
+	return IRQ_HANDLED;
 }
 
-/* mdm_ssr_completed assumes that mdm_ssr_started has previously
- * been called.
+/* This function will generate the MDM crash.
+ * when you need to get the ram dumps of MDM9K,
+ * you can trigger the crash by calling this function.
  */
-static void mdm_ssr_completed(struct mdm_device *mdev)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&ssr_lock, flags);
-	ssr_count--;
-	if (mdev->ssr_started_internally) {
-		mdev->ssr_started_internally = 0;
-		ssr_count--;
-	}
-
-	if (ssr_count < 0) {
-		pr_err("%s: ssr_count = %d\n",
-			    __func__, ssr_count);
-		panic("%s: ssr_count = %d < 0\n",
-			  __func__, ssr_count);
-	}
-	spin_unlock_irqrestore(&ssr_lock, flags);
-}
-
-static int mdm_force_crash(struct mdm_device *mdev)
+static int mdm_force_crash(void)
 {
 	pr_info("%s: Start mdm force crash\n", __func__);
 
-	mdm_start_ssr(mdev);
-
+	if (mdm_drv->mdm_ready) {
+		mdm_drv->mdm_ready = 0;
+		subsystem_restart_dev(mdm_subsys_dev);
+	}
 	return 0;
 }
-static irqreturn_t mdm_vddmin_change(int irq, void *dev_id)
-{
-	struct mdm_device *mdev = (struct mdm_device *)dev_id;
-	struct mdm_vddmin_resource *vddmin_res;
-	int value;
-
-	if (!mdev)
-		goto handled;
-
-	vddmin_res = mdev->mdm_data.pdata->vddmin_resource;
-	if (!vddmin_res)
-		goto handled;
-
-	value = gpio_get_value(
-	   vddmin_res->mdm2ap_vddmin_gpio);
-	if (value == 0)
-		pr_info("External Modem id %d entered Vddmin\n",
-				mdev->mdm_data.device_id);
-	else
-		pr_info("External Modem id %d exited Vddmin\n",
-				mdev->mdm_data.device_id);
-handled:
-	return IRQ_HANDLED;
-}
 
-/* The vddmin_res resource may not be supported by some platforms. */
 static void mdm_setup_vddmin_gpios(void)
 {
-	unsigned long flags;
 	struct msm_rpm_iv_pair req;
-	struct mdm_device *mdev;
 	struct mdm_vddmin_resource *vddmin_res;
 	int irq, ret;
 
-	spin_lock_irqsave(&mdm_devices_lock, flags);
-	list_for_each_entry(mdev, &mdm_devices, link) {
-		vddmin_res = mdev->mdm_data.pdata->vddmin_resource;
-		if (!vddmin_res)
-			continue;
-
-		pr_info("Enabling vddmin logging on modem id %d\n",
-				mdev->mdm_data.device_id);
-		req.id = vddmin_res->rpm_id;
-		req.value =
-			((uint32_t)vddmin_res->ap2mdm_vddmin_gpio & 0x0000FFFF)
-						<< 16;
-		req.value |= ((uint32_t)vddmin_res->modes & 0x000000FF) << 8;
-		req.value |= (uint32_t)vddmin_res->drive_strength & 0x000000FF;
-
-		msm_rpm_set(MSM_RPM_CTX_SET_0, &req, 1);
-
-		/* Start monitoring low power gpio from mdm */
-		irq = MSM_GPIO_TO_INT(vddmin_res->mdm2ap_vddmin_gpio);
-		if (irq < 0)
-			pr_err("%s: could not get LPM POWER IRQ resource mdm id %d.\n",
-				   __func__, mdev->mdm_data.device_id);
-		else {
-			ret = request_threaded_irq(irq, NULL, mdm_vddmin_change,
-				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
-				"mdm lpm", mdev);
-
-			if (ret < 0)
-				pr_err("%s: MDM LPM IRQ#%d request failed with error=%d",
-					   __func__, irq, ret);
-		}
+	/* This resource may not be supported by some platforms. */
+	vddmin_res = mdm_drv->pdata->vddmin_resource;
+	if (!vddmin_res)
+		return;
+
+	pr_info("Enabling vddmin logging\n");
+	req.id = vddmin_res->rpm_id;
+	req.value = ((uint32_t)vddmin_res->ap2mdm_vddmin_gpio & 0x0000FFFF)
+							<< 16;
+	req.value |= ((uint32_t)vddmin_res->modes & 0x000000FF) << 8;
+	req.value |= (uint32_t)vddmin_res->drive_strength & 0x000000FF;
+
+	msm_rpm_set(MSM_RPM_CTX_SET_0, &req, 1);
+
+	/* Start monitoring low power gpio from mdm */
+	irq = MSM_GPIO_TO_INT(vddmin_res->mdm2ap_vddmin_gpio);
+	if (irq < 0) {
+		pr_err("%s: could not get LPM POWER IRQ resource.\n",
+			__func__);
+		goto error_end;
 	}
-	spin_unlock_irqrestore(&mdm_devices_lock, flags);
+
+	ret = request_threaded_irq(irq, NULL, mdm_vddmin_change,
+		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+		"mdm lpm", NULL);
+
+	if (ret < 0)
+		pr_err("%s: MDM LPM IRQ#%d request failed with error=%d",
+			__func__, irq, ret);
+error_end:
 	return;
 }
 
@@ -313,60 +152,48 @@
 {
 	int ret, ntries = 0;
 	char sfr_buf[RD_BUF_SIZE];
-	struct mdm_platform_data *pdata;
-	struct mdm_device *mdev = container_of(work,
-			struct mdm_device, sfr_reason_work);
 
-	pdata = mdev->mdm_data.pdata;
 	do {
-		if (pdata->sysmon_subsys_id_valid)
-		{
-			msleep(SFR_RETRY_INTERVAL);
-			ret = sysmon_get_reason(pdata->sysmon_subsys_id,
+		msleep(SFR_RETRY_INTERVAL);
+		ret = sysmon_get_reason(SYSMON_SS_EXT_MODEM,
 					sfr_buf, sizeof(sfr_buf));
-			if (ret) {
-				/*
-				 * The sysmon device may not have been probed as
-				 * yet after the restart.
-				 */
-				pr_err("%s: Error retrieving restart reason,"
-						"ret = %d %d/%d tries\n",
-						__func__, ret,
-						ntries + 1,
-						SFR_MAX_RETRIES);
-			} else {
-				pr_err("mdm restart reason: %s\n", sfr_buf);
-				break;
-			}
+		if (ret) {
+			/*
+			 * The sysmon device may not have been probed as yet
+			 * after the restart.
+			 */
+			pr_err("%s: Error retrieving mdm restart reason, ret = %d, "
+					"%d/%d tries\n", __func__, ret,
+					ntries + 1,	SFR_MAX_RETRIES);
+		} else {
+			pr_err("mdm restart reason: %s\n", sfr_buf);
+			break;
 		}
 	} while (++ntries < SFR_MAX_RETRIES);
 }
 
+static DECLARE_WORK(sfr_reason_work, mdm_restart_reason_fn);
+
 static void mdm2ap_status_check(struct work_struct *work)
 {
-	struct mdm_device *mdev =
-		container_of(work, struct mdm_device,
-					 mdm2ap_status_check_work.work);
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
 	/*
 	 * If the mdm modem did not pull the MDM2AP_STATUS gpio
 	 * high then call subsystem_restart.
 	 */
 	if (!mdm_drv->disable_status_check) {
 		if (gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 0) {
-			pr_err("%s: MDM2AP_STATUS did not go high on mdm id %d\n",
-				   __func__, mdev->mdm_data.device_id);
-			if (!disable_boot_timeout)
-				mdm_start_ssr(mdev);
+			pr_err("%s: MDM2AP_STATUS gpio did not go high\n",
+					__func__);
+			mdm_drv->mdm_ready = 0;
+			subsystem_restart_dev(mdm_subsys_dev);
 		}
 	}
 }
 
-static void mdm_update_gpio_configs(struct mdm_device *mdev,
-				enum gpio_update_config gpio_config)
-{
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
+static DECLARE_DELAYED_WORK(mdm2ap_status_check_work, mdm2ap_status_check);
 
+static void mdm_update_gpio_configs(enum gpio_update_config gpio_config)
+{
 	/* Some gpio configuration may need updating after modem bootup.*/
 	switch (gpio_config) {
 	case GPIO_UPDATE_RUNNING_CONFIG:
@@ -374,20 +201,20 @@
 			if (msm_gpiomux_write(mdm_drv->mdm2ap_status_gpio,
 				GPIOMUX_ACTIVE,
 				mdm_drv->pdata->mdm2ap_status_gpio_run_cfg,
-				&mdev->mdm2ap_status_old_config))
-				pr_err("%s: failed updating running gpio config mdm id %d\n",
-					   __func__, mdev->mdm_data.device_id);
+				&mdm2ap_status_old_config))
+				pr_err("%s: failed updating running gpio config\n",
+					   __func__);
 			else
-				mdev->mdm2ap_status_valid_old_config = 1;
+				mdm2ap_status_valid_old_config = 1;
 		}
 		break;
 	case GPIO_UPDATE_BOOTING_CONFIG:
-		if (mdev->mdm2ap_status_valid_old_config) {
+		if (mdm2ap_status_valid_old_config) {
 			msm_gpiomux_write(mdm_drv->mdm2ap_status_gpio,
 					GPIOMUX_ACTIVE,
-					&mdev->mdm2ap_status_old_config,
+					&mdm2ap_status_old_config,
 					NULL);
-			mdev->mdm2ap_status_valid_old_config = 0;
+			mdm2ap_status_valid_old_config = 0;
 		}
 		break;
 	default:
@@ -419,28 +246,21 @@
 }
 #endif
 
-static long mdm_modem_ioctl(struct file *filp, unsigned int cmd,
+long mdm_modem_ioctl(struct file *filp, unsigned int cmd,
 				unsigned long arg)
 {
 	int status, ret = 0;
-	struct mdm_device *mdev = filp->private_data;
-	struct mdm_modem_drv *mdm_drv;
-	struct mdm_device *l_mdev;
 
 	if (_IOC_TYPE(cmd) != CHARM_CODE) {
-		pr_err("%s: invalid ioctl code to mdm id %d\n",
-			   __func__, mdev->mdm_data.device_id);
+		pr_err("%s: invalid ioctl code\n", __func__);
 		return -EINVAL;
 	}
 
-	mdm_drv = &mdev->mdm_data;
-	pr_debug("%s: Entering ioctl cmd = %d, mdm id = %d\n",
-			 __func__, _IOC_NR(cmd), mdev->mdm_data.device_id);
+	pr_debug("%s: Entering ioctl cmd = %d\n", __func__, _IOC_NR(cmd));
 	switch (cmd) {
 	case WAKE_CHARM:
-		pr_info("%s: Powering on mdm id %d\n",
-				__func__, mdev->mdm_data.device_id);
-		mdm_ops->power_on_mdm_cb(mdm_drv);
+		pr_info("%s: Powering on mdm\n", __func__);
+		mdm_drv->ops->power_on_mdm_cb(mdm_drv);
 		break;
 	case CHECK_FOR_BOOT:
 		if (gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 0)
@@ -449,33 +269,30 @@
 			put_user(0, (unsigned long __user *) arg);
 		break;
 	case NORMAL_BOOT_DONE:
-		pr_debug("%s: check if mdm id %d is booted up\n",
-				 __func__, mdev->mdm_data.device_id);
+		pr_debug("%s: check if mdm is booted up\n", __func__);
 		get_user(status, (unsigned long __user *) arg);
 		if (status) {
-			pr_debug("%s: normal boot of mdm id %d failed\n",
-					 __func__, mdev->mdm_data.device_id);
+			pr_debug("%s: normal boot failed\n", __func__);
 			mdm_drv->mdm_boot_status = -EIO;
 		} else {
-			pr_info("%s: normal boot of mdm id %d done\n",
-					__func__, mdev->mdm_data.device_id);
+			pr_info("%s: normal boot done\n", __func__);
 			mdm_drv->mdm_boot_status = 0;
 		}
-		atomic_set(&mdm_drv->mdm_ready, 1);
+		mdm_drv->mdm_ready = 1;
 
-		if (mdm_ops->normal_boot_done_cb != NULL)
-			mdm_ops->normal_boot_done_cb(mdm_drv);
+		if (mdm_drv->ops->normal_boot_done_cb != NULL)
+			mdm_drv->ops->normal_boot_done_cb(mdm_drv);
 
-		if (!mdev->first_boot)
-			complete(&mdev->mdm_boot);
+		if (!first_boot)
+			complete(&mdm_boot);
 		else
-			mdev->first_boot = 0;
+			first_boot = 0;
 
 		/* If successful, start a timer to check that the mdm2ap_status
 		 * gpio goes high.
 		 */
 		if (!status && gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 0)
-			schedule_delayed_work(&mdev->mdm2ap_status_check_work,
+			schedule_delayed_work(&mdm2ap_status_check_work,
 				msecs_to_jiffies(MDM2AP_STATUS_TIMEOUT_MS));
 		break;
 	case RAM_DUMP_DONE:
@@ -492,24 +309,22 @@
 				panic("external_modem %s", mdm_read_err_report());
 			}
 #endif
-
 		}
-		complete(&mdev->mdm_ram_dumps);
+		complete(&mdm_ram_dumps);
 		break;
 	case WAIT_FOR_RESTART:
 		pr_debug("%s: wait for mdm to need images reloaded\n",
 				__func__);
-		ret = wait_for_completion_interruptible(
-				&mdev->mdm_needs_reload);
+		ret = wait_for_completion_interruptible(&mdm_needs_reload);
 		if (!ret)
 			put_user(mdm_drv->boot_type,
 					 (unsigned long __user *) arg);
-		init_completion(&mdev->mdm_needs_reload);
+		INIT_COMPLETION(mdm_needs_reload);
 		break;
 	case GET_DLOAD_STATUS:
 		pr_debug("getting status of mdm2ap_errfatal_gpio\n");
 		if (gpio_get_value(mdm_drv->mdm2ap_errfatal_gpio) == 1 &&
-			!atomic_read(&mdm_drv->mdm_ready))
+			!mdm_drv->mdm_ready)
 			put_user(1, (unsigned long __user *) arg);
 		else
 			put_user(0, (unsigned long __user *) arg);
@@ -517,136 +332,105 @@
 	case IMAGE_UPGRADE:
 		pr_debug("%s Image upgrade ioctl recieved\n", __func__);
 		if (mdm_drv->pdata->image_upgrade_supported &&
-				mdm_ops->image_upgrade_cb) {
-			list_for_each_entry(l_mdev, &mdm_devices, link) {
-				if (l_mdev != mdev) {
-					pr_debug("%s:setting mdm_rdy to false",
-							__func__);
-					atomic_set(&l_mdev->mdm_data.mdm_ready,
-							0);
-				}
-			}
+				mdm_drv->ops->image_upgrade_cb) {
 			get_user(status, (unsigned long __user *) arg);
-			mdm_ops->image_upgrade_cb(mdm_drv, status);
+			mdm_drv->ops->image_upgrade_cb(mdm_drv, status);
 		} else
 			pr_debug("%s Image upgrade not supported\n", __func__);
 		break;
 	case SHUTDOWN_CHARM:
-		if (!mdm_drv->pdata->send_shdn ||
-				!mdm_drv->pdata->sysmon_subsys_id_valid) {
-			pr_debug("%s shutdown not supported for this mdm\n",
-					__func__);
-			break;
-		}
-		atomic_set(&mdm_drv->mdm_ready, 0);
+		mdm_drv->mdm_ready = 0;
 		if (mdm_debug_mask & MDM_DEBUG_MASK_SHDN_LOG)
 			pr_info("Sending shutdown request to mdm\n");
-		ret = sysmon_send_shutdown(mdm_drv->pdata->sysmon_subsys_id);
+		ret = sysmon_send_shutdown(SYSMON_SS_EXT_MODEM);
 		if (ret)
-			pr_err("%s:Graceful shutdown of mdm failed, ret = %d\n",
-			   __func__, ret);
+			pr_err("%s: Graceful shutdown of the external modem failed, ret = %d\n",
+				   __func__, ret);
 		put_user(ret, (unsigned long __user *) arg);
 		break;
 	case USER_FORCE_CRASH:
-		pr_info("%s: User force crash ioctl received\n", __func__);
-		mdm_force_crash(mdev);
+		pr_info("%s: User forced crash ioctl recieved\n", __func__);
+		mdm_force_crash();
+		break;
+
+	case AUTOPM_LOCK:
+		get_user(status, (unsigned long __user *) arg);
+		pr_info("%s: mdm autopm request[%s]\n", __func__,
+						status ? "lock" : "release");
+		request_autopm_lock(status);
+		break;
 	case SILENT_RESET_CONTROL:
 		pr_info("%s: mdm doing silent reset\n", __func__);
 		mdm_drv->mdm_ram_dump_status = 0;
-		complete(&mdev->mdm_ram_dumps);
+		complete(&mdm_ram_dumps);
+		break;
 	default:
 		pr_err("%s: invalid ioctl cmd = %d\n", __func__, _IOC_NR(cmd));
 		ret = -EINVAL;
 		break;
 	}
+
 	return ret;
 }
 
 static void mdm_status_fn(struct work_struct *work)
 {
-	struct mdm_device *mdev =
-		container_of(work, struct mdm_device, mdm_status_work);
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
 	int value = gpio_get_value(mdm_drv->mdm2ap_status_gpio);
 
 	pr_debug("%s: status:%d\n", __func__, value);
-	if (atomic_read(&mdm_drv->mdm_ready) && mdm_ops->status_cb)
-		mdm_ops->status_cb(mdm_drv, value);
+	if (mdm_drv->mdm_ready && mdm_drv->ops->status_cb)
+		mdm_drv->ops->status_cb(mdm_drv, value);
 
 	/* Update gpio configuration to "running" config. */
-	mdm_update_gpio_configs(mdev, GPIO_UPDATE_RUNNING_CONFIG);
+	mdm_update_gpio_configs(GPIO_UPDATE_RUNNING_CONFIG);
 }
 
-static void mdm_disable_irqs(struct mdm_device *mdev)
+static DECLARE_WORK(mdm_status_work, mdm_status_fn);
+
+static void mdm_disable_irqs(void)
 {
-	if (!mdev)
-		return;
-	disable_irq_nosync(mdev->mdm_errfatal_irq);
-	disable_irq_nosync(mdev->mdm_status_irq);
-	disable_irq_nosync(mdev->mdm_pblrdy_irq);
+	disable_irq_nosync(mdm_drv->mdm_errfatal_irq);
+	disable_irq_nosync(mdm_drv->mdm_status_irq);
 }
 
 static irqreturn_t mdm_errfatal(int irq, void *dev_id)
 {
-	struct mdm_modem_drv *mdm_drv;
-	struct mdm_device *mdev = (struct mdm_device *)dev_id;
-	if (!mdev)
-		return IRQ_HANDLED;
-
-	pr_debug("%s: mdm id %d sent errfatal interrupt\n",
-			 __func__, mdev->mdm_data.device_id);
-	mdm_drv = &mdev->mdm_data;
-	if (atomic_read(&mdm_drv->mdm_ready) &&
+	pr_debug("%s: mdm got errfatal interrupt\n", __func__);
+	if (mdm_drv->mdm_ready &&
 		(gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 1)) {
-		pr_info("%s: Received err fatal from mdm id %d\n",
-				__func__, mdev->mdm_data.device_id);
-		mdm_start_ssr(mdev);
+		pr_info("%s: Reseting the mdm due to an errfatal\n", __func__);
+		mdm_drv->mdm_ready = 0;
+		subsystem_restart_dev(mdm_subsys_dev);
 	}
 	return IRQ_HANDLED;
 }
 
-/* set the mdm_device as the file's private data */
 static int mdm_modem_open(struct inode *inode, struct file *file)
 {
-	struct miscdevice *misc = file->private_data;
-	struct mdm_device *mdev = container_of(misc,
-			struct mdm_device, misc_device);
-
-	file->private_data = mdev;
 	return 0;
 }
 
-static int ssr_notifier_cb(struct notifier_block *this,
-				unsigned long code,
-				void *data)
-{
-	struct mdm_device *mdev =
-		container_of(this, struct mdm_device, ssr_notifier_blk);
-
-	switch (code) {
-	case SUBSYS_AFTER_POWERUP:
-		mdm_ssr_completed(mdev);
-		break;
-	default:
-		break;
-	}
+static const struct file_operations mdm_modem_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mdm_modem_open,
+	.unlocked_ioctl	= mdm_modem_ioctl,
+};
 
-	return NOTIFY_DONE;
-}
+
+static struct miscdevice mdm_modem_misc = {
+	.minor	= MISC_DYNAMIC_MINOR,
+	.name	= "mdm",
+	.fops	= &mdm_modem_fops
+};
 
 static int mdm_panic_prep(struct notifier_block *this,
 				unsigned long event, void *ptr)
 {
 	int i;
-	struct mdm_modem_drv *mdm_drv;
-	struct mdm_device *mdev =
-		container_of(this, struct mdm_device, mdm_panic_blk);
-
-	mdm_drv = &mdev->mdm_data;
 
 	pr_debug("%s: setting AP2MDM_ERRFATAL high for a non graceful reset\n",
 			 __func__);
-	mdm_disable_irqs(mdev);
+	mdm_disable_irqs();
 	gpio_set_value(mdm_drv->ap2mdm_errfatal_gpio, 1);
 
 	for (i = MDM_MODEM_TIMEOUT; i > 0; i -= MDM_MODEM_DELTA) {
@@ -658,71 +442,50 @@
 	if (i <= 0) {
 		pr_err("%s: MDM2AP_STATUS never went low\n", __func__);
 		/* Reset the modem so that it will go into download mode. */
-		if (mdm_drv && mdm_ops->atomic_reset_mdm_cb)
-			mdm_ops->atomic_reset_mdm_cb(mdm_drv);
+		if (mdm_drv && mdm_drv->ops->atomic_reset_mdm_cb)
+			mdm_drv->ops->atomic_reset_mdm_cb(mdm_drv);
 	}
 	return NOTIFY_DONE;
 }
 
+static struct notifier_block mdm_panic_blk = {
+	.notifier_call  = mdm_panic_prep,
+};
+
 static irqreturn_t mdm_status_change(int irq, void *dev_id)
 {
-	struct mdm_modem_drv *mdm_drv;
-	struct mdm_device *mdev = (struct mdm_device *)dev_id;
-	int value;
-	if (!mdev)
-		return IRQ_HANDLED;
-
-	mdm_drv = &mdev->mdm_data;
-	value = gpio_get_value(mdm_drv->mdm2ap_status_gpio);
+	int value = gpio_get_value(mdm_drv->mdm2ap_status_gpio);
 
 	if ((mdm_debug_mask & MDM_DEBUG_MASK_SHDN_LOG) && (value == 0))
 		pr_info("%s: mdm2ap_status went low\n", __func__);
 
-	pr_debug("%s: mdm id %d sent status change interrupt\n",
-			 __func__, mdev->mdm_data.device_id);
-	if (value == 0 && atomic_read(&mdm_drv->mdm_ready)) {
-		pr_info("%s: unexpected reset external modem id %d\n",
-				__func__, mdev->mdm_data.device_id);
+	pr_debug("%s: mdm sent status change interrupt\n", __func__);
+	if (value == 0 && mdm_drv->mdm_ready == 1) {
+		pr_info("%s: unexpected reset external modem\n", __func__);
 		mdm_drv->mdm_unexpected_reset_occurred = 1;
-		mdm_start_ssr(mdev);
+		mdm_drv->mdm_ready = 0;
+		subsystem_restart_dev(mdm_subsys_dev);
 	} else if (value == 1) {
-		cancel_delayed_work(&mdev->mdm2ap_status_check_work);
-		pr_info("%s: status = 1: mdm id %d is now ready\n",
-				__func__, mdev->mdm_data.device_id);
-		queue_work(mdev->mdm_queue, &mdev->mdm_status_work);
+		cancel_delayed_work(&mdm2ap_status_check_work);
+		pr_info("%s: status = 1: mdm is now ready\n", __func__);
+		queue_work(mdm_queue, &mdm_status_work);
 	}
 	return IRQ_HANDLED;
 }
 
 static irqreturn_t mdm_pblrdy_change(int irq, void *dev_id)
 {
-	struct mdm_modem_drv *mdm_drv;
-	struct mdm_device *mdev = (struct mdm_device *)dev_id;
-	if (!mdev)
-		return IRQ_HANDLED;
-
-	mdm_drv = &mdev->mdm_data;
-	pr_info("%s: mdm id %d: pbl ready:%d\n",
-			__func__, mdev->mdm_data.device_id,
+	pr_info("%s: pbl ready:%d\n", __func__,
 			gpio_get_value(mdm_drv->mdm2ap_pblrdy));
+
 	return IRQ_HANDLED;
 }
 
 static int mdm_subsys_shutdown(const struct subsys_desc *crashed_subsys)
 {
-	struct mdm_device *mdev =
-	 container_of(crashed_subsys, struct mdm_device, mdm_subsys);
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
-
-	pr_debug("%s: ssr on modem id %d\n", __func__,
-			 mdev->mdm_data.device_id);
-
-	mdm_ssr_started(mdev);
-	cancel_delayed_work(&mdev->mdm2ap_status_check_work);
-
-	if (!mdm_drv->pdata->no_a2m_errfatal_on_ssr)
-		gpio_direction_output(mdm_drv->ap2mdm_errfatal_gpio, 1);
-
+	mdm_drv->mdm_ready = 0;
+	cancel_delayed_work(&mdm2ap_status_check_work);
+	gpio_direction_output(mdm_drv->ap2mdm_errfatal_gpio, 1);
 	if (mdm_drv->pdata->ramdump_delay_ms > 0) {
 		/* Wait for the external modem to complete
 		 * its preparation for ramdumps.
@@ -730,9 +493,9 @@
 		msleep(mdm_drv->pdata->ramdump_delay_ms);
 	}
 	if (!mdm_drv->mdm_unexpected_reset_occurred) {
-		mdm_ops->reset_mdm_cb(mdm_drv);
+		mdm_drv->ops->reset_mdm_cb(mdm_drv);
 		/* Update gpio configuration to "booting" config. */
-		mdm_update_gpio_configs(mdev, GPIO_UPDATE_BOOTING_CONFIG);
+		mdm_update_gpio_configs(GPIO_UPDATE_BOOTING_CONFIG);
 	} else {
 		mdm_drv->mdm_unexpected_reset_occurred = 0;
 	}
@@ -741,74 +504,59 @@
 
 static int mdm_subsys_powerup(const struct subsys_desc *crashed_subsys)
 {
-	struct mdm_device *mdev =
-		container_of(crashed_subsys, struct mdm_device,
-					 mdm_subsys);
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
-
-	pr_debug("%s: ssr on modem id %d\n",
-			 __func__, mdev->mdm_data.device_id);
-
 	gpio_direction_output(mdm_drv->ap2mdm_errfatal_gpio, 0);
 	gpio_direction_output(mdm_drv->ap2mdm_status_gpio, 1);
-
-	if (mdm_drv->pdata->ps_hold_delay_ms > 0)
-		msleep(mdm_drv->pdata->ps_hold_delay_ms);
-
-	mdm_ops->power_on_mdm_cb(mdm_drv);
+	mdm_drv->ops->power_on_mdm_cb(mdm_drv);
 	mdm_drv->boot_type = CHARM_NORMAL_BOOT;
-	complete(&mdev->mdm_needs_reload);
-	if (!wait_for_completion_timeout(&mdev->mdm_boot,
+	complete(&mdm_needs_reload);
+	if (!wait_for_completion_timeout(&mdm_boot,
 			msecs_to_jiffies(MDM_BOOT_TIMEOUT))) {
 		mdm_drv->mdm_boot_status = -ETIMEDOUT;
 		pr_info("%s: mdm modem restart timed out.\n", __func__);
 	} else {
-		pr_info("%s: id %d: mdm modem has been restarted\n",
-				__func__, mdm_drv->device_id);
+		pr_info("%s: mdm modem has been restarted\n", __func__);
 
 		/* Log the reason for the restart */
 		if (mdm_drv->pdata->sfr_query)
-			queue_work(mdev->mdm_sfr_queue, &mdev->sfr_reason_work);
+			queue_work(mdm_sfr_queue, &sfr_reason_work);
 	}
-	init_completion(&mdev->mdm_boot);
+	INIT_COMPLETION(mdm_boot);
 	return mdm_drv->mdm_boot_status;
 }
 
 static int mdm_subsys_ramdumps(int want_dumps,
 				const struct subsys_desc *crashed_subsys)
 {
-	struct mdm_device *mdev =
-		container_of(crashed_subsys, struct mdm_device,
-					 mdm_subsys);
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
-
-	pr_debug("%s: ssr on modem id %d\n", __func__,
-			 mdev->mdm_data.device_id);
-
 	mdm_drv->mdm_ram_dump_status = 0;
-	cancel_delayed_work(&mdev->mdm2ap_status_check_work);
+	cancel_delayed_work(&mdm2ap_status_check_work);
 	if (want_dumps) {
 		mdm_drv->boot_type = CHARM_RAM_DUMPS;
-		complete(&mdev->mdm_needs_reload);
-		if (!wait_for_completion_timeout(&mdev->mdm_ram_dumps,
-				msecs_to_jiffies(mdev->dump_timeout_ms))) {
+		complete(&mdm_needs_reload);
+		if (!wait_for_completion_timeout(&mdm_ram_dumps,
+				msecs_to_jiffies(dump_timeout_ms))) {
 			mdm_drv->mdm_ram_dump_status = -ETIMEDOUT;
-			pr_err("%s: mdm modem ramdumps timed out.\n",
+			pr_info("%s: mdm modem ramdumps timed out.\n",
 					__func__);
 		} else
 			pr_info("%s: mdm modem ramdumps completed.\n",
 					__func__);
-		init_completion(&mdev->mdm_ram_dumps);
+		INIT_COMPLETION(mdm_ram_dumps);
 		if (!mdm_drv->pdata->no_powerdown_after_ramdumps) {
-			mdm_ops->power_down_mdm_cb(mdm_drv);
+			mdm_drv->ops->power_down_mdm_cb(mdm_drv);
 			/* Update gpio configuration to "booting" config. */
-			mdm_update_gpio_configs(mdev,
-						GPIO_UPDATE_BOOTING_CONFIG);
+			mdm_update_gpio_configs(GPIO_UPDATE_BOOTING_CONFIG);
 		}
 	}
 	return mdm_drv->mdm_ram_dump_status;
 }
 
+static struct subsys_desc mdm_subsystem = {
+	.shutdown = mdm_subsys_shutdown,
+	.ramdump = mdm_subsys_ramdumps,
+	.powerup = mdm_subsys_powerup,
+	.name = EXTERNAL_MODEM,
+};
+
 /* Once the gpios are sent to RPM and debugging
  * starts, there is no way to stop it without
  * rebooting the device.
@@ -822,8 +570,8 @@
 	}
 
 	mdm_debug_mask = val;
-	if (mdm_ops->debug_state_changed_cb)
-		mdm_ops->debug_state_changed_cb(mdm_debug_mask);
+	if (mdm_drv->ops->debug_state_changed_cb)
+		mdm_drv->ops->debug_state_changed_cb(mdm_debug_mask);
 	return 0;
 }
 
@@ -833,10 +581,23 @@
 	return 0;
 }
 
+static int mdm_force_crash_set(void *data, u64 val)
+{
+	pr_info("%s: debugfs\n", __func__);
+
+	mdm_force_crash();
+
+	return 0;
+}
+
 DEFINE_SIMPLE_ATTRIBUTE(mdm_debug_mask_fops,
 			mdm_debug_mask_get,
 			mdm_debug_mask_set, "%llu\n");
 
+DEFINE_SIMPLE_ATTRIBUTE(mdm_force_crash_fops,
+			NULL,
+			mdm_force_crash_set, "%llu\n");
+
 static int mdm_debugfs_init(void)
 {
 	struct dentry *dent;
@@ -845,66 +606,26 @@
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);
 
-	debugfs_create_file("debug_mask", 0644, dent, NULL,
-			&mdm_debug_mask_fops);
+	if (!debugfs_create_file("debug_mask", 0644, dent, NULL,
+			&mdm_debug_mask_fops))
+		goto error;
+
+	if (!debugfs_create_file("force_crash", S_IRUGO | S_IWUSR, dent,
+				NULL, &mdm_force_crash_fops))
+		goto error;
+
 	return 0;
-}
 
-static const struct file_operations mdm_modem_fops = {
-	.owner		= THIS_MODULE,
-	.open		= mdm_modem_open,
-	.unlocked_ioctl	= mdm_modem_ioctl,
-};
+error:
+	debugfs_remove_recursive(dent);
+	return -ENOMEM;
+}
 
-static void mdm_modem_initialize_data(struct platform_device *pdev,
-						struct mdm_device *mdev)
+static void mdm_modem_initialize_data(struct platform_device  *pdev,
+				struct mdm_ops *mdm_ops)
 {
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
 	struct resource *pres;
 
-	mdm_drv->pdata    = pdev->dev.platform_data;
-	if (pdev->id < 0)
-		mdm_drv->device_id   = 0;
-	else
-		mdm_drv->device_id   = pdev->id;
-
-	memset((void *)&mdev->mdm_subsys, 0,
-		   sizeof(struct subsys_desc));
-	if (mdm_drv->pdata->subsys_name) {
-		strlcpy(mdev->subsys_name, mdm_drv->pdata->subsys_name,
-				sizeof(mdev->subsys_name));
-	} else {
-		if (mdev->mdm_data.device_id <= 0)
-			snprintf(mdev->subsys_name, sizeof(mdev->subsys_name),
-				"%s",  EXTERNAL_MODEM);
-		else
-			snprintf(mdev->subsys_name, sizeof(mdev->subsys_name),
-				"%s.%d",  EXTERNAL_MODEM,
-				mdev->mdm_data.device_id);
-	}
-	mdev->mdm_subsys.shutdown = mdm_subsys_shutdown;
-	mdev->mdm_subsys.ramdump = mdm_subsys_ramdumps;
-	mdev->mdm_subsys.powerup = mdm_subsys_powerup;
-	mdev->mdm_subsys.name = mdev->subsys_name;
-
-	memset((void *)&mdev->misc_device, 0,
-		   sizeof(struct miscdevice));
-	if (mdev->mdm_data.device_id <= 0)
-		snprintf(mdev->device_name, sizeof(mdev->device_name),
-			 "%s",  DEVICE_BASE_NAME);
-	else
-		snprintf(mdev->device_name, sizeof(mdev->device_name),
-			 "%s%d",  DEVICE_BASE_NAME, mdev->mdm_data.device_id);
-	mdev->misc_device.minor	= MISC_DYNAMIC_MINOR;
-	mdev->misc_device.name	= mdev->device_name;
-	mdev->misc_device.fops	= &mdm_modem_fops;
-
-	memset((void *)&mdev->mdm_panic_blk, 0,
-		   sizeof(struct notifier_block));
-	mdev->mdm_panic_blk.notifier_call  = mdm_panic_prep;
-	atomic_notifier_chain_register(&panic_notifier_list,
-				   &mdev->mdm_panic_blk);
-
 	/* MDM2AP_ERRFATAL */
 	pres = platform_get_resource_byname(pdev, IORESOURCE_IO,
 							"MDM2AP_ERRFATAL");
@@ -962,49 +683,26 @@
 
 	mdm_drv->boot_type                  = CHARM_NORMAL_BOOT;
 
-	mdev->dump_timeout_ms = mdm_drv->pdata->ramdump_timeout_ms > 0 ?
+	mdm_drv->ops      = mdm_ops;
+	mdm_drv->pdata    = pdev->dev.platform_data;
+	dump_timeout_ms = mdm_drv->pdata->ramdump_timeout_ms > 0 ?
 		mdm_drv->pdata->ramdump_timeout_ms : MDM_RDUMP_TIMEOUT;
-
-	init_completion(&mdev->mdm_needs_reload);
-	init_completion(&mdev->mdm_boot);
-	init_completion(&mdev->mdm_ram_dumps);
-
-	mdev->first_boot = 1;
-	mutex_init(&mdm_drv->peripheral_status_lock);
 }
 
-static void mdm_deconfigure_ipc(struct mdm_device *mdev)
+int mdm_common_create(struct platform_device  *pdev,
+					  struct mdm_ops *p_mdm_cb)
 {
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
-
-	gpio_free(mdm_drv->ap2mdm_status_gpio);
-	gpio_free(mdm_drv->ap2mdm_errfatal_gpio);
-	if (GPIO_IS_VALID(mdm_drv->ap2mdm_kpdpwr_n_gpio))
-		gpio_free(mdm_drv->ap2mdm_kpdpwr_n_gpio);
-	if (GPIO_IS_VALID(mdm_drv->ap2mdm_pmic_pwr_en_gpio))
-		gpio_free(mdm_drv->ap2mdm_pmic_pwr_en_gpio);
-	gpio_free(mdm_drv->mdm2ap_status_gpio);
-	gpio_free(mdm_drv->mdm2ap_errfatal_gpio);
-	if (GPIO_IS_VALID(mdm_drv->ap2mdm_soft_reset_gpio))
-		gpio_free(mdm_drv->ap2mdm_soft_reset_gpio);
-
-	if (GPIO_IS_VALID(mdm_drv->ap2mdm_wakeup_gpio))
-		gpio_free(mdm_drv->ap2mdm_wakeup_gpio);
+	int ret = -1, irq;
 
-	if (mdev->mdm_queue) {
-		destroy_workqueue(mdev->mdm_queue);
-		mdev->mdm_queue = NULL;
-	}
-	if (mdev->mdm_sfr_queue) {
-		destroy_workqueue(mdev->mdm_sfr_queue);
-		mdev->mdm_sfr_queue = NULL;
+	mdm_drv = kzalloc(sizeof(struct mdm_modem_drv), GFP_KERNEL);
+	if (mdm_drv == NULL) {
+		pr_err("%s: kzalloc fail.\n", __func__);
+		goto alloc_err;
 	}
-}
 
-static int mdm_configure_ipc(struct mdm_device *mdev)
-{
-	struct mdm_modem_drv *mdm_drv = &mdev->mdm_data;
-	int ret = -1, irq;
+	mdm_modem_initialize_data(pdev, p_mdm_cb);
+	if (mdm_drv->ops->debug_state_changed_cb)
+		mdm_drv->ops->debug_state_changed_cb(mdm_debug_mask);
 
 	gpio_request(mdm_drv->ap2mdm_status_gpio, "AP2MDM_STATUS");
 	gpio_request(mdm_drv->ap2mdm_errfatal_gpio, "AP2MDM_ERRFATAL");
@@ -1032,7 +730,7 @@
 		}
 	}
 
-	gpio_direction_output(mdm_drv->ap2mdm_status_gpio, 0);
+	gpio_direction_output(mdm_drv->ap2mdm_status_gpio, 1);
 	gpio_direction_output(mdm_drv->ap2mdm_errfatal_gpio, 0);
 
 	if (GPIO_IS_VALID(mdm_drv->ap2mdm_wakeup_gpio))
@@ -1041,92 +739,96 @@
 	gpio_direction_input(mdm_drv->mdm2ap_status_gpio);
 	gpio_direction_input(mdm_drv->mdm2ap_errfatal_gpio);
 
-	mdev->mdm_queue = alloc_workqueue("mdm_queue", 0, 0);
-	if (!mdev->mdm_queue) {
-		pr_err("%s: could not create mdm_queue for mdm id %d\n",
-			   __func__, mdev->mdm_data.device_id);
+	mdm_queue = create_singlethread_workqueue("mdm_queue");
+	if (!mdm_queue) {
+		pr_err("%s: could not create workqueue. All mdm "
+				"functionality will be disabled\n",
+			__func__);
 		ret = -ENOMEM;
 		goto fatal_err;
 	}
 
-	mdev->mdm_sfr_queue = alloc_workqueue("mdm_sfr_queue", 0, 0);
-	if (!mdev->mdm_sfr_queue) {
-		pr_err("%s: could not create mdm_sfr_queue for mdm id %d\n",
-			   __func__, mdev->mdm_data.device_id);
+	mdm_sfr_queue = alloc_workqueue("mdm_sfr_queue", 0, 0);
+	if (!mdm_sfr_queue) {
+		pr_err("%s: could not create workqueue mdm_sfr_queue."
+			" All mdm functionality will be disabled\n",
+			__func__);
 		ret = -ENOMEM;
+		destroy_workqueue(mdm_queue);
 		goto fatal_err;
 	}
 
+	atomic_notifier_chain_register(&panic_notifier_list, &mdm_panic_blk);
+	mdm_debugfs_init();
+
 	/* Register subsystem handlers */
-	mdev->mdm_subsys_dev = subsys_register(&mdev->mdm_subsys);
-	if (IS_ERR(mdev->mdm_subsys_dev)) {
-		ret = PTR_ERR(mdev->mdm_subsys_dev);
+	mdm_subsys_dev = subsys_register(&mdm_subsystem);
+	if (IS_ERR(mdm_subsys_dev)) {
+		ret = PTR_ERR(mdm_subsys_dev);
 		goto fatal_err;
 	}
-	memset((void *)&mdev->ssr_notifier_blk, 0,
-			sizeof(struct notifier_block));
-	mdev->ssr_notifier_blk.notifier_call  = ssr_notifier_cb;
-	subsys_notif_register_notifier(mdev->subsys_name,
-			&mdev->ssr_notifier_blk);
 
 	/* ERR_FATAL irq. */
 	irq = MSM_GPIO_TO_INT(mdm_drv->mdm2ap_errfatal_gpio);
 	if (irq < 0) {
-		pr_err("%s: bad MDM2AP_ERRFATAL IRQ resource, err = %d\n",
-			   __func__, irq);
+		pr_err("%s: could not get MDM2AP_ERRFATAL IRQ resource. "
+			"error=%d No IRQ will be generated on errfatal.",
+			__func__, irq);
 		goto errfatal_err;
 	}
 	ret = request_irq(irq, mdm_errfatal,
-			IRQF_TRIGGER_RISING , "mdm errfatal", mdev);
+		IRQF_TRIGGER_RISING , "mdm errfatal", NULL);
 
 	if (ret < 0) {
-		pr_err("%s: MDM2AP_ERRFATAL IRQ#%d request failed, err=%d\n",
-					__func__, irq, ret);
+		pr_err("%s: MDM2AP_ERRFATAL IRQ#%d request failed with error=%d"
+			". No IRQ will be generated on errfatal.",
+			__func__, irq, ret);
 		goto errfatal_err;
 	}
-	mdev->mdm_errfatal_irq = irq;
+	mdm_drv->mdm_errfatal_irq = irq;
 
 errfatal_err:
 
-	 /* status irq */
+	/* status irq */
 	irq = MSM_GPIO_TO_INT(mdm_drv->mdm2ap_status_gpio);
 	if (irq < 0) {
-		pr_err("%s: bad MDM2AP_STATUS IRQ resource, err = %d\n",
-				__func__, irq);
+		pr_err("%s: could not get MDM2AP_STATUS IRQ resource. "
+			"error=%d No IRQ will be generated on status change.",
+			__func__, irq);
 		goto status_err;
 	}
 
 	ret = request_threaded_irq(irq, NULL, mdm_status_change,
 		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_SHARED,
-		"mdm status", mdev);
+		"mdm status", mdm_drv);
 
 	if (ret < 0) {
-		pr_err("%s: MDM2AP_STATUS IRQ#%d request failed, err=%d",
-			 __func__, irq, ret);
+		pr_err("%s: MDM2AP_STATUS IRQ#%d request failed with error=%d"
+			". No IRQ will be generated on status change.",
+			__func__, irq, ret);
 		goto status_err;
 	}
-	mdev->mdm_status_irq = irq;
+	mdm_drv->mdm_status_irq = irq;
 
 status_err:
 	if (GPIO_IS_VALID(mdm_drv->mdm2ap_pblrdy)) {
 		irq = MSM_GPIO_TO_INT(mdm_drv->mdm2ap_pblrdy);
 		if (irq < 0) {
-			pr_err("%s: could not get MDM2AP_PBLRDY IRQ resource\n",
-				 __func__);
+			pr_err("%s: could not get MDM2AP_PBLRDY IRQ resource",
+				__func__);
 			goto pblrdy_err;
 		}
 
 		ret = request_threaded_irq(irq, NULL, mdm_pblrdy_change,
-				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-				IRQF_SHARED,
-				"mdm pbl ready", mdev);
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+			IRQF_SHARED,
+			"mdm pbl ready", mdm_drv);
 
 		if (ret < 0) {
-			pr_err("%s: MDM2AP_PBL IRQ#%d request failed error=%d\n",
+			pr_err("%s: MDM2AP_PBL IRQ#%d request failed error=%d",
 				__func__, irq, ret);
 			goto pblrdy_err;
 		}
-		mdev->mdm_pblrdy_irq = irq;
 	}
 
 pblrdy_err:
@@ -1137,139 +839,67 @@
 	if (GPIO_IS_VALID(mdm_drv->ap2mdm_pmic_pwr_en_gpio))
 		gpio_direction_output(mdm_drv->ap2mdm_pmic_pwr_en_gpio, 1);
 
-	return 0;
-
-fatal_err:
-	mdm_deconfigure_ipc(mdev);
-	return ret;
-}
-
-static int __devinit mdm_modem_probe(struct platform_device *pdev)
-{
-	struct mdm_device *mdev = NULL;
-	int ret = -1;
-
-	mdev = kzalloc(sizeof(struct mdm_device), GFP_KERNEL);
-	if (!mdev) {
-		pr_err("%s: kzalloc fail.\n", __func__);
-		ret = -ENOMEM;
-		goto init_err;
-	}
-
-	platform_set_drvdata(pdev, mdev);
-	mdm_modem_initialize_data(pdev, mdev);
-
-	if (mdm_ops->debug_state_changed_cb)
-		mdm_ops->debug_state_changed_cb(mdm_debug_mask);
-
-	if (mdm_configure_ipc(mdev)) {
-		pr_err("%s: mdm_configure_ipc failed, id = %d\n",
-			   __func__, mdev->mdm_data.device_id);
-		goto init_err;
-	}
+	/* Perform early powerup of the external modem in order to
+	 * allow tabla devices to be found.
+	 */
+	if (mdm_drv->pdata->early_power_on)
+		mdm_drv->ops->power_on_mdm_cb(mdm_drv);
 
-	pr_debug("%s: Registering mdm id %d\n", __func__,
-			mdev->mdm_data.device_id);
-	ret = misc_register(&mdev->misc_device);
-	if (ret) {
-		pr_err("%s: failed registering mdm id %d, ret = %d\n",
-			   __func__, mdev->mdm_data.device_id, ret);
-		mdm_deconfigure_ipc(mdev);
-		goto init_err;
-	} else {
-		pr_err("%s: registered mdm id %d\n",
-			   __func__, mdev->mdm_data.device_id);
+	pr_info("%s: Registering mdm modem\n", __func__);
+	return misc_register(&mdm_modem_misc);
 
-		mdm_device_list_add(mdev);
-		INIT_DELAYED_WORK(&mdev->mdm2ap_status_check_work,
-					mdm2ap_status_check);
-		INIT_WORK(&mdev->mdm_status_work, mdm_status_fn);
-		INIT_WORK(&mdev->sfr_reason_work, mdm_restart_reason_fn);
+fatal_err:
+	gpio_free(mdm_drv->ap2mdm_status_gpio);
+	gpio_free(mdm_drv->ap2mdm_errfatal_gpio);
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_kpdpwr_n_gpio))
+		gpio_free(mdm_drv->ap2mdm_kpdpwr_n_gpio);
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_pmic_pwr_en_gpio))
+		gpio_free(mdm_drv->ap2mdm_pmic_pwr_en_gpio);
+	gpio_free(mdm_drv->mdm2ap_status_gpio);
+	gpio_free(mdm_drv->mdm2ap_errfatal_gpio);
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_soft_reset_gpio))
+		gpio_free(mdm_drv->ap2mdm_soft_reset_gpio);
 
-		/* Perform early powerup of the external modem in order to
-		 * allow tabla devices to be found.
-		 */
-		if (mdev->mdm_data.pdata->early_power_on)
-			mdm_ops->power_on_mdm_cb(&mdev->mdm_data);
-	}
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_wakeup_gpio))
+		gpio_free(mdm_drv->ap2mdm_wakeup_gpio);
 
-	return ret;
+	kfree(mdm_drv);
+	ret = -ENODEV;
 
-init_err:
-	kfree(mdev);
+alloc_err:
 	return ret;
 }
 
-static int __devexit mdm_modem_remove(struct platform_device *pdev)
+int mdm_common_modem_remove(struct platform_device *pdev)
 {
 	int ret;
-	struct mdm_device *mdev = platform_get_drvdata(pdev);
-
-	pr_debug("%s: removing device id %d\n",
-			__func__, mdev->mdm_data.device_id);
-	mdm_deconfigure_ipc(mdev);
-	ret = misc_deregister(&mdev->misc_device);
-	mdm_device_list_remove(mdev);
-	kfree(mdev);
-	return ret;
-}
-
-static void mdm_modem_shutdown(struct platform_device *pdev)
-{
-	struct mdm_modem_drv *mdm_drv;
-	struct mdm_device *mdev = platform_get_drvdata(pdev);
-
-	pr_debug("%s: shutting down device id %d\n",
-		 __func__, mdev->mdm_data.device_id);
 
-	mdm_disable_irqs(mdev);
-	mdm_drv = &mdev->mdm_data;
-	mdm_ops->power_down_mdm_cb(mdm_drv);
+	gpio_free(mdm_drv->ap2mdm_status_gpio);
+	gpio_free(mdm_drv->ap2mdm_errfatal_gpio);
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_kpdpwr_n_gpio))
+		gpio_free(mdm_drv->ap2mdm_kpdpwr_n_gpio);
 	if (GPIO_IS_VALID(mdm_drv->ap2mdm_pmic_pwr_en_gpio))
-		gpio_direction_output(mdm_drv->ap2mdm_pmic_pwr_en_gpio, 0);
-}
-
-static struct of_device_id mdm_match_table[] = {
-	{.compatible = "qcom,mdm2_modem,mdm2_modem.1"},
-	{},
-};
+		gpio_free(mdm_drv->ap2mdm_pmic_pwr_en_gpio);
+	gpio_free(mdm_drv->mdm2ap_status_gpio);
+	gpio_free(mdm_drv->mdm2ap_errfatal_gpio);
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_soft_reset_gpio))
+		gpio_free(mdm_drv->ap2mdm_soft_reset_gpio);
 
-static struct platform_driver mdm_modem_driver = {
-	.probe    = mdm_modem_probe,
-	.remove   = __devexit_p(mdm_modem_remove),
-	.shutdown = mdm_modem_shutdown,
-	.driver         = {
-		.name = "mdm2_modem",
-		.owner = THIS_MODULE,
-		.of_match_table = mdm_match_table,
-	},
-};
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_wakeup_gpio))
+		gpio_free(mdm_drv->ap2mdm_wakeup_gpio);
 
-static int __init mdm_modem_init(void)
-{
-	int ret;
-#ifdef CONFIG_SAMSUNG_LPM_MODE
-	if (poweroff_charging)
-		return 0;
-#endif
-	ret = mdm_get_ops(&mdm_ops);
-	if (ret)
-		return ret;
+	kfree(mdm_drv);
 
-	INIT_LIST_HEAD(&mdm_devices);
-	mdm_debugfs_init();
-	return platform_driver_register(&mdm_modem_driver);
+	ret = misc_deregister(&mdm_modem_misc);
+	return ret;
 }
 
-static void __exit mdm_modem_exit(void)
+void mdm_common_modem_shutdown(struct platform_device *pdev)
 {
-	platform_driver_unregister(&mdm_modem_driver);
-}
+	mdm_disable_irqs();
 
-module_init(mdm_modem_init);
-module_exit(mdm_modem_exit);
+	mdm_drv->ops->power_down_mdm_cb(mdm_drv);
+	if (GPIO_IS_VALID(mdm_drv->ap2mdm_pmic_pwr_en_gpio))
+		gpio_direction_output(mdm_drv->ap2mdm_pmic_pwr_en_gpio, 0);
+}
 
-MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("mdm modem driver");
-MODULE_VERSION("2.0");
-MODULE_ALIAS("mdm_modem");
diff --unified -r mach-msm/mdm_private.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/mdm_private.h
--- mach-msm/mdm_private.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/mdm_private.h	2013-12-17 17:08:05.650151095 -0800
@@ -48,21 +48,25 @@
 	unsigned mdm2ap_pblrdy;
 	unsigned usb_switch_gpio;
 
-	atomic_t mdm_ready;
+	int mdm_errfatal_irq;
+	int mdm_status_irq;
+	int mdm_ready;
 	int mdm_boot_status;
 	int mdm_ram_dump_status;
 	enum charm_boot_type boot_type;
 	int mdm_debug_on;
 	int mdm_unexpected_reset_occurred;
 	int disable_status_check;
-	int power_on_count;
-	int peripheral_status;
-	struct mutex peripheral_status_lock;
-	int device_id;
 
+	struct mdm_ops *ops;
 	struct mdm_platform_data *pdata;
 };
-int mdm_get_ops(struct mdm_ops **mdm_ops);
+
+int mdm_common_create(struct platform_device  *pdev,
+					  struct mdm_ops *mdm_cb);
+int mdm_common_modem_remove(struct platform_device *pdev);
+void mdm_common_modem_shutdown(struct platform_device *pdev);
+void mdm_common_set_debug_state(int value);
 
 #endif
 
diff --unified -r mach-msm/memory.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/memory.c
--- mach-msm/memory.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/memory.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,7 +1,7 @@
 /* arch/arm/mach-msm/memory.c
  *
  * Copyright (C) 2007 Google, Inc.
- * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/memory_alloc.h>
 #include <linux/memblock.h>
+#include <asm/memblock.h>
 #include <asm/pgtable.h>
 #include <asm/io.h>
 #include <asm/mach/map.h>
@@ -27,13 +28,13 @@
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <mach/msm_memtypes.h>
+#include <mach/memory.h>
 #include <linux/hardirq.h>
 #if defined(CONFIG_MSM_NPA_REMOTE)
 #include "npa_remote.h"
 #include <linux/completion.h>
 #include <linux/err.h>
 #endif
-#include <linux/android_pmem.h>
 #include <mach/msm_iomap.h>
 #include <mach/socinfo.h>
 #include <linux/sched.h>
@@ -113,34 +114,6 @@
 	outer_inv_range(pstart, pstart + length);
 }
 
-void * __init alloc_bootmem_aligned(unsigned long size, unsigned long alignment)
-{
-	void *unused_addr = NULL;
-	unsigned long addr, tmp_size, unused_size;
-
-	/* Allocate maximum size needed, see where it ends up.
-	 * Then free it -- in this path there are no other allocators
-	 * so we can depend on getting the same address back
-	 * when we allocate a smaller piece that is aligned
-	 * at the end (if necessary) and the piece we really want,
-	 * then free the unused first piece.
-	 */
-
-	tmp_size = size + alignment - PAGE_SIZE;
-	addr = (unsigned long)alloc_bootmem(tmp_size);
-	free_bootmem(__pa(addr), tmp_size);
-
-	unused_size = alignment - (addr % alignment);
-	if (unused_size)
-		unused_addr = alloc_bootmem(unused_size);
-
-	addr = (unsigned long)alloc_bootmem(size);
-	if (unused_size)
-		free_bootmem(__pa(unused_addr), unused_size);
-
-	return (void *)addr;
-}
-
 char *memtype_name[] = {
 	"SMI_KERNEL",
 	"SMI",
@@ -150,63 +123,29 @@
 
 struct reserve_info *reserve_info;
 
-static unsigned long stable_size(struct membank *mb,
-	unsigned long unstable_limit)
-{
-	unsigned long upper_limit = mb->start + mb->size;
-
-	if (!unstable_limit)
-		return mb->size;
-
-	/* Check for 32 bit roll-over */
-	if (upper_limit >= mb->start) {
-		/* If we didn't roll over we can safely make the check below */
-		if (upper_limit <= unstable_limit)
-			return mb->size;
-	}
-
-	if (mb->start >= unstable_limit)
-		return 0;
-	return unstable_limit - mb->start;
-}
-
-/* stable size of all memory banks contiguous to and below this one */
-static unsigned long total_stable_size(unsigned long bank)
-{
-	int i;
-	struct membank *mb = &meminfo.bank[bank];
-	int memtype = reserve_info->paddr_to_memtype(mb->start);
-	unsigned long size;
-
-	size = stable_size(mb, reserve_info->low_unstable_address);
-	for (i = bank - 1, mb = &meminfo.bank[bank - 1]; i >= 0; i--, mb--) {
-		if (mb->start + mb->size != (mb + 1)->start)
-			break;
-		if (reserve_info->paddr_to_memtype(mb->start) != memtype)
-			break;
-		size += stable_size(mb, reserve_info->low_unstable_address);
-	}
-	return size;
-}
-
+/**
+ * calculate_reserve_limits() - calculate reserve limits for all
+ * memtypes
+ *
+ * for each memtype in the reserve_info->memtype_reserve_table, sets
+ * the `limit' field to the largest size of any memblock of that
+ * memtype.
+ */
 static void __init calculate_reserve_limits(void)
 {
-	int i;
-	struct membank *mb;
+	struct memblock_region *mr;
 	int memtype;
 	struct memtype_reserve *mt;
-	unsigned long size;
 
-	for (i = 0, mb = &meminfo.bank[0]; i < meminfo.nr_banks; i++, mb++)  {
-		memtype = reserve_info->paddr_to_memtype(mb->start);
+	for_each_memblock(memory, mr) {
+		memtype = reserve_info->paddr_to_memtype(mr->base);
 		if (memtype == MEMTYPE_NONE) {
-			pr_warning("unknown memory type for bank at %lx\n",
-				(long unsigned int)mb->start);
+			pr_warning("unknown memory type for region at %lx\n",
+				(long unsigned int)mr->base);
 			continue;
 		}
 		mt = &reserve_info->memtype_reserve_table[memtype];
-		size = total_stable_size(i);
-		mt->limit = max(mt->limit, size);
+		mt->limit = max_t(unsigned long, mt->limit, mr->size);
 	}
 }
 
@@ -229,50 +168,18 @@
 
 static void __init reserve_memory_for_mempools(void)
 {
-	int i, memtype, membank_type;
+	int memtype;
 	struct memtype_reserve *mt;
-	struct membank *mb;
-	int ret;
-	unsigned long size;
+	phys_addr_t alignment;
 
 	mt = &reserve_info->memtype_reserve_table[0];
 	for (memtype = 0; memtype < MEMTYPE_MAX; memtype++, mt++) {
 		if (mt->flags & MEMTYPE_FLAGS_FIXED || !mt->size)
 			continue;
-
-		/* We know we will find memory bank(s) of the proper size
-		 * as we have limited the size of the memory pool for
-		 * each memory type to the largest total size of the memory
-		 * banks which are contiguous and of the correct memory type.
-		 * Choose the memory bank with the highest physical
-		 * address which is large enough, so that we will not
-		 * take memory from the lowest memory bank which the kernel
-		 * is in (and cause boot problems) and so that we might
-		 * be able to steal memory that would otherwise become
-		 * highmem. However, do not use unstable memory.
-		 */
-		for (i = meminfo.nr_banks - 1; i >= 0; i--) {
-			mb = &meminfo.bank[i];
-			membank_type =
-				reserve_info->paddr_to_memtype(mb->start);
-			if (memtype != membank_type)
-				continue;
-			size = total_stable_size(i);
-			if (size >= mt->size) {
-				size = stable_size(mb,
-					reserve_info->low_unstable_address);
-				if (!size)
-					continue;
-				/* mt->size may be larger than size, all this
-				 * means is that we are carving the memory pool
-				 * out of multiple contiguous memory banks.
-				 */
-				mt->start = mb->start + (size - mt->size);
-				ret = memblock_remove(mt->start, mt->size);
-				BUG_ON(ret);
-				break;
-			}
-		}
+		alignment = (mt->flags & MEMTYPE_FLAGS_1M_ALIGN) ?
+			SZ_1M : PAGE_SIZE;
+		mt->start = arm_memblock_steal(mt->size, alignment);
+		BUG_ON(!mt->start);
 	}
 }
 
@@ -394,7 +301,7 @@
 	return ret;
 }
 
-static int check_for_compat(unsigned long node)
+static int __init check_for_compat(unsigned long node)
 {
 	char **start = __compat_exports_start;
 
@@ -483,6 +390,90 @@
 	return 0;
 }
 
+/* Function to remove any meminfo blocks which are of size zero */
+static void merge_meminfo(void)
+{
+	int i = 0;
+
+	while (i < meminfo.nr_banks) {
+		struct membank *bank = &meminfo.bank[i];
+
+		if (bank->size == 0) {
+			memmove(bank, bank + 1,
+			(meminfo.nr_banks - i) * sizeof(*bank));
+			meminfo.nr_banks--;
+			continue;
+		}
+		i++;
+	}
+}
+
+/*
+ * Function to scan the device tree and adjust the meminfo table to
+ * reflect the memory holes.
+ */
+int __init dt_scan_for_memory_hole(unsigned long node, const char *uname,
+		int depth, void *data)
+{
+	unsigned int *memory_remove_prop;
+	unsigned long memory_remove_prop_length;
+	unsigned long hole_start;
+	unsigned long hole_size;
+
+	memory_remove_prop = of_get_flat_dt_prop(node,
+						"qcom,memblock-remove",
+						&memory_remove_prop_length);
+
+	if (memory_remove_prop) {
+		if (!check_for_compat(node))
+			goto out;
+	} else {
+		goto out;
+	}
+
+	if (memory_remove_prop) {
+		if (memory_remove_prop_length != (2*sizeof(unsigned int))) {
+			WARN(1, "Memory remove malformed\n");
+			goto out;
+		}
+
+		hole_start = be32_to_cpu(memory_remove_prop[0]);
+		hole_size = be32_to_cpu(memory_remove_prop[1]);
+
+		adjust_meminfo(hole_start, hole_size);
+	}
+
+out:
+	return 0;
+}
+
+/*
+ * Split the memory bank to reflect the hole, if present,
+ * using the start and end of the memory hole.
+ */
+void adjust_meminfo(unsigned long start, unsigned long size)
+{
+	int i;
+
+	for (i = 0; i < meminfo.nr_banks; i++) {
+		struct membank *bank = &meminfo.bank[i];
+
+		if (((start + size) <= (bank->start + bank->size)) &&
+			(start >= bank->start)) {
+			memmove(bank + 1, bank,
+				(meminfo.nr_banks - i) * sizeof(*bank));
+			meminfo.nr_banks++;
+			i++;
+
+			bank->size = start - bank->start;
+			bank[1].start = (start + size);
+			bank[1].size -= (bank->size + size);
+			bank[1].highmem = 0;
+			merge_meminfo();
+		}
+	}
+}
+
 unsigned long get_ddr_size(void)
 {
 	unsigned int i;
diff --unified -r mach-msm/msm_bus/msm_bus_arb.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_bus/msm_bus_arb.c
--- mach-msm/msm_bus/msm_bus_arb.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_bus/msm_bus_arb.c	2013-12-17 17:08:05.650151095 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -462,7 +462,7 @@
 	deffab = msm_bus_get_fabric_device(MSM_BUS_FAB_DEFAULT);
 	if (!deffab) {
 		MSM_BUS_ERR("Error finding default fabric\n");
-		return 0;
+		return -ENXIO;
 	}
 
 	nfab = msm_bus_get_num_fab();
@@ -574,10 +574,6 @@
 
 	curr = client->curr;
 	pdata = client->pdata;
-	if (!pdata) {
-		MSM_BUS_ERR("Null pdata passed to update-request\n");
-		return -ENXIO;
-	}
 
 	if (index >= pdata->num_usecases) {
 		MSM_BUS_ERR("Client %u passed invalid index: %d\n",
@@ -722,7 +718,7 @@
 {
 	int i, src, pnode, index;
 	struct msm_bus_client *client = (struct msm_bus_client *)(cl);
-	if (IS_ERR_OR_NULL(client)) {
+	if (IS_ERR(client)) {
 		MSM_BUS_ERR("msm_bus_scale_reset_pnodes error\n");
 		return;
 	}
@@ -743,7 +739,7 @@
 void msm_bus_scale_unregister_client(uint32_t cl)
 {
 	struct msm_bus_client *client = (struct msm_bus_client *)(cl);
-	if (IS_ERR_OR_NULL(client))
+	if (IS_ERR(client) || (!client))
 		return;
 	if (client->curr != 0)
 		msm_bus_scale_client_update_request(cl, 0);
diff --unified -r mach-msm/msm_bus/msm_bus_core.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_bus/msm_bus_core.h
--- mach-msm/msm_bus/msm_bus_core.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_bus/msm_bus_core.h	2013-12-17 17:08:05.650151095 -0800
@@ -35,13 +35,8 @@
 #define IS_SLAVE_VALID(slv) \
 	(((slv >= MSM_BUS_SLAVE_FIRST) && (slv <= MSM_BUS_SLAVE_LAST)) ? 1 : 0)
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
-#define INTERLEAVED_BW(fab_pdata, bw, ports) \
-	((fab_pdata->il_flag) ? msm_bus_div64((ports), (bw)) : (bw))//((bw), (ports)) : (bw))
-#else
 #define INTERLEAVED_BW(fab_pdata, bw, ports) \
 	((fab_pdata->il_flag) ? msm_bus_div64((ports), (bw)) : (bw))
-#endif
 #define INTERLEAVED_VAL(fab_pdata, n) \
 	((fab_pdata->il_flag) ? (n) : 1)
 
diff --unified -r mach-msm/msm_dcvs.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_dcvs.c
--- mach-msm/msm_dcvs.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_dcvs.c	2013-12-17 17:08:05.654151088 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1026,9 +1026,6 @@
 	uint32_t ret1;
 	uint32_t ret2;
 
-	if (!msm_dcvs_enabled)
-		return ret;
-
 	offset = get_core_offset(type, type_core_num);
 	if (offset < 0)
 		return ret;
@@ -1280,9 +1277,6 @@
 	struct kobject *module_kobj = NULL;
 	int ret = 0;
 
-	if (!msm_dcvs_enabled)
-		return ret;
-
 	module_kobj = kset_find_obj(module_kset, KBUILD_MODNAME);
 	if (!module_kobj) {
 		pr_err("%s: cannot find kobject for module %s\n",
@@ -1349,7 +1343,6 @@
 	ret = msm_dcvs_scm_init(SZ_32K);
 	if (ret) {
 		__err("Unable to initialize DCVS err=%d\n", ret);
-		msm_dcvs_enabled = 0;
 		goto done;
 	}
 
Only in mach-msm: msm_ipc_router_security.c
Only in mach-msm: msm_ipc_router_security.h
diff --unified -r mach-msm/msm_rq_stats.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_rq_stats.c
--- mach-msm/msm_rq_stats.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_rq_stats.c	2013-12-17 17:08:05.654151088 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -30,6 +30,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/tick.h>
 #include <asm/smp_plat.h>
+#include "acpuclock.h"
 #include <linux/suspend.h>
 
 #define MAX_LONG_SIZE 24
@@ -198,6 +199,8 @@
 
 	switch (val) {
 	case CPU_ONLINE:
+		if (!this_cpu->cur_freq)
+			this_cpu->cur_freq = acpuclk_get_rate(cpu);
 	case CPU_ONLINE_FROZEN:
 		this_cpu->avg_load_maxfreq = 0;
 	}
@@ -414,10 +417,8 @@
 		mutex_init(&pcpu->cpu_load_mutex);
 		cpufreq_get_policy(&cpu_policy, i);
 		pcpu->policy_max = cpu_policy.cpuinfo.max_freq;
-#ifdef CONFIG_MACH_JF
-		/* This is initial frequency */
-		pcpu->cur_freq = 1566000;
-#endif
+		if (cpu_online(i))
+			pcpu->cur_freq = acpuclk_get_rate(i);
 		cpumask_copy(pcpu->related_cpus, cpu_policy.cpus);
 	}
 	freq_transition.notifier_call = cpufreq_transition_handler;
diff --unified -r mach-msm/msm_watchdog.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_watchdog.c
--- mach-msm/msm_watchdog.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/msm_watchdog.c	2013-12-17 17:08:05.654151088 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,7 +23,6 @@
 #include <linux/suspend.h>
 #include <linux/percpu.h>
 #include <linux/interrupt.h>
-#include <linux/reboot.h>
 #include <asm/fiq.h>
 #include <asm/hardware/gic.h>
 #include <mach/msm_iomap.h>
@@ -65,12 +64,6 @@
 module_param(enable, int, 0);
 
 /*
- * Watchdog bark reboot timeout in seconds.
- * Can be specified in kernel command line.
- */
-static int reboot_bark_timeout = 22;
-module_param(reboot_bark_timeout, int, 0644);
-/*
  * If the watchdog is enabled at bootup (enable=1),
  * the runtime_disable sysfs node at
  * /sys/module/msm_watchdog/runtime_disable
@@ -91,7 +84,7 @@
 static int appsbark;
 module_param(appsbark, int, 0);
 
-#if CONFIG_SEC_DEBUG
+#ifdef CONFIG_SEC_DEBUG
 static unsigned int regsave_vaddr;
 static unsigned int regsave_paddr;
 #endif
@@ -165,27 +158,6 @@
 	.notifier_call	= panic_wdog_handler,
 };
 
-#define get_sclk_hz(t_ms) ((t_ms / 1000) * WDT_HZ)
-#define get_reboot_bark_timeout(t_s) ((t_s * MSEC_PER_SEC) < bark_time ? \
-		get_sclk_hz(bark_time) : get_sclk_hz(t_s * MSEC_PER_SEC))
-
-static int msm_watchdog_reboot_notifier(struct notifier_block *this,
-		unsigned long code, void *unused)
-{
-
-	u64 timeout = get_reboot_bark_timeout(reboot_bark_timeout);
-	__raw_writel(timeout, msm_wdt_base + WDT_BARK_TIME);
-	__raw_writel(timeout + 3 * WDT_HZ,
-			msm_wdt_base + WDT_BITE_TIME);
-	__raw_writel(1, msm_wdt_base + WDT_RST);
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block msm_reboot_notifier = {
-	.notifier_call = msm_watchdog_reboot_notifier,
-};
-
 struct wdog_disable_work_data {
 	struct work_struct work;
 	struct completion complete;
@@ -209,7 +181,6 @@
 	}
 	enable = 0;
 	atomic_notifier_chain_unregister(&panic_notifier_list, &panic_blk);
-	unregister_reboot_notifier(&msm_reboot_notifier);
 	cancel_delayed_work(&dogwork_struct);
 	/* may be suspended after the first write above */
 	__raw_writel(0, msm_wdt_base + WDT_EN);
@@ -250,7 +221,7 @@
 	return ret;
 }
 
-#if CONFIG_SEC_DEBUG
+#ifdef CONFIG_SEC_DEBUG
 static unsigned long long last_emerg_pet;
 void emerg_pet_watchdog(void)
 {
@@ -328,7 +299,7 @@
 	return IRQ_HANDLED;
 }
 
-#if CONFIG_SEC_DEBUG
+#ifdef CONFIG_SEC_DEBUG
 unsigned int get_wdog_regsave_paddr(void)
 {
 	return __pa(&regsave_paddr);
@@ -350,7 +321,7 @@
 
 	if (!appsbark) {
 		scm_regsave = (void *)__get_free_page(GFP_KERNEL);
-#if CONFIG_SEC_DEBUG
+#ifdef CONFIG_SEC_DEBUG
 		printk(KERN_INFO "WDOG handled by TZ:dump @0x%08x PA:%08x\n",
 				(unsigned int) scm_regsave,
 				(unsigned int) __pa(scm_regsave));
@@ -434,10 +405,6 @@
 	atomic_notifier_chain_register(&panic_notifier_list,
 				       &panic_blk);
 
-	ret = register_reboot_notifier(&msm_reboot_notifier);
-	if (ret)
-		pr_err("Failed to register reboot notifier\n");
-
 	__raw_writel(1, msm_wdt_base + WDT_EN);
 	__raw_writel(1, msm_wdt_base + WDT_RST);
 	last_pet = sched_clock();
@@ -460,11 +427,6 @@
 	}
 
 	bark_time = pdata->bark_time;
-	/* reboot_bark_timeout (in seconds) might have been supplied as
-	 * module parameter.
-	 */
-	if ((reboot_bark_timeout * MSEC_PER_SEC) < bark_time)
-		reboot_bark_timeout = (bark_time / MSEC_PER_SEC);
 	has_vic = pdata->has_vic;
 	if (!pdata->has_secure) {
 		appsbark = 1;
diff --unified -r mach-msm/nohlt.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/nohlt.c
--- mach-msm/nohlt.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/nohlt.c	2013-12-17 17:08:05.654151088 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009, 2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -28,11 +28,18 @@
 	return 0;
 }
 
-DEFINE_SIMPLE_ATTRIBUTE(nohalt_ops, NULL, set_nohalt, "%llu\n");
+static int get_nohalt(void *data, u64 *val)
+{
+	*val = (unsigned int)get_hlt();
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nohalt_ops, get_nohalt, set_nohalt, "%llu\n");
 
 static int __init init_hlt_debug(void)
 {
-	debugfs_create_file("nohlt", 0200, NULL, NULL, &nohalt_ops);
+	debugfs_create_file("nohlt", 0600, NULL, NULL, &nohalt_ops);
 
 	return 0;
 }
diff --unified -r mach-msm/perf_event_msm_krait_l2.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/perf_event_msm_krait_l2.c
--- mach-msm/perf_event_msm_krait_l2.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/perf_event_msm_krait_l2.c	2013-12-17 17:08:05.654151088 -0800
@@ -72,11 +72,9 @@
  */
 struct pmu_constraints {
 	u64 pmu_bitmap;
-	u8 codes[64];
 	raw_spinlock_t lock;
 } l2_pmu_constraints = {
 	.pmu_bitmap = 0,
-	.codes = {-1},
 	.lock = __RAW_SPIN_LOCK_UNLOCKED(l2_pmu_constraints.lock),
 };
 
@@ -337,10 +335,8 @@
 	int ctr = 0;
 
 	if (hwc->config_base == L2CYCLE_CTR_RAW_CODE) {
-		if (test_and_set_bit(l2_cycle_ctr_idx, cpuc->used_mask))
-			return -EAGAIN;
-
-		return l2_cycle_ctr_idx;
+		if (!test_and_set_bit(l2_cycle_ctr_idx, cpuc->used_mask))
+			return l2_cycle_ctr_idx;
 	}
 
 	for (ctr = 0; ctr < total_l2_ctrs - 1; ctr++) {
@@ -457,48 +453,22 @@
 {
 	u32 evt_type = event->attr.config & L2_EVT_MASK;
 	u8 reg   = (evt_type & 0x0F000) >> 12;
-	u8 group = evt_type & 0x0000F;
-	u8 code = (evt_type & 0x00FF0) >> 4;
+	u8 group =  evt_type & 0x0000F;
 	unsigned long flags;
 	u32 err = 0;
 	u64 bitmap_t;
-	u32 shift_idx;
-
-	/*
-	 * Cycle counter collision is detected in
-	 * get_event_idx().
-	 */
-	if (evt_type == L2CYCLE_CTR_RAW_CODE)
-		return err;
 
 	raw_spin_lock_irqsave(&l2_pmu_constraints.lock, flags);
 
-	shift_idx = ((reg * 4) + group);
-
-	bitmap_t = 1 << shift_idx;
+	bitmap_t = 1 << ((reg * 4) + group);
 
 	if (!(l2_pmu_constraints.pmu_bitmap & bitmap_t)) {
 		l2_pmu_constraints.pmu_bitmap |= bitmap_t;
-		l2_pmu_constraints.codes[shift_idx] = code;
 		goto out;
-	} else {
-		/*
-		 * If NRCCG's are identical,
-		 * its not column exclusion.
-		 */
-		if (l2_pmu_constraints.codes[shift_idx] != code)
-			err = -EPERM;
-		else
-			/*
-			 * If the event is counted in syswide mode
-			 * then we want to count only on one CPU
-			 * and set its filter to count from all.
-			 * This sets the event OFF on all but one
-			 * CPU.
-			 */
-			if (!(event->cpu < 0))
-				event->state = PERF_EVENT_STATE_OFF;
 	}
+
+	/* Bit is already set. Constraint failed. */
+	err = -EPERM;
 out:
 	raw_spin_unlock_irqrestore(&l2_pmu_constraints.lock, flags);
 	return err;
@@ -511,20 +481,14 @@
 	u8 group =  evt_type & 0x0000F;
 	unsigned long flags;
 	u64 bitmap_t;
-	u32 shift_idx;
 
 	raw_spin_lock_irqsave(&l2_pmu_constraints.lock, flags);
 
-	shift_idx = ((reg * 4) + group);
-
-	bitmap_t = 1 << shift_idx;
+	bitmap_t = 1 << ((reg * 4) + group);
 
 	/* Clear constraint bit. */
 	l2_pmu_constraints.pmu_bitmap &= ~bitmap_t;
 
-	/* Clear code. */
-	l2_pmu_constraints.codes[shift_idx] = -1;
-
 	raw_spin_unlock_irqrestore(&l2_pmu_constraints.lock, flags);
 	return 1;
 }
diff --unified -r mach-msm/perf_event_msm_l2.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/perf_event_msm_l2.c
--- mach-msm/perf_event_msm_l2.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/perf_event_msm_l2.c	2013-12-17 17:08:05.654151088 -0800
@@ -38,11 +38,9 @@
  */
 struct pmu_constraints {
 	u64 pmu_bitmap;
-	u8 codes[64];
 	raw_spinlock_t lock;
 } l2_pmu_constraints = {
 	.pmu_bitmap = 0,
-	.codes = {-1},
 	.lock = __RAW_SPIN_LOCK_UNLOCKED(l2_pmu_constraints.lock),
 };
 
@@ -669,11 +667,9 @@
 	int ctr = 0;
 
 	if (hwc->config_base == SCORPION_L2CYCLE_CTR_RAW_CODE) {
-		if (test_and_set_bit(l2_cycle_ctr_idx,
+		if (!test_and_set_bit(l2_cycle_ctr_idx,
 					cpuc->used_mask))
-			return -EAGAIN;
-
-		return l2_cycle_ctr_idx;
+			return l2_cycle_ctr_idx;
 	}
 
 	for (ctr = 0; ctr < total_l2_ctrs - 1; ctr++) {
@@ -796,50 +792,25 @@
 	u8 prefix = (evt_type & 0xF0000) >> 16;
 	u8 reg   = (evt_type & 0x0F000) >> 12;
 	u8 group =  evt_type & 0x0000F;
-	u8 code = (evt_type & 0x00FF0) >> 4;
 	unsigned long flags;
 	u32 err = 0;
 	u64 bitmap_t;
-	u32 shift_idx;
 
 	if (!prefix)
 		return 0;
-	/*
-	 * Cycle counter collision is detected in
-	 * get_event_idx().
-	 */
-	if (evt_type == SCORPION_L2CYCLE_CTR_RAW_CODE)
-		return err;
 
 	raw_spin_lock_irqsave(&l2_pmu_constraints.lock, flags);
 
-	shift_idx = ((reg * 4) + group);
-
-	bitmap_t = 1 << shift_idx;
+	bitmap_t = 1 << ((reg * 4) + group);
 
 	if (!(l2_pmu_constraints.pmu_bitmap & bitmap_t)) {
 		l2_pmu_constraints.pmu_bitmap |= bitmap_t;
-		l2_pmu_constraints.codes[shift_idx] = code;
 		goto out;
-	} else {
-		/*
-		 * If NRCCG's are identical,
-		 * its not column exclusion.
-		 */
-		if (l2_pmu_constraints.codes[shift_idx] != code)
-			err = -EPERM;
-		else
-			/*
-			 * If the event is counted in syswide mode
-			 * then we want to count only on one CPU
-			 * and set its filter to count from all.
-			 * This sets the event OFF on all but one
-			 * CPU.
-			 */
-			if (!(event->cpu < 0))
-				event->state = PERF_EVENT_STATE_OFF;
 	}
 
+	/* Bit is already set. Constraint failed. */
+	err = -EPERM;
+
 out:
 	raw_spin_unlock_irqrestore(&l2_pmu_constraints.lock, flags);
 	return err;
@@ -853,16 +824,13 @@
 	u8 group =  evt_type & 0x0000F;
 	unsigned long flags;
 	u64 bitmap_t;
-	u32 shift_idx;
 
 	if (!prefix)
 		return 0;
 
 	raw_spin_lock_irqsave(&l2_pmu_constraints.lock, flags);
 
-	shift_idx = ((reg * 4) + group);
-
-	bitmap_t = 1 << shift_idx;
+	bitmap_t = 1 << ((reg * 4) + group);
 
 	/* Clear constraint bit. */
 	l2_pmu_constraints.pmu_bitmap &= ~bitmap_t;
diff --unified -r mach-msm/platsmp.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/platsmp.c
--- mach-msm/platsmp.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/platsmp.c	2013-12-17 17:08:05.658151081 -0800
@@ -49,10 +49,10 @@
  */
 static void __cpuinit write_pen_release(int val)
 {
-	pen_release = val;
-	smp_wmb();
-	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
-	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+       pen_release = val;
+       smp_wmb();
+       __cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+       outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
 }
 
 static DEFINE_SPINLOCK(boot_lock);
@@ -68,10 +68,9 @@
 	 */
 	gic_secondary_init(0);
 
-	/*
-	 * let the primary processor know we're out of the
-	 * pen, then head off into the C entry point
-	 */
+	/* let the primary processor know we're out of the
+         * pen, then head off into the C entry point
+         */
 	write_pen_release(-1);
 
 	/*
diff --unified -r mach-msm/pm-8x60.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/pm-8x60.c
--- mach-msm/pm-8x60.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/pm-8x60.c	2013-12-17 17:08:05.658151081 -0800
@@ -55,17 +55,13 @@
 #include "timer.h"
 #include "pm-boot.h"
 #include <mach/event_timer.h>
-#include <linux/cpu_pm.h>
-#if CONFIG_SEC_DEBUG
+#ifdef CONFIG_SEC_DEBUG
 #include <mach/sec_debug.h>
 #endif
 #include <linux/regulator/consumer.h>
 #include <mach/gpiomux.h>
 #include <linux/mfd/pm8xxx/pm8921.h>
-
-#ifdef CONFIG_SEC_GPIO_DVS
-#include <linux/secgpio_dvs.h>
-#endif
+#include <linux/cpu_pm.h>
 
 /******************************************************************************
  * Debug Definitions
@@ -88,6 +84,7 @@
 	debug_mask, msm_pm_debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP
 );
 static int msm_pm_retention_tz_call;
+static struct msm_pm_sleep_status_data *msm_pm_slp_sts;
 
 /******************************************************************************
  * Sleep Modes and Parameters
@@ -986,13 +983,13 @@
 
 int msm_pm_wait_cpu_shutdown(unsigned int cpu)
 {
-	int timeout = 10;
+	int timeout = 0;
 
 	if (!msm_pm_slp_sts)
 		return 0;
 	if (!msm_pm_slp_sts[cpu].base_addr)
 		return 0;
-	while (timeout--) {
+	while (1) {
 		/*
 		 * Check for the SPM of the core being hotplugged to set
 		 * its sleep state.The SPM sleep state indicates that the
@@ -1003,10 +1000,10 @@
 		if (acc_sts & msm_pm_slp_sts[cpu].mask)
 			return 0;
 		udelay(100);
+		WARN(++timeout == 10, "CPU%u didn't collape within 1ms\n",
+					cpu);
 	}
 
-	pr_info("%s(): Timed out waiting for CPU %u SPM to enter sleep state",
-		__func__, cpu);
 	return -EBUSY;
 }
 
@@ -1150,14 +1147,6 @@
 		pm_mpp_dbg_showall(0);
 	}
 
-#ifdef CONFIG_SEC_GPIO_DVS
-	/************************ Caution !!! ****************************/
-	/* This function must be located in appropriate SLEEP position
-	 * in accordance with the specification of each BB vendor.
-	 */
-	/************************ Caution !!! ****************************/
-	gpio_dvs_check_sleepgpio();
-#endif
 	return 0;
 }
 
@@ -1388,7 +1377,6 @@
 		return rc;
 	}
 
-
 	return 0;
 }
 
diff --unified -r mach-msm/pm-data.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/pm-data.c
--- mach-msm/pm-data.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/pm-data.c	2013-12-17 17:08:05.658151081 -0800
@@ -125,4 +125,11 @@
 		.idle_enabled = 1,
 		.suspend_enabled = 0,
 	},
+
+	[MSM_PM_MODE(3, MSM_PM_SLEEP_MODE_NR)] = {
+		.idle_supported = 0,
+		.suspend_supported = 0,
+		.idle_enabled = 0,
+		.suspend_enabled = 0,
+	},
 };
diff --unified -r mach-msm/pm.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/pm.h
--- mach-msm/pm.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/pm.h	2013-12-17 17:08:05.658151081 -0800
@@ -64,11 +64,6 @@
 	uint32_t modified_time_us;
 };
 
-struct msm_pm_sleep_status_data {
-	void *base_addr;
-	uint32_t cpu_offset;
-	uint32_t mask;
-};
 
 struct msm_pm_platform_data {
 	u8 idle_supported;   /* Allow device to enter mode during idle */
@@ -83,6 +78,12 @@
 
 extern struct msm_pm_platform_data msm_pm_sleep_modes[];
 
+struct msm_pm_sleep_status_data {
+	void *base_addr;
+	uint32_t cpu_offset;
+	uint32_t mask;
+};
+
 struct msm_pm_sleep_ops {
 	void *(*lowest_limits)(bool from_idle,
 			enum msm_pm_sleep_mode sleep_mode,
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm: qdsp5
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm: qdsp5v2
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm: qdsp6
diff --unified -r mach-msm/qdsp6v2/audio_aac.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_aac.c
--- mach-msm/qdsp6v2/audio_aac.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_aac.c	2013-12-17 17:08:05.674151053 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -129,9 +129,10 @@
 		} else {
 			uint16_t sce_left = 1, sce_right = 2;
 			aac_config = audio->codec_cfg;
-			/* PL_PR is 0 only need to check PL_SR */
-			if (aac_config->dual_mono_mode >
-			    AUDIO_AAC_DUAL_MONO_PL_SR) {
+			if ((aac_config->dual_mono_mode <
+				AUDIO_AAC_DUAL_MONO_PL_PR) ||
+				(aac_config->dual_mono_mode >
+				AUDIO_AAC_DUAL_MONO_PL_SR)) {
 				pr_err("%s:AUDIO_SET_AAC_CONFIG: Invalid"
 					"dual_mono mode =%d\n", __func__,
 					aac_config->dual_mono_mode);
@@ -251,10 +252,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_aac_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_acdb.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_acdb.c
--- mach-msm/qdsp6v2/audio_acdb.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_acdb.c	2013-12-17 17:08:05.674151053 -0800
@@ -868,7 +868,7 @@
 static int acdb_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	int result = 0;
-	uint32_t size = vma->vm_end - vma->vm_start;
+	int size = vma->vm_end - vma->vm_start;
 
 	pr_debug("%s\n", __func__);
 
diff --unified -r mach-msm/qdsp6v2/audio_amrnb.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_amrnb.c
--- mach-msm/qdsp6v2/audio_amrnb.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_amrnb.c	2013-12-17 17:08:05.674151053 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -120,10 +120,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_amrnb_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_amrwb.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_amrwb.c
--- mach-msm/qdsp6v2/audio_amrwb.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_amrwb.c	2013-12-17 17:08:05.674151053 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -122,10 +122,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_amrwb_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_amrwbplus.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c
--- mach-msm/qdsp6v2/audio_amrwbplus.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_amrwbplus.c	2013-12-17 17:08:05.674151053 -0800
@@ -199,10 +199,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 	config_debug_fs(audio);
 	pr_debug("%s: AMRWBPLUS dec success mode[%d]session[%d]\n", __func__,
diff --unified -r mach-msm/qdsp6v2/audio_evrc.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_evrc.c
--- mach-msm/qdsp6v2/audio_evrc.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_evrc.c	2013-12-17 17:08:05.674151053 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -128,10 +128,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_evrc_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_lpa.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_lpa.c
--- mach-msm/qdsp6v2/audio_lpa.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_lpa.c	2013-12-17 17:08:05.674151053 -0800
@@ -1126,6 +1126,7 @@
 	if (audio->out_enabled)
 		audlpa_async_flush(audio);
 	audio->wflush = 0;
+	audlpa_unmap_ion_region(audio);
 	audio_disable(audio);
 	audlpa_unmap_ion_region(audio);
 	msm_clear_session_id(audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_mp3.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_mp3.c
--- mach-msm/qdsp6v2/audio_mp3.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_mp3.c	2013-12-17 17:08:05.674151053 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -123,10 +123,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_mp3_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_multi_aac.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_multi_aac.c
--- mach-msm/qdsp6v2/audio_multi_aac.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_multi_aac.c	2013-12-17 17:08:05.674151053 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -142,8 +142,10 @@
 		} else {
 			uint16_t sce_left = 1, sce_right = 2;
 			aac_config = audio->codec_cfg;
-			if (aac_config->dual_mono_mode >
-			    AUDIO_AAC_DUAL_MONO_PL_SR) {
+			if ((aac_config->dual_mono_mode <
+				AUDIO_AAC_DUAL_MONO_PL_PR) ||
+				(aac_config->dual_mono_mode >
+				AUDIO_AAC_DUAL_MONO_PL_SR)) {
 				pr_err("%s:AUDIO_SET_AAC_CONFIG: Invalid dual_mono mode =%d\n",
 					 __func__, aac_config->dual_mono_mode);
 			} else {
@@ -180,25 +182,6 @@
 		}
 		break;
 	}
-	case AUDIO_SET_AAC_MIX_CONFIG:	{
-		pr_debug("%s, AUDIO_SET_AAC_MIX_CONFIG", __func__);
-		if (copy_from_user(audio->codec_cfg, (void *)arg,
-			sizeof(unsigned long))) {
-			rc = -EFAULT;
-			break;
-		} else {
-			unsigned long *mix_coeff =
-				 (unsigned long *)audio->codec_cfg;
-			pr_debug("%s, value of coeff = %lu",
-				 __func__, *mix_coeff);
-			rc = q6asm_cfg_aac_sel_mix_coef(audio->ac, *mix_coeff);
-			if (rc < 0)
-				pr_err("%s asm aac_sel_mix_coef failed rc=%d\n",
-								__func__, rc);
-			break;
-		}
-		break;
-	}
 	default:
 		pr_debug("Calling utils ioctl\n");
 		rc = audio->codec_ioctl(file, cmd, arg);
@@ -277,10 +260,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_multi_aac_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_qcelp.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_qcelp.c
--- mach-msm/qdsp6v2/audio_qcelp.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_qcelp.c	2013-12-17 17:08:05.678151046 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -133,10 +133,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_qcelp_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_utils_aio.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c
--- mach-msm/qdsp6v2/audio_utils_aio.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.c	2013-12-17 17:08:05.678151046 -0800
@@ -1,6 +1,6 @@
 /* Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -222,29 +222,23 @@
 		   it is not in pause state */
 		if (!(audio->drv_status & ADRV_STATUS_PAUSE)) {
 			rc = audio_aio_pause(audio);
-			if (rc < 0) {
+			if (rc < 0)
 				pr_err("%s[%p}: pause cmd failed rc=%d\n",
 					__func__, audio,
 					rc);
-				goto fail;
-			}
 			else
 				audio->drv_status |= ADRV_STATUS_PAUSE;
 		}
 		rc = q6asm_cmd(audio->ac, CMD_FLUSH);
-		if (rc < 0) {
+		if (rc < 0)
 			pr_err("%s[%p]: flush cmd failed rc=%d\n",
 				__func__, audio, rc);
-			goto fail;
-		}
 		/* Not in stop state, reenable the stream */
 		if (audio->stopped == 0) {
 			rc = audio_aio_enable(audio);
-			if (rc) {
+			if (rc)
 				pr_err("%s[%p]:audio re-enable failed\n",
 					__func__, audio);
-				goto fail;
-			}
 			else {
 				audio->enabled = 1;
 				if (audio->drv_status & ADRV_STATUS_PAUSE)
@@ -259,8 +253,6 @@
 	atomic_set(&audio->in_bytes, 0);
 	atomic_set(&audio->in_samples, 0);
 	return 0;
-fail:
-	return -EINVAL;
 }
 
 static int audio_aio_outport_flush(struct q6audio_aio *audio)
@@ -476,9 +468,9 @@
 	audio->wflush = 0;
 	audio->drv_ops.out_flush(audio);
 	audio->drv_ops.in_flush(audio);
+	audio_aio_unmap_ion_region(audio);
 	audio_aio_disable(audio);
-	if (audio->stopped == 1)
-		audio_aio_unmap_ion_region(audio);
+	audio_aio_unmap_ion_region(audio);
 	audio_aio_reset_ion_region(audio);
 	ion_client_destroy(audio->client);
 	audio->event_abort = 1;
@@ -652,13 +644,7 @@
 	if (audio->eos_rsp && !list_empty(&audio->in_queue)) {
 		pr_debug("%s[%p]:Send flush command to release read buffers"\
 			" held up in DSP\n", __func__, audio);
-		audio->rflush = 1;
-		audio->wflush = 1;
-		rc = audio_aio_flush(audio);
-		if (rc < 0) {
-			audio->rflush = 0;
-			audio->wflush = 0;
-		}
+		audio_aio_flush(audio);
 	}
 
 	if (copy_to_user(arg, &usr_evt, sizeof(usr_evt)))
@@ -817,11 +803,6 @@
 	struct audio_client *ac;
 	struct audio_aio_write_param param;
 
-        if (!audio || !buf_node) {
-                pr_err("%s: NULL pointer audio=[0x%p], buf_node=[0x%p]\n",
-                        __func__, audio, buf_node);
-                return;
-        }
 	pr_debug("%s[%p]: Send write buff %p phy %lx len %d meta_enable = %d\n",
 		__func__, audio, buf_node, buf_node->paddr,
 		buf_node->buf.data_len,
@@ -848,7 +829,8 @@
 	else
 		param.flags = 0xFF00;
 
-	if (buf_node->meta_info.meta_in.nflags & AUDIO_DEC_EOF_SET)
+	if ((buf_node != NULL) &&
+		(buf_node->meta_info.meta_in.nflags & AUDIO_DEC_EOF_SET))
 		param.flags |= AUDIO_DEC_EOF_SET;
 
 	param.uid = param.paddr;
@@ -986,8 +968,7 @@
 			return -EINVAL;
 		}
 		/* No EOS reached */
-		/* No flush in progress */
-		if (!audio->eos_rsp && !audio->rflush) {
+		if (!audio->eos_rsp) {
 			spin_lock_irqsave(&audio->dsp_lock, flags);
 			audio_aio_async_read(audio, buf_node);
 			/* EOS buffer handled in driver */
@@ -1012,7 +993,7 @@
 	return 0;
 }
 
-void audio_aio_ioport_reset(struct q6audio_aio *audio)
+static void audio_aio_ioport_reset(struct q6audio_aio *audio)
 {
 	if (audio->drv_status & ADRV_STATUS_AIO_INTF) {
 		/* If fsync is in progress, make sure
@@ -1075,8 +1056,6 @@
 
 	audio->drv_ops.out_flush(audio);
 	audio->opened = 1;
-	audio->rflush = 0;
-	audio->wflush = 0;
 	file->private_data = audio;
 	audio->codec_ioctl = audio_aio_ioctl;
 
@@ -1099,6 +1078,9 @@
 	pr_debug("Ion client create in audio_aio_open %p", audio->client);
 	return 0;
 fail:
+	q6asm_audio_client_free(audio->ac);
+	kfree(audio->codec_cfg);
+	kfree(audio);
 	return rc;
 }
 
@@ -1172,19 +1154,15 @@
 				audio, audio->ac->session);
 		mutex_lock(&audio->lock);
 		audio->stopped = 1;
-		audio->rflush = 1;
-		audio->wflush = 1;
-		rc = audio_aio_flush(audio);
+		audio_aio_flush(audio);
+		audio->enabled = 0;
+		audio->drv_status &= ~ADRV_STATUS_PAUSE;
 		if (rc < 0) {
 			pr_err("%s[%p]:Audio Stop procedure failed rc=%d\n",
 				__func__, audio, rc);
-			audio->rflush = 0;
-			audio->wflush = 0;
 			mutex_unlock(&audio->lock);
 			break;
 		}
-		audio->enabled = 0;
-		audio->drv_status &= ~ADRV_STATUS_PAUSE;
 		mutex_unlock(&audio->lock);
 		break;
 	}
@@ -1223,6 +1201,8 @@
 		audio->wflush = 1;
 		/* Flush DSP */
 		rc = audio_aio_flush(audio);
+		/* Flush input / Output buffer in software*/
+		audio_aio_ioport_reset(audio);
 		if (rc < 0) {
 			pr_err("%s[%p]:AUDIO_FLUSH interrupted\n",
 				__func__, audio);
diff --unified -r mach-msm/qdsp6v2/audio_utils_aio.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.h
--- mach-msm/qdsp6v2/audio_utils_aio.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.h	2013-12-17 17:08:05.678151046 -0800
@@ -1,6 +1,6 @@
 /* Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -211,7 +211,6 @@
 int audio_aio_fsync(struct file *file, loff_t start, loff_t end, int datasync);
 void audio_aio_async_out_flush(struct q6audio_aio *audio);
 void audio_aio_async_in_flush(struct q6audio_aio *audio);
-void audio_aio_ioport_reset(struct q6audio_aio *audio);
 #ifdef CONFIG_DEBUG_FS
 ssize_t audio_aio_debug_open(struct inode *inode, struct file *file);
 ssize_t audio_aio_debug_read(struct file *file, char __user *buf,
diff --unified -r mach-msm/qdsp6v2/audio_wma.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_wma.c
--- mach-msm/qdsp6v2/audio_wma.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_wma.c	2013-12-17 17:08:05.678151046 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -167,10 +167,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_wma_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/audio_wmapro.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_wmapro.c
--- mach-msm/qdsp6v2/audio_wmapro.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/audio_wmapro.c	2013-12-17 17:08:05.678151046 -0800
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2008 Google, Inc.
  * Copyright (C) 2008 HTC Corporation
- * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -227,10 +227,6 @@
 		goto fail;
 	}
 	rc = audio_aio_open(audio, file);
-	if (rc < 0) {
-		pr_err("audio_aio_open rc=%d\n", rc);
-		goto fail;
-	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof name, "msm_wmapro_%04x", audio->ac->session);
diff --unified -r mach-msm/qdsp6v2/dsp_debug.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/dsp_debug.c
--- mach-msm/qdsp6v2/dsp_debug.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/dsp_debug.c	2013-12-17 17:08:05.678151046 -0800
@@ -38,14 +38,12 @@
 
 void q6audio_dsp_not_responding(void)
 {
-	int i;
-
 	if (cb_ptr)
 		cb_ptr(DSP_STATE_CRASHED);
 	if (atomic_add_return(1, &dsp_crash_count) != 1) {
 		pr_err("q6audio_dsp_not_responding() \
 			- parking additional crasher...\n");
-		for (i = 0; i < 600; i++)
+		for (;;)
 			msleep(1000);
 	}
 	if (dsp_wait_count) {
diff --unified -r mach-msm/qdsp6v2/q6audio_v1_aio.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c
--- mach-msm/qdsp6v2/q6audio_v1_aio.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/q6audio_v1_aio.c	2013-12-17 17:08:05.678151046 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -39,9 +39,6 @@
 	case ASM_DATA_EVENT_ENC_SR_CM_NOTIFY:
 		audio_aio_cb(opcode, token, payload, audio);
 		break;
-	case APR_BASIC_RSP_RESULT:
-		audio_aio_cb(opcode, token, payload, audio);
-		break;
 	default:
 		pr_debug("%s:Unhandled event = 0x%8x\n", __func__, opcode);
 		break;
@@ -109,26 +106,6 @@
 		e_payload.stream_info.sample_rate = audio->pcm_cfg.sample_rate;
 		audio_aio_post_event(audio, AUDIO_EVENT_STREAM_INFO, e_payload);
 		break;
-	case APR_BASIC_RSP_RESULT:
-		switch (payload[0]) {
-		case ASM_STREAM_CMD_FLUSH:
-			if (payload[1] == ADSP_EOK) {
-				pr_debug("%s: FLUSH CMD success\n", __func__);
-				audio_aio_ioport_reset(audio);
-				audio->wflush = 0;
-				audio->rflush = 0;
-			} else {
-				pr_err("%s: FLUSH CMD failed with status:%d\n",
-					__func__, payload[1]);
-				audio_aio_ioport_reset(audio);
-				audio->wflush = 0;
-				audio->rflush = 0;
-			}
-			break;
-		default:
-			pr_debug("%s: cmd%x cmd_status:%d\n",
-				__func__, payload[0], payload[1]);
-		}
 	default:
 		break;
 	}
diff --unified -r mach-msm/qdsp6v2/q6core.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/q6core.c
--- mach-msm/qdsp6v2/q6core.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/qdsp6v2/q6core.c	2013-12-17 17:08:05.678151046 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2011, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -249,6 +249,8 @@
 	int len;
 	static int t_len;
 
+	if (count < 0)
+		return 0;
 	len = count > 63 ? 63 : count;
 	if (copy_from_user(l_buf + 20 , buf, len)) {
 		pr_info("Unable to copy data from user space\n");
diff --unified -r mach-msm/restart.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/restart.c
--- mach-msm/restart.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/restart.c	2013-12-17 17:08:05.682151039 -0800
@@ -40,6 +40,10 @@
 #include "msm_watchdog.h"
 #include "timer.h"
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+#include <asm/kexec.h>
+#endif
+
 #define WDT0_RST	0x38
 #define WDT0_EN		0x40
 #define WDT0_BARK_TIME	0x4C
@@ -200,6 +204,30 @@
 		;
 }
 
+static int irq_enabled;
+static int status;
+
+int resout_irq_control(int enable)
+{
+	if (!irq_enabled)
+		return -1;
+
+	if (enable ^ status) {
+		if (enable) {
+			enable_irq(pmic_reset_irq);
+			status = 1;
+			pr_info("%s : %d\n", __func__, status);
+		} else {
+			disable_irq_nosync(pmic_reset_irq);
+			status = 0;
+			pr_info("%s : %d\n", __func__, status);
+		}
+	} else
+		return -1;
+
+	return 0;
+}
+
 static irqreturn_t resout_irq_handler(int irq, void *dev_id)
 {
 	pr_warn("%s PMIC Initiated shutdown\n", __func__);
@@ -315,8 +343,6 @@
 #ifdef CONFIG_SEC_DEBUG
 		} else if (!strncmp(cmd, "sec_debug_hw_reset", 18)) {
 			__raw_writel(0x776655ee, restart_reason);
-		} else if (!strncmp(cmd, "sec_debug_low_panic", 19)) {
-			__raw_writel(0x776655dd, restart_reason);
 #endif
 		} else if (!strncmp(cmd, "download", 8)) {
 			__raw_writel(0x12345671, restart_reason);
@@ -331,9 +357,6 @@
 				&& !kstrtoul(cmd + 7, 0, &value)) {
 			__raw_writel(0xfedc0000 | value, restart_reason);
 #endif
-		} else if (strlen(cmd) == 0) {
-			printk(KERN_NOTICE "%s : value of cmd is NULL.\n", __func__);
-			__raw_writel(0x12345678, restart_reason);
 		} else {
 			__raw_writel(0x77665501, restart_reason);
 		}
@@ -343,13 +366,12 @@
 		set_kernel_crash_magic_number();
 reset:
 #endif /* CONFIG_LGE_CRASH_HANDLER */
-#ifdef CONFIG_SEC_DEBUG
+#if 1
 	else {
 		printk(KERN_NOTICE "%s : clear reset flag\r\n", __func__);
 		__raw_writel(0x12345678, restart_reason);
 	}
 #endif
-	printk(KERN_NOTICE " msm_restart restart_reason : 0x%08x\n", readl(restart_reason));
 	__raw_writel(0, msm_tmr0_base + WDT0_EN);
 	if (!(machine_is_msm8x60_fusion() || machine_is_msm8x60_fusn_ffa())) {
 		mb();
@@ -379,13 +401,30 @@
 };
 #endif
 
+#ifdef CONFIG_KEXEC_HARDBOOT
+void msm_kexec_hardboot(void)
+{
+#if defined(CONFIG_MSM_DLOAD_MODE) && !defined(CONFIG_SEC_DEBUG)
+	/* Do not enter download mode on reboot. */
+	set_dload_mode(0);
+#endif
+
+	/* Set PM8XXX PMIC to reset on power off. */
+	pm8xxx_reset_pwr_off(1);
+
+	/* Reboot with the recovery kernel since the boot kernel decompressor may
+	 * not support the hardboot jump. */
+	__raw_writel(0x77665502, restart_reason);
+}
+#endif
+
 static int __init msm_pmic_restart_init(void)
 {
 	int rc;
 
 #ifdef CONFIG_MACH_JF_VZW
 	return 0;
-#else
+#elif defined(CONFIG_SEC_DEBUG)
 	if (kernel_sec_get_debug_level() != KERNEL_SEC_DEBUG_LEVEL_LOW)
 		return 0;
 #endif
@@ -396,6 +435,8 @@
 					"restart_from_pmic", NULL);
 		if (rc < 0)
 			pr_err("pmic restart irq fail rc = %d\n", rc);
+		irq_enabled = 1;
+		status = 1;
 	} else {
 		pr_warn("no pmic restart interrupt specified\n");
 	}
@@ -433,6 +474,9 @@
 	restart_reason = MSM_IMEM_BASE + RESTART_REASON_ADDR;
 #endif
 	pm_power_off = msm_power_off;
+#ifdef CONFIG_KEXEC_HARDBOOT
+	kexec_hardboot_hook = msm_kexec_hardboot;
+#endif
 
 	return 0;
 }
diff --unified -r mach-msm/rpm_resources.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/rpm_resources.c
--- mach-msm/rpm_resources.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/rpm_resources.c	2013-12-17 17:08:05.682151039 -0800
@@ -953,11 +953,9 @@
 
 		if ((MSM_PM_SLEEP_MODE_POWER_COLLAPSE_STANDALONE == sleep_mode)
 			|| (MSM_PM_SLEEP_MODE_POWER_COLLAPSE == sleep_mode))
-			if (!cpu && msm_rpm_local_request_is_outstanding()) {
-				if (MSM_RPMRS_DEBUG_OUTPUT & msm_rpmrs_debug_mask)
-					pr_info(" RPM Request is outstanding\n");
-				break;
-			}
+			if (!cpu && msm_rpm_local_request_is_outstanding())
+					break;
+
 		if (next_wakeup_us <= 1) {
 			pwr = level->energy_overhead;
 		} else if (next_wakeup_us <= level->time_overhead_us) {
diff --unified -r mach-msm/rpm-smd.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/rpm-smd.c
--- mach-msm/rpm-smd.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/rpm-smd.c	2013-12-17 17:08:05.682151039 -0800
@@ -987,7 +987,8 @@
 	smd_disable_read_intr(msm_rpm_data.ch_info);
 
 	if (!standalone) {
-		msm_rpm_smd_wq = create_singlethread_workqueue("rpm-smd");
+		msm_rpm_smd_wq = alloc_workqueue("rpm-smd",
+				WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_HIGHPRI, 1);
 		if (!msm_rpm_smd_wq)
 			return -EINVAL;
 	}
diff --unified -r mach-msm/scm.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/scm.c
--- mach-msm/scm.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/scm.c	2013-12-17 17:08:05.682151039 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -31,9 +31,6 @@
 
 static DEFINE_MUTEX(scm_lock);
 
-#define SCM_BUF_LEN(__cmd_size, __resp_size)	\
-	(sizeof(struct scm_command) + sizeof(struct scm_response) + \
-		__cmd_size + __resp_size)
 /**
  * struct scm_command - one SCM command buffer
  * @len: total available memory for command and response
@@ -79,6 +76,42 @@
 };
 
 /**
+ * alloc_scm_command() - Allocate an SCM command
+ * @cmd_size: size of the command buffer
+ * @resp_size: size of the response buffer
+ *
+ * Allocate an SCM command, including enough room for the command
+ * and response headers as well as the command and response buffers.
+ *
+ * Returns a valid &scm_command on success or %NULL if the allocation fails.
+ */
+static struct scm_command *alloc_scm_command(size_t cmd_size, size_t resp_size)
+{
+	struct scm_command *cmd;
+	size_t len = sizeof(*cmd) + sizeof(struct scm_response) + cmd_size +
+		resp_size;
+
+	cmd = kzalloc(PAGE_ALIGN(len), GFP_KERNEL);
+	if (cmd) {
+		cmd->len = len;
+		cmd->buf_offset = offsetof(struct scm_command, buf);
+		cmd->resp_hdr_offset = cmd->buf_offset + cmd_size;
+	}
+	return cmd;
+}
+
+/**
+ * free_scm_command() - Free an SCM command
+ * @cmd: command to free
+ *
+ * Free an SCM command.
+ */
+static inline void free_scm_command(struct scm_command *cmd)
+{
+	kfree(cmd);
+}
+
+/**
  * scm_command_to_response() - Get a pointer to a scm_response
  * @cmd: command
  *
@@ -186,47 +219,39 @@
 }
 
 /**
- * scm_call_common() - Send an SCM command
+ * scm_call() - Send an SCM command
  * @svc_id: service identifier
  * @cmd_id: command identifier
  * @cmd_buf: command buffer
  * @cmd_len: length of the command buffer
  * @resp_buf: response buffer
  * @resp_len: length of the response buffer
- * @scm_buf: internal scm structure used for passing data
- * @scm_buf_len: length of the internal scm structure
  *
- * Core function to scm call. Initializes the given cmd structure with
- * appropriate values and makes the actual scm call. Validation of cmd
- * pointer and length must occur in the calling function.
- *
- * Returns the appropriate error code from the scm call
+ * Sends a command to the SCM and waits for the command to finish processing.
  */
-
-static int scm_call_common(u32 svc_id, u32 cmd_id, const void *cmd_buf,
-				size_t cmd_len, void *resp_buf, size_t resp_len,
-				struct scm_command *scm_buf,
-				size_t scm_buf_length)
+int scm_call(u32 svc_id, u32 cmd_id, const void *cmd_buf, size_t cmd_len,
+		void *resp_buf, size_t resp_len)
 {
 	int ret;
+	struct scm_command *cmd;
 	struct scm_response *rsp;
 	unsigned long start, end;
 
-	scm_buf->len = scm_buf_length;
-	scm_buf->buf_offset = offsetof(struct scm_command, buf);
-	scm_buf->resp_hdr_offset = scm_buf->buf_offset + cmd_len;
-	scm_buf->id = (svc_id << 10) | cmd_id;
+	cmd = alloc_scm_command(cmd_len, resp_len);
+	if (!cmd)
+		return -ENOMEM;
 
+	cmd->id = (svc_id << 10) | cmd_id;
 	if (cmd_buf)
-		memcpy(scm_get_command_buffer(scm_buf), cmd_buf, cmd_len);
+		memcpy(scm_get_command_buffer(cmd), cmd_buf, cmd_len);
 
 	mutex_lock(&scm_lock);
-	ret = __scm_call(scm_buf);
+	ret = __scm_call(cmd);
 	mutex_unlock(&scm_lock);
 	if (ret)
-		return ret;
+		goto out;
 
-	rsp = scm_command_to_response(scm_buf);
+	rsp = scm_command_to_response(cmd);
 	start = (unsigned long)rsp;
 
 	do {
@@ -238,74 +263,8 @@
 
 	if (resp_buf)
 		memcpy(resp_buf, scm_get_response_buffer(rsp), resp_len);
-
-	return ret;
-}
-
-/**
- * scm_call_noalloc - Send an SCM command
- *
- * Same as scm_call except clients pass in a buffer (@scm_buf) to be used for
- * scm internal structures. The buffer should be allocated with
- * DEFINE_SCM_BUFFER to account for the proper alignment and size.
- */
-int scm_call_noalloc(u32 svc_id, u32 cmd_id, const void *cmd_buf,
-		size_t cmd_len, void *resp_buf, size_t resp_len,
-		void *scm_buf, size_t scm_buf_len)
-{
-	int ret;
-	size_t len = SCM_BUF_LEN(cmd_len, resp_len);
-
-	if (cmd_len > scm_buf_len || resp_len > scm_buf_len ||
-	    len > scm_buf_len)
-		return -EINVAL;
-
-	if (!IS_ALIGNED((unsigned long)scm_buf, PAGE_SIZE))
-		return -EINVAL;
-
-	memset(scm_buf, 0, scm_buf_len);
-
-	ret = scm_call_common(svc_id, cmd_id, cmd_buf, cmd_len, resp_buf,
-				resp_len, scm_buf, len);
-	return ret;
-
-}
-
-/**
- * scm_call() - Send an SCM command
- * @svc_id: service identifier
- * @cmd_id: command identifier
- * @cmd_buf: command buffer
- * @cmd_len: length of the command buffer
- * @resp_buf: response buffer
- * @resp_len: length of the response buffer
- *
- * Sends a command to the SCM and waits for the command to finish processing.
- *
- * A note on cache maintenance:
- * Note that any buffers that are expected to be accessed by the secure world
- * must be flushed before invoking scm_call and invalidated in the cache
- * immediately after scm_call returns. Cache maintenance on the command and
- * response buffers is taken care of by scm_call; however, callers are
- * responsible for any other cached buffers passed over to the secure world.
- */
-int scm_call(u32 svc_id, u32 cmd_id, const void *cmd_buf, size_t cmd_len,
-		void *resp_buf, size_t resp_len)
-{
-	struct scm_command *cmd;
-	int ret;
-	size_t len = SCM_BUF_LEN(cmd_len, resp_len);
-
-	if (cmd_len > len || resp_len > len)
-		return -EINVAL;
-
-	cmd = kzalloc(PAGE_ALIGN(len), GFP_KERNEL);
-	if (!cmd)
-		return -ENOMEM;
-
-	ret = scm_call_common(svc_id, cmd_id, cmd_buf, cmd_len, resp_buf,
-				resp_len, cmd, len);
-	kfree(cmd);
+out:
+	free_scm_command(cmd);
 	return ret;
 }
 EXPORT_SYMBOL(scm_call);
@@ -383,6 +342,43 @@
 }
 EXPORT_SYMBOL(scm_call_atomic2);
 
+/**
+ * scm_call_atomic3() - Send an atomic SCM command with three arguments
+ * @svc_id: service identifier
+ * @cmd_id: command identifier
+ * @arg1: first argument
+ * @arg2: second argument
+ * @arg3: third argument
+ *
+ * This shall only be used with commands that are guaranteed to be
+ * uninterruptable, atomic and SMP safe.
+ */
+s32 scm_call_atomic3(u32 svc, u32 cmd, u32 arg1, u32 arg2, u32 arg3)
+{
+	int context_id;
+	register u32 r0 asm("r0") = SCM_ATOMIC(svc, cmd, 3);
+	register u32 r1 asm("r1") = (u32)&context_id;
+	register u32 r2 asm("r2") = arg1;
+	register u32 r3 asm("r3") = arg2;
+	register u32 r4 asm("r4") = arg3;
+
+	asm volatile(
+		__asmeq("%0", "r0")
+		__asmeq("%1", "r0")
+		__asmeq("%2", "r1")
+		__asmeq("%3", "r2")
+		__asmeq("%4", "r3")
+		__asmeq("%5", "r4")
+#ifdef REQUIRES_SEC
+			".arch_extension sec\n"
+#endif
+		"smc	#0	@ switch to secure world\n"
+		: "=r" (r0)
+		: "r" (r0), "r" (r1), "r" (r2), "r" (r3), "r" (r4));
+	return r0;
+}
+EXPORT_SYMBOL(scm_call_atomic3);
+
 s32 scm_call_atomic4_3(u32 svc, u32 cmd, u32 arg1, u32 arg2,
 		u32 arg3, u32 arg4, u32 *ret1, u32 *ret2)
 {
diff --unified -r mach-msm/sec_debug.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/sec_debug.c
--- mach-msm/sec_debug.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/sec_debug.c	2013-12-17 17:08:05.686151032 -0800
@@ -956,17 +956,6 @@
 }
 EXPORT_SYMBOL(sec_debug_hw_reset);
 
-void sec_debug_low_panic(void)
-{
-	pr_emerg("(%s) rebooting...\n", __func__);
-	flush_cache_all();
-	outer_flush_all();
-	msm_restart(0, "sec_debug_low_panic");
-
-	while (1)
-		;
-}
-
 #ifdef CONFIG_SEC_DEBUG_LOW_LOG
 unsigned sec_debug_get_reset_reason(void)
 {
@@ -980,6 +969,12 @@
 	emerg_pet_watchdog();
 	sec_debug_set_upload_magic(0x776655ee);
 
+	if (!enable) {
+#ifdef CONFIG_SEC_DEBUG_LOW_LOG
+		sec_debug_hw_reset();
+#endif
+		return -EPERM;
+	}
 	len = strnlen(buf, 15);
 	if (!strncmp(buf, "User Fault", len))
 		sec_debug_set_upload_cause(UPLOAD_CAUSE_USER_FAULT);
@@ -1004,13 +999,6 @@
 	else
 		sec_debug_set_upload_cause(UPLOAD_CAUSE_KERNEL_PANIC);
 
-	if (!enable) {
-#ifdef CONFIG_SEC_DEBUG_LOW_LOG
-		sec_debug_hw_reset();
-#endif
-		sec_debug_low_panic();
-		return -EPERM;
-	}
 /* enable after SSR feature
 	ssr_panic_handler_for_sec_dbg();
 */
diff --unified -r mach-msm/smd.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd.c
--- mach-msm/smd.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd.c	2013-12-17 17:08:05.686151032 -0800
@@ -3191,7 +3191,6 @@
 			flags, "smd_dev", 0);
 	if (r < 0)
 		return r;
-	interrupt_stats[SMD_MODEM].smd_interrupt_id = INT_A9_M2A_0;
 	r = enable_irq_wake(INT_A9_M2A_0);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3203,7 +3202,6 @@
 		free_irq(INT_A9_M2A_0, 0);
 		return r;
 	}
-	interrupt_stats[SMD_MODEM].smsm_interrupt_id = INT_A9_M2A_5;
 	r = enable_irq_wake(INT_A9_M2A_5);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3221,7 +3219,6 @@
 		return r;
 	}
 
-	interrupt_stats[SMD_Q6].smd_interrupt_id = INT_ADSP_A11;
 	r = request_irq(INT_ADSP_A11_SMSM, smsm_dsp_irq_handler,
 			flags, "smsm_dev", smsm_dsp_irq_handler);
 	if (r < 0) {
@@ -3231,7 +3228,6 @@
 		return r;
 	}
 
-	interrupt_stats[SMD_Q6].smsm_interrupt_id = INT_ADSP_A11_SMSM;
 	r = enable_irq_wake(INT_ADSP_A11);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3257,7 +3253,6 @@
 		return r;
 	}
 
-	interrupt_stats[SMD_DSPS].smd_interrupt_id = INT_DSPS_A11;
 	r = enable_irq_wake(INT_DSPS_A11);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3276,7 +3271,6 @@
 		return r;
 	}
 
-	interrupt_stats[SMD_WCNSS].smd_interrupt_id = INT_WCNSS_A11;
 	r = enable_irq_wake(INT_WCNSS_A11);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3294,7 +3288,6 @@
 		return r;
 	}
 
-	interrupt_stats[SMD_WCNSS].smsm_interrupt_id = INT_WCNSS_A11_SMSM;
 	r = enable_irq_wake(INT_WCNSS_A11_SMSM);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3315,7 +3308,6 @@
 		return r;
 	}
 
-	interrupt_stats[SMD_DSPS].smsm_interrupt_id = INT_DSPS_A11_SMSM;
 	r = enable_irq_wake(INT_DSPS_A11_SMSM);
 	if (r < 0)
 		pr_err("smd_core_init: "
@@ -3445,8 +3437,6 @@
 			goto intr_failed;
 		}
 
-		interrupt_stats[cfg->irq_config_id].smd_interrupt_id
-						 = cfg->smd_int.irq_id;
 		/* only init smsm structs if this edge supports smsm */
 		if (cfg->smsm_int.irq_id)
 			ret = intr_init(
@@ -3462,9 +3452,6 @@
 			goto intr_failed;
 		}
 
-		if (cfg->smsm_int.irq_id)
-			interrupt_stats[cfg->irq_config_id].smsm_interrupt_id
-						 = cfg->smsm_int.irq_id;
 		if (cfg->subsys_name)
 			strlcpy(edge_to_pids[cfg->edge].subsys_name,
 				cfg->subsys_name, SMD_MAX_CH_NAME_LEN);
diff --unified -r mach-msm/smd_debug.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd_debug.c
--- mach-msm/smd_debug.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd_debug.c	2013-12-17 17:08:05.686151032 -0800
@@ -103,24 +103,22 @@
 	const char *subsys_name;
 
 	i += scnprintf(buf + i, max - i,
-		"   Subsystem    | Interrupt ID |     In    | Out (Hardcoded) |"
+		"   Subsystem    |     In    | Out (Hardcoded) |"
 		" Out (Configured) |\n");
 
 	for (subsys = 0; subsys < NUM_SMD_SUBSYSTEMS; ++subsys) {
 		subsys_name = smd_pid_to_subsystem(subsys);
 		if (subsys_name) {
 			i += scnprintf(buf + i, max - i,
-				"%-10s %4s |    %9d | %9u |       %9u |        %9u |\n",
+				"%-10s %4s | %9u |       %9u |        %9u |\n",
 				smd_pid_to_subsystem(subsys), "smd",
-				stats->smd_interrupt_id,
 				stats->smd_in_count,
 				stats->smd_out_hardcode_count,
 				stats->smd_out_config_count);
 
 			i += scnprintf(buf + i, max - i,
-				"%-10s %4s |    %9d | %9u |       %9u |        %9u |\n",
+				"%-10s %4s | %9u |       %9u |        %9u |\n",
 				smd_pid_to_subsystem(subsys), "smsm",
-				stats->smsm_interrupt_id,
 				stats->smsm_in_count,
 				stats->smsm_out_hardcode_count,
 				stats->smsm_out_config_count);
diff --unified -r mach-msm/smd_pkt.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd_pkt.c
--- mach-msm/smd_pkt.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd_pkt.c	2013-12-17 17:08:05.686151032 -0800
@@ -35,13 +35,12 @@
 
 #include <mach/msm_smd.h>
 #include <mach/peripheral-loader.h>
-#include <mach/msm_ipc_logging.h>
 
 #include "smd_private.h"
 #ifdef CONFIG_ARCH_FSM9XXX
 #define NUM_SMD_PKT_PORTS 4
 #else
-#define NUM_SMD_PKT_PORTS 24
+#define NUM_SMD_PKT_PORTS 15
 #endif
 
 #define PDRIVER_NAME_MAX_SIZE 32
@@ -66,7 +65,6 @@
 	wait_queue_head_t ch_opened_wait_queue;
 
 	int i;
-	int ref_cnt;
 
 	int blocking_write;
 	int is_open;
@@ -90,9 +88,6 @@
 static void check_and_wakeup_writer(struct smd_pkt_dev *smd_pkt_devp);
 static uint32_t is_modem_smsm_inited(void);
 
-#define SMD_PKT_IPC_LOG_PAGE_CNT 2
-static void *smd_pkt_ilctxt;
-
 static int msm_smd_pkt_debug_mask;
 module_param_named(debug_mask, msm_smd_pkt_debug_mask,
 		int, S_IRUGO | S_IWUSR | S_IWGRP);
@@ -109,44 +104,22 @@
 #define DEBUG
 
 #ifdef DEBUG
-
-#define SMD_PKT_LOG_STRING(x...) \
-do { \
-	if (smd_pkt_ilctxt) \
-		ipc_log_string(smd_pkt_ilctxt, "<SMD_PKT>: "x); \
-} while (0)
-
-#define SMD_PKT_LOG_BUF(buf, cnt) \
-do { \
-	char log_buf[128]; \
-	int i; \
-	if (smd_pkt_ilctxt) { \
-		i = cnt < 16 ? cnt : 16; \
-		hex_dump_to_buffer(buf, i, 16, 1, log_buf, \
-				   sizeof(log_buf), false); \
-		ipc_log_string(smd_pkt_ilctxt, "<SMD_PKT>: %s", log_buf); \
-	} \
-} while (0)
-
 #define D_STATUS(x...) \
 do { \
 	if (msm_smd_pkt_debug_mask & SMD_PKT_STATUS) \
 		pr_info("Status: "x); \
-	SMD_PKT_LOG_STRING(x); \
 } while (0)
 
 #define D_READ(x...) \
 do { \
 	if (msm_smd_pkt_debug_mask & SMD_PKT_READ) \
 		pr_info("Read: "x); \
-	SMD_PKT_LOG_STRING(x); \
 } while (0)
 
 #define D_WRITE(x...) \
 do { \
 	if (msm_smd_pkt_debug_mask & SMD_PKT_WRITE) \
 		pr_info("Write: "x); \
-	SMD_PKT_LOG_STRING(x); \
 } while (0)
 
 #define D_READ_DUMP_BUFFER(prestr, cnt, buf) \
@@ -155,7 +128,6 @@
 		print_hex_dump(KERN_INFO, prestr, \
 			       DUMP_PREFIX_NONE, 16, 1, \
 			       buf, cnt, 1); \
-	SMD_PKT_LOG_BUF(buf, cnt); \
 } while (0)
 
 #define D_WRITE_DUMP_BUFFER(prestr, cnt, buf) \
@@ -164,14 +136,12 @@
 		print_hex_dump(KERN_INFO, prestr, \
 			       DUMP_PREFIX_NONE, 16, 1, \
 			       buf, cnt, 1); \
-	SMD_PKT_LOG_BUF(buf, cnt); \
 } while (0)
 
 #define D_POLL(x...) \
 do { \
 	if (msm_smd_pkt_debug_mask & SMD_PKT_POLL) \
 		pr_info("Poll: "x); \
-	SMD_PKT_LOG_STRING(x); \
 } while (0)
 
 #define E_SMD_PKT_SSR(x) \
@@ -300,7 +270,6 @@
 	if (!smd_pkt_devp)
 		return -EINVAL;
 
-	mutex_lock(&smd_pkt_devp->ch_lock);
 	switch (cmd) {
 	case TIOCMGET:
 		D_STATUS("%s TIOCMGET command on smd_pkt_dev id:%d\n",
@@ -319,7 +288,6 @@
 		pr_err("%s: Unrecognized ioctl command %d\n", __func__, cmd);
 		ret = -1;
 	}
-	mutex_unlock(&smd_pkt_devp->ch_lock);
 
 	return ret;
 }
@@ -711,15 +679,6 @@
 	"smdcntl6",
 	"smdcntl7",
 	"smd22",
-	"smdcnt_rev0",
-	"smdcnt_rev1",
-	"smdcnt_rev2",
-	"smdcnt_rev3",
-	"smdcnt_rev4",
-	"smdcnt_rev5",
-	"smdcnt_rev6",
-	"smdcnt_rev7",
-	"smdcnt_rev8",
 	"smd_sns_dsps",
 	"apr_apps2",
 	"smdcntl8",
@@ -738,15 +697,6 @@
 	"DATA13_CNTL",
 	"DATA14_CNTL",
 	"DATA22",
-	"DATA23_CNTL",
-	"DATA24_CNTL",
-	"DATA25_CNTL",
-	"DATA26_CNTL",
-	"DATA27_CNTL",
-	"DATA28_CNTL",
-	"DATA29_CNTL",
-	"DATA30_CNTL",
-	"DATA31_CNTL",
 	"SENSOR",
 	"apr_apps2",
 	"DATA40_CNTL",
@@ -765,15 +715,6 @@
 	SMD_APPS_MODEM,
 	SMD_APPS_MODEM,
 	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
-	SMD_APPS_MODEM,
 	SMD_APPS_DSPS,
 	SMD_APPS_QDSP,
 	SMD_APPS_MODEM,
@@ -926,12 +867,9 @@
 			smd_pkt_devp->ch_size =
 				smd_write_avail(smd_pkt_devp->ch);
 			r = 0;
-			smd_pkt_devp->ref_cnt++;
 			D_STATUS("Finished %s on smd_pkt_dev id:%d\n",
 				 __func__, smd_pkt_devp->i);
 		}
-	} else {
-		smd_pkt_devp->ref_cnt++;
 	}
 release_pil:
 	if (peripheral && (r < 0))
@@ -964,14 +902,12 @@
 	D_STATUS("Begin %s on smd_pkt_dev id:%d\n",
 		 __func__, smd_pkt_devp->i);
 
+	clean_and_signal(smd_pkt_devp);
+
 	mutex_lock(&smd_pkt_devp->ch_lock);
 	mutex_lock(&smd_pkt_devp->rx_lock);
 	mutex_lock(&smd_pkt_devp->tx_lock);
-	if (smd_pkt_devp->ref_cnt > 0)
-		smd_pkt_devp->ref_cnt--;
-
-	if (smd_pkt_devp->ch != 0 && smd_pkt_devp->ref_cnt == 0) {
-		clean_and_signal(smd_pkt_devp);
+	if (smd_pkt_devp->ch != 0) {
 		r = smd_close(smd_pkt_devp->ch);
 		smd_pkt_devp->ch = 0;
 		smd_pkt_devp->blocking_write = 0;
@@ -980,15 +916,15 @@
 		smd_pkt_devp->driver.probe = NULL;
 		if (smd_pkt_devp->pil)
 			pil_put(smd_pkt_devp->pil);
-		smd_pkt_devp->has_reset = 0;
-		smd_pkt_devp->do_reset_notification = 0;
-		smd_pkt_devp->wakelock_locked = 0;
-		wake_lock_destroy(&smd_pkt_devp->pa_wake_lock);
 	}
 	mutex_unlock(&smd_pkt_devp->tx_lock);
 	mutex_unlock(&smd_pkt_devp->rx_lock);
 	mutex_unlock(&smd_pkt_devp->ch_lock);
 
+	smd_pkt_devp->has_reset = 0;
+	smd_pkt_devp->do_reset_notification = 0;
+	smd_pkt_devp->wakelock_locked = 0;
+	wake_lock_destroy(&smd_pkt_devp->pa_wake_lock);
 	D_STATUS("Finished %s on smd_pkt_dev id:%d\n",
 		 __func__, smd_pkt_devp->i);
 
@@ -1088,9 +1024,6 @@
 
 	INIT_DELAYED_WORK(&loopback_work, loopback_probe_worker);
 
-	smd_pkt_ilctxt = ipc_log_context_create(SMD_PKT_IPC_LOG_PAGE_CNT,
-						"smd_pkt");
-
 	D_STATUS("SMD Packet Port Driver Initialized.\n");
 	return 0;
 
diff --unified -r mach-msm/smd_private.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd_private.h
--- mach-msm/smd_private.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smd_private.h	2013-12-17 17:08:05.686151032 -0800
@@ -255,12 +255,10 @@
 	uint32_t smd_in_count;
 	uint32_t smd_out_hardcode_count;
 	uint32_t smd_out_config_count;
-	uint32_t smd_interrupt_id;
 
 	uint32_t smsm_in_count;
 	uint32_t smsm_out_hardcode_count;
 	uint32_t smsm_out_config_count;
-	uint32_t smsm_interrupt_id;
 };
 extern struct interrupt_stat interrupt_stats[NUM_SMD_SUBSYSTEMS];
 
diff --unified -r mach-msm/smem_log.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smem_log.c
--- mach-msm/smem_log.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/smem_log.c	2013-12-17 17:08:05.686151032 -0800
@@ -155,10 +155,7 @@
 	{ SMEM_LOG_ERROR_EVENT_BASE, "ERROR" },
 	{ SMEM_LOG_DCVS_EVENT_BASE, "DCVS" },
 	{ SMEM_LOG_SLEEP_EVENT_BASE, "SLEEP" },
-	{ SMEM_LOG_RPC_ROUTER_EVENT_BASE, "RPCROUTER" },
-	{ SMEM_LOG_QMI_CCI_EVENT_BASE, "QCCI" },
-	{ SMEM_LOG_QMI_CSI_EVENT_BASE, "QCSI" },
-	{ SMEM_LOG_IPC_ROUTER_EVENT_BASE, "IPCROUTER" },
+	{ SMEM_LOG_RPC_ROUTER_EVENT_BASE, "ROUTER" },
 };
 
 struct sym event_syms[] = {
diff --unified -r mach-msm/socinfo.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/socinfo.c
--- mach-msm/socinfo.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/socinfo.c	2013-12-17 17:08:05.686151032 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -35,7 +35,6 @@
 	HW_PLATFORM_LIQUID  = 9,
 	/* Dragonboard platform id is assigned as 10 in CDT */
 	HW_PLATFORM_DRAGON	= 10,
-	HW_PLATFORM_QRD	= 11,
 	HW_PLATFORM_INVALID
 };
 
@@ -48,8 +47,7 @@
 	[HW_PLATFORM_SVLTE_SURF] = "SLVTE_SURF",
 	[HW_PLATFORM_MTP] = "MTP",
 	[HW_PLATFORM_LIQUID] = "Liquid",
-	[HW_PLATFORM_DRAGON] = "Dragon",
-	[HW_PLATFORM_QRD] = "QRD",
+	[HW_PLATFORM_DRAGON] = "Dragon"
 };
 
 enum {
@@ -236,7 +234,6 @@
 	[117] = MSM_CPU_8930,
 	[118] = MSM_CPU_8930,
 	[119] = MSM_CPU_8930,
-	[179] = MSM_CPU_8930,
 
 	/* 8627 IDs */
 	[120] = MSM_CPU_8627,
@@ -282,7 +279,6 @@
 	[143] = MSM_CPU_8930AA,
 	[144] = MSM_CPU_8930AA,
 	[160] = MSM_CPU_8930AA,
-	[180] = MSM_CPU_8930AA,
 
 	/* 8226 IDs */
 	[145] = MSM_CPU_8226,
@@ -298,7 +294,6 @@
 	[155] = MSM_CPU_8930AB,
 	[156] = MSM_CPU_8930AB,
 	[157] = MSM_CPU_8930AB,
-	[181] = MSM_CPU_8930AB,
 
 	/* 8064AA IDs */
 	[172] = MSM_CPU_8064AA,
@@ -330,52 +325,7 @@
 {
 	return (socinfo) ? socinfo->v1.build_id : NULL;
 }
-#ifdef CONFIG_SEC_FACTORY
-uint32_t socinfo_get_iddq(void)
-{
-	void __iomem *pte_efuse;
-	uint32_t pte_efuse_val;
-	uint32_t qfprom_iddq;
-	
-	pte_efuse = ioremap(0x007000C4, 4);
-	if (!pte_efuse) {
-		pr_err("%s : Unable to map QFPROM base\n", __func__);
-		return 0;
-	}
-	
-	pte_efuse_val = readl_relaxed(pte_efuse);
-	iounmap(pte_efuse);
 
-	qfprom_iddq = pte_efuse_val & 0xFFFFFFFF;
-
-	return qfprom_iddq;
-}
-
-uint32_t socinfo_get_pvs(void)
-{
-	void __iomem *pte_efuse;
-	uint32_t pte_efuse_val;
-	uint32_t pvs_bin;
-
-	pte_efuse = ioremap(0x007000C0, 4);
-	if (!pte_efuse) {
-		pr_err("%s : Unable to map QFPROM base\n", __func__);
-		return 0;
-	}
-	
-	pte_efuse_val = readl_relaxed(pte_efuse);
-	iounmap(pte_efuse);
-
-	pvs_bin = (pte_efuse_val >> 10) & 0x7;
-	if (pvs_bin == 0x7)
-		pvs_bin = (pte_efuse_val >> 13) & 0x7;
-
-	if (pvs_bin == 0x7)
-		pvs_bin = 0;
-
-	return pvs_bin;
-}
-#endif
 uint32_t socinfo_get_raw_id(void)
 {
 	return socinfo ?
@@ -485,34 +435,8 @@
 
 	return snprintf(buf, PAGE_SIZE, "%-.32s\n", socinfo_get_build_id());
 }
-#ifdef CONFIG_SEC_FACTORY
-static ssize_t
-socinfo_show_soc_iddq(struct sys_device *dev,
-		      struct sysdev_attribute *attr,
-		      char *buf)
-{
-	if (!socinfo) {
-		pr_err("%s: No socinfo found!\n", __func__);
-		return 0;
-	}
-
-	return snprintf(buf, PAGE_SIZE, "%x\n", socinfo_get_iddq());
-}
 
 static ssize_t
-socinfo_show_soc_pvs(struct sys_device *dev,
-		      struct sysdev_attribute *attr,
-		      char *buf)
-{
-	if (!socinfo) {
-		pr_err("%s: No socinfo found!\n", __func__);
-		return 0;
-	}
-
-	return snprintf(buf, PAGE_SIZE, "%x\n", socinfo_get_pvs());
-}
-#endif
-static ssize_t
 socinfo_show_raw_id(struct sys_device *dev,
 		    struct sysdev_attribute *attr,
 		    char *buf)
@@ -674,10 +598,6 @@
 	_SYSDEV_ATTR(id, 0444, socinfo_show_id, NULL),
 	_SYSDEV_ATTR(version, 0444, socinfo_show_version, NULL),
 	_SYSDEV_ATTR(build_id, 0444, socinfo_show_build_id, NULL),
-#ifdef CONFIG_SEC_FACTORY
-	_SYSDEV_ATTR(soc_iddq, 0444, socinfo_show_soc_iddq, NULL),
-	_SYSDEV_ATTR(soc_pvs, 0444, socinfo_show_soc_pvs, NULL),
-#endif
 };
 
 static struct sysdev_attribute socinfo_v2_files[] = {
diff --unified -r mach-msm/subsystem_map.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/subsystem_map.c
--- mach-msm/subsystem_map.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/subsystem_map.c	2013-12-17 17:08:05.690151025 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -256,8 +256,6 @@
 
 	subsys_domain = msm_get_iommu_domain(msm_subsystem_get_domain_no
 								(subsys_id));
-	if (!subsys_domain)
-		return -EINVAL;
 
 	return iommu_iova_to_phys(subsys_domain, iova);
 }
@@ -412,8 +410,8 @@
 
 			if (flags & MSM_SUBSYSTEM_MAP_IOMMU_2X)
 				msm_iommu_map_extra
-					(d, temp_va, length, SZ_4K,
-					(IOMMU_READ | IOMMU_WRITE));
+					(d, temp_va, phys, length, SZ_4K,
+					IOMMU_READ);
 		}
 
 	}
@@ -431,18 +429,15 @@
 	return buf;
 
 outiova:
-	if (flags & MSM_SUBSYSTEM_MAP_IOVA) {
-		if (d)
-			iommu_unmap(d, temp_va, SZ_4K);
-	}
+	if (flags & MSM_SUBSYSTEM_MAP_IOVA)
+		iommu_unmap(d, temp_va, SZ_4K);
 outdomain:
 	if (flags & MSM_SUBSYSTEM_MAP_IOVA) {
 		/* Unmap the rest of the current domain, i */
-		if (d) {
-			for (j -= SZ_4K, temp_va -= SZ_4K;
-				j > 0; temp_va -= SZ_4K, j -= SZ_4K)
-				iommu_unmap(d, temp_va, SZ_4K);
-		}
+		for (j -= SZ_4K, temp_va -= SZ_4K;
+			j > 0; temp_va -= SZ_4K, j -= SZ_4K)
+			iommu_unmap(d, temp_va, SZ_4K);
+
 		/* Unmap all the other domains */
 		for (i--; i >= 0; i--) {
 			unsigned int domain_no, partition_no;
@@ -452,14 +447,10 @@
 			partition_no = msm_subsystem_get_partition_no(
 								subsys_ids[i]);
 
-			d = msm_get_iommu_domain(domain_no);
-
-			if (d) {
-				temp_va = buf->iova[i];
-				for (j = length; j > 0; j -= SZ_4K,
-							temp_va += SZ_4K)
-					iommu_unmap(d, temp_va, SZ_4K);
-			}
+			temp_va = buf->iova[i];
+			for (j = length; j > 0; j -= SZ_4K,
+						temp_va += SZ_4K)
+				iommu_unmap(d, temp_va, SZ_4K);
 			msm_free_iova_address(buf->iova[i], domain_no,
 					partition_no, length);
 		}
@@ -515,9 +506,6 @@
 						msm_subsystem_get_domain_no(
 						node->subsystems[i]));
 
-				if (!subsys_domain)
-					continue;
-
 				domain_no = msm_subsystem_get_domain_no(
 							node->subsystems[i]);
 				partition_no = msm_subsystem_get_partition_no(
diff --unified -r mach-msm/subsystem_restart.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/subsystem_restart.c
--- mach-msm/subsystem_restart.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/subsystem_restart.c	2013-12-17 17:08:05.690151025 -0800
@@ -55,18 +55,6 @@
 	struct list_head list;
 };
 
-enum subsys_state {
-	SUBSYS_OFFLINE,
-	SUBSYS_ONLINE,
-	SUBSYS_CRASHED,
-};
-
-static const char * const subsys_states[] = {
-	[SUBSYS_OFFLINE] = "OFFLINE",
-	[SUBSYS_ONLINE] = "ONLINE",
-	[SUBSYS_CRASHED] = "CRASHED",
-};
-
 struct subsys_device {
 	struct subsys_desc *desc;
 	struct list_head list;
@@ -74,8 +62,7 @@
 	char wlname[64];
 	struct work_struct work;
 	spinlock_t restart_lock;
-	bool restarting;
-	enum subsys_state state;
+	int restart_count;
 
 	void *notify;
 
@@ -131,20 +118,6 @@
 	&restart_orders_8960_fusion_sglte,
 	};
 
-/* SGLTE2 restart ordering info*/
-static const char * const order_8064_sglte2[] = {"external_modem",
-						"external_modem_mdm"};
-
-static struct subsys_soc_restart_order restart_orders_8064_fusion_sglte2 = {
-	.subsystem_list = order_8064_sglte2,
-	.count = ARRAY_SIZE(order_8064_sglte2),
-	.subsys_ptrs = {[ARRAY_SIZE(order_8064_sglte2)] = NULL}
-	};
-
-static struct subsys_soc_restart_order *restart_orders_8064_sglte2[] = {
-	&restart_orders_8064_fusion_sglte2,
-	};
-
 /* These will be assigned to one of the sets above after
  * runtime SoC identification.
  */
@@ -163,7 +136,6 @@
 {
 	int ret;
 	int old_val = restart_level;
-	int subtype;
 
 	if (cpu_is_msm9615()) {
 		pr_err("Only Phase 1 subsystem restart is supported\n");
@@ -176,9 +148,7 @@
 
 	switch (restart_level) {
 	case RESET_SUBSYS_INDEPENDENT:
-		subtype = socinfo_get_platform_subtype();
-		if ((subtype == PLATFORM_SUBTYPE_SGLTE) ||
-			(subtype == PLATFORM_SUBTYPE_SGLTE2)) {
+		if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE) {
 			pr_info("Phase 3 is currently unsupported. Using phase 2 instead.\n");
 			restart_level = RESET_SUBSYS_COUPLED;
 		}
@@ -196,20 +166,6 @@
 module_param_call(restart_level, restart_level_set, param_get_int,
 			&restart_level, 0644);
 
-static void subsys_set_state(struct subsys_device *subsys,
-			     enum subsys_state state)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&subsys->restart_lock, flags);
-	if (subsys->state != state) {
-		subsys->state = state;
-		spin_unlock_irqrestore(&subsys->restart_lock, flags);
-		return;
-	}
-	spin_unlock_irqrestore(&subsys->restart_lock, flags);
-}
-
 static struct subsys_soc_restart_order *
 update_restart_order(struct subsys_device *dev)
 {
@@ -290,7 +246,7 @@
 	if (time_first && n >= max_restarts_check) {
 		if ((curr_time->tv_sec - time_first->tv_sec) <
 				max_history_time_check) {
-			panic("Subsystems have crashed %d times in less than "\
+			WARN(1, "Subsystems have crashed %d times in less than "\
 				"%ld seconds!", max_restarts_check,
 				max_history_time_check);
 		}
@@ -330,10 +286,9 @@
 
 	pr_info("[%p]: Shutting down %s\n", current, name);
 	if (dev->desc->shutdown(dev->desc) < 0) {
-		panic("subsys-restart: [%p]: Failed to shutdown %s!",
+		WARN(1, "subsys-restart: [%p]: Failed to shutdown %s!",
 			current, name);
 	}
-	subsys_set_state(dev, SUBSYS_OFFLINE);
 }
 
 static void subsystem_ramdump(struct subsys_device *dev, void *data)
@@ -351,9 +306,8 @@
 
 	pr_info("[%p]: Powering up %s\n", current, name);
 	if (dev->desc->powerup(dev->desc) < 0) {
-		panic("[%p]: Failed to powerup %s!", current, name);
+		WARN(1, "[%p]: Failed to powerup %s!", current, name);
 	}
-	subsys_set_state(dev, SUBSYS_ONLINE);
 }
 
 static void subsystem_restart_wq_func(struct work_struct *work)
@@ -403,13 +357,10 @@
 	 * Now that we've acquired the shutdown lock, either we're the first to
 	 * restart these subsystems or some other thread is doing the powerup
 	 * sequence for these subsystems. In the latter case, panic and bail
-	 * out, since a subsystem died in its powerup sequence. This catches
-	 * the case where a subsystem in a restart order isn't the one
-	 * who initiated the original restart but has crashed while the restart
-	 * order is being rebooted.
+	 * out, since a subsystem died in its powerup sequence.
 	 */
 	if (!mutex_trylock(powerup_lock)) {
-		panic("%s[%p]: Subsystem died during powerup!",
+		WARN(1, "%s[%p]: Subsystem died during powerup!",
 						__func__, current);
 	}
 
@@ -454,53 +405,38 @@
 
 out:
 	spin_lock_irqsave(&dev->restart_lock, flags);
-	dev->restarting = false;
-	wake_unlock(&dev->wake_lock);
+	dev->restart_count--;
+	if (!dev->restart_count)
+		wake_unlock(&dev->wake_lock);
 	spin_unlock_irqrestore(&dev->restart_lock, flags);
 }
 
 static void __subsystem_restart_dev(struct subsys_device *dev)
 {
 	struct subsys_desc *desc = dev->desc;
-	const char *name = dev->desc->name;
 	unsigned long flags;
 
 	pr_debug("Restarting %s [level=%d]!\n", desc->name, restart_level);
 
-	/*
-	 * We want to allow drivers to call subsystem_restart{_dev}() as many
-	 * times as they want up until the point where the subsystem is
-	 * shutdown.
-	 */
 	spin_lock_irqsave(&dev->restart_lock, flags);
-	if (dev->state != SUBSYS_CRASHED) {
-		if (dev->state == SUBSYS_ONLINE && !dev->restarting) {
-			dev->restarting = true;
-			dev->state = SUBSYS_CRASHED;
-			wake_lock(&dev->wake_lock);
-			queue_work(ssr_wq, &dev->work);
-		} else {
-			panic("Subsystem %s crashed during SSR!", name);
-		}
-	}
+	if (!dev->restart_count)
+		wake_lock(&dev->wake_lock);
+	dev->restart_count++;
 	spin_unlock_irqrestore(&dev->restart_lock, flags);
+
+	if (!queue_work(ssr_wq, &dev->work)) {
+		spin_lock_irqsave(&dev->restart_lock, flags);
+		dev->restart_count--;
+		if (!dev->restart_count)
+			wake_unlock(&dev->wake_lock);
+		spin_unlock_irqrestore(&dev->restart_lock, flags);
+	}
 }
 
 int subsystem_restart_dev(struct subsys_device *dev)
 {
 	const char *name = dev->desc->name;
 
-	/*
-	 * If a system reboot/shutdown is underway, ignore subsystem errors.
-	 * However, print a message so that we know that a subsystem behaved
-	 * unexpectedly here.
-	 */
-	if (system_state == SYSTEM_RESTART
-		|| system_state == SYSTEM_POWER_OFF) {
-		pr_err("%s crashed during a system poweroff/shutdown.\n", name);
-		return -EBUSY;
-	}
-
 	pr_info("Restart sequence requested for %s, restart_level = %d.\n",
 		name, restart_level);
 
@@ -562,7 +498,6 @@
 	dev->desc = desc;
 	dev->notify = subsys_notif_add_subsys(desc->name);
 	dev->restart_order = update_restart_order(dev);
-	dev->state = SUBSYS_ONLINE; /* Until proper refcounting appears */
 
 	snprintf(dev->wlname, sizeof(dev->wlname), "ssr(%s)", desc->name);
 	wake_lock_init(&dev->wake_lock, WAKE_LOCK_SUSPEND, dev->wlname);
@@ -634,20 +569,11 @@
 		n_restart_orders = ARRAY_SIZE(restart_orders_8960_sglte);
 	}
 
-	if (socinfo_get_platform_subtype() == PLATFORM_SUBTYPE_SGLTE2) {
-		restart_orders = restart_orders_8064_sglte2;
-		n_restart_orders = ARRAY_SIZE(restart_orders_8064_sglte2);
-	}
-
 	for (i = 0; i < n_restart_orders; i++) {
 		mutex_init(&restart_orders[i]->powerup_lock);
 		mutex_init(&restart_orders[i]->shutdown_lock);
 	}
 
-	if (restart_orders == NULL || n_restart_orders < 1) {
-		WARN_ON(1);
-	}
-
 	return 0;
 }
 
@@ -656,9 +582,11 @@
 #ifdef CONFIG_SEC_DEBUG_MDM_FILE_INFO
 	restart_level = RESET_SUBSYS_INDEPENDENT_SOC;
 #endif
-	ssr_wq = alloc_workqueue("ssr_wq", WQ_CPU_INTENSIVE, 0);
-	if (!ssr_wq)
-		panic("%s: out of memory\n", __func__);
+	ssr_wq = alloc_workqueue("ssr_wq", 0, 0);
+	if (!ssr_wq) {
+		pr_err("%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
 
 	return ssr_init_soc_restart_orders();
 }
diff --unified -r mach-msm/sysmon.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/sysmon.c
--- mach-msm/sysmon.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/sysmon.c	2013-12-17 17:08:05.690151025 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -45,17 +45,15 @@
 	char			rx_buf[RX_BUF_SIZE];
 	enum transports		transport;
 	struct device		*dev;
-	enum hsic_sysmon_device_id hsic_id;
 };
 
 static struct sysmon_subsys subsys[SYSMON_NUM_SS] = {
-	[SYSMON_SS_MODEM].transport      = TRANSPORT_SMD,
-	[SYSMON_SS_LPASS].transport      = TRANSPORT_SMD,
-	[SYSMON_SS_WCNSS].transport      = TRANSPORT_SMD,
-	[SYSMON_SS_DSPS].transport       = TRANSPORT_SMD,
-	[SYSMON_SS_Q6FW].transport       = TRANSPORT_SMD,
-	[SYSMON_SS_EXT_MODEM].transport  = TRANSPORT_HSIC,
-	[SYSMON_SS_EXT_MODEM2].transport = TRANSPORT_HSIC,
+	[SYSMON_SS_MODEM].transport     = TRANSPORT_SMD,
+	[SYSMON_SS_LPASS].transport     = TRANSPORT_SMD,
+	[SYSMON_SS_WCNSS].transport     = TRANSPORT_SMD,
+	[SYSMON_SS_DSPS].transport      = TRANSPORT_SMD,
+	[SYSMON_SS_Q6FW].transport      = TRANSPORT_SMD,
+	[SYSMON_SS_EXT_MODEM].transport = TRANSPORT_HSIC,
 };
 
 static const char *notif_name[SUBSYS_NOTIF_TYPE_COUNT] = {
@@ -91,10 +89,11 @@
 	size_t actual_len;
 
 	pr_debug("Sending HSIC message: %s\n", tx_buf);
-	ret = hsic_sysmon_write(ss->hsic_id, tx_buf, len, TIMEOUT_MS);
+	ret = hsic_sysmon_write(HSIC_SYSMON_DEV_EXT_MODEM,
+				tx_buf, len, TIMEOUT_MS);
 	if (ret)
 		return ret;
-	ret = hsic_sysmon_read(ss->hsic_id, ss->rx_buf,
+	ret = hsic_sysmon_read(HSIC_SYSMON_DEV_EXT_MODEM, ss->rx_buf,
 			       ARRAY_SIZE(ss->rx_buf), &actual_len, TIMEOUT_MS);
 	return ret;
 }
@@ -303,9 +302,7 @@
 		if (pdev->id < SMD_NUM_TYPE)
 			return -EINVAL;
 
-		ss->hsic_id = HSIC_SYSMON_DEV_EXT_MODEM +
-				(pdev->id - SYSMON_SS_EXT_MODEM);
-		ret = hsic_sysmon_open(ss->hsic_id);
+		ret = hsic_sysmon_open(HSIC_SYSMON_DEV_EXT_MODEM);
 		if (ret) {
 			pr_err("HSIC open failed\n");
 			return ret;
@@ -331,7 +328,7 @@
 		smd_close(ss->chan);
 		break;
 	case TRANSPORT_HSIC:
-		hsic_sysmon_close(ss->hsic_id);
+		hsic_sysmon_close(HSIC_SYSMON_DEV_EXT_MODEM);
 		break;
 	}
 	mutex_unlock(&ss->lock);
diff --unified -r mach-msm/sysmon.h /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/sysmon.h
--- mach-msm/sysmon.h	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/sysmon.h	2013-12-17 17:08:05.690151025 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -31,7 +31,6 @@
 
 	/* Non-SMD subsystems */
 	SYSMON_SS_EXT_MODEM = SMD_NUM_TYPE,
-	SYSMON_SS_EXT_MODEM2,
 	SYSMON_NUM_SS
 };
 
diff --unified -r mach-msm/timer.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/timer.c
--- mach-msm/timer.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/timer.c	2013-12-17 17:08:05.690151025 -0800
@@ -23,12 +23,14 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/percpu.h>
+#include <linux/mm.h>
 
 #include <asm/localtimer.h>
 #include <asm/mach/time.h>
 #include <asm/hardware/gic.h>
 #include <asm/sched_clock.h>
 #include <asm/smp_plat.h>
+#include <asm/user_accessible_timer.h>
 #include <mach/msm_iomap.h>
 #include <mach/irqs.h>
 #include <mach/socinfo.h>
@@ -290,6 +292,8 @@
 
 	clock = clockevent_to_clock(evt);
 	clock_state = &__get_cpu_var(msm_clocks_percpu)[clock->index];
+	if (clock_state->stopped)
+		return 0;
 	now = msm_read_timer_count(clock, LOCAL_TIMER);
 	alarm = now + (cycles << clock->shift);
 	if (clock->flags & MSM_CLOCK_FLAGS_ODD_MATCH_WRITE)
@@ -938,11 +942,12 @@
 	return cs->read(NULL);
 }
 
-int read_current_timer(unsigned long *timer_val)
+static struct delay_timer msm_delay_timer;
+
+static unsigned long msm_read_current_timer(void)
 {
 	struct msm_clock *dgt = &msm_clocks[MSM_CLOCK_DGT];
-	*timer_val = msm_read_timer_count(dgt, GLOBAL_TIMER);
-	return 0;
+	return msm_read_timer_count(dgt, GLOBAL_TIMER);
 }
 
 static void __init msm_sched_clock_init(void)
@@ -1161,13 +1166,23 @@
 	}
 	msm_sched_clock_init();
 
-#ifdef ARCH_HAS_READ_CURRENT_TIMER
+	if (use_user_accessible_timers()) {
+		if (cpu_is_msm8960() || cpu_is_msm8930() || cpu_is_apq8064()) {
+			struct msm_clock *gtclock = &msm_clocks[MSM_CLOCK_GPT];
+			void __iomem *addr = gtclock->regbase +
+				TIMER_COUNT_VAL + global_timer_offset;
+			setup_user_timer_offset(virt_to_phys(addr)&0xfff);
+			set_user_accessible_timer_flag(true);
+		}
+	}
+
 	if (is_smp()) {
 		__raw_writel(1,
 			msm_clocks[MSM_CLOCK_DGT].regbase + TIMER_ENABLE);
-		set_delay_fn(read_current_timer_delay_loop);
+		msm_delay_timer.freq = dgt->freq;
+		msm_delay_timer.read_current_timer = &msm_read_current_timer;
+		register_current_timer_delay(&msm_delay_timer);
 	}
-#endif
 
 #ifdef CONFIG_LOCAL_TIMERS
 	local_timer_register(&msm_lt_ops);
Only in /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm: timer_page.c
diff --unified -r mach-msm/wcnss-ssr-8960.c /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/wcnss-ssr-8960.c
--- mach-msm/wcnss-ssr-8960.c	2013-12-11 02:38:30.000000000 -0800
+++ /home/shade/dev/cm/11/kernel/samsung/jf/arch/arm/mach-msm/wcnss-ssr-8960.c	2013-12-17 17:08:05.690151025 -0800
@@ -50,8 +50,6 @@
 
 	pr_err("%s: smsm state changed\n", MODULE_NAME);
 
-	wcnss_riva_dump_pmic_regs();
-
 	if (!(new_state & SMSM_RESET))
 		return;
 
@@ -239,7 +237,7 @@
 		goto out;
 	}
 	ret = request_irq(RIVA_APSS_WDOG_BITE_RESET_RDY_IRQ,
-			riva_wdog_bite_irq_hdlr, IRQF_TRIGGER_RISING,
+			riva_wdog_bite_irq_hdlr, IRQF_TRIGGER_HIGH,
 				"riva_wdog", NULL);
 
 	if (ret < 0) {
