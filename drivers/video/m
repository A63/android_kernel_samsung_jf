diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/external_common.c msm/external_common.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/external_common.c	2013-12-17 17:08:08.010147360 -0800
+++ msm/external_common.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -31,6 +31,8 @@
 #include "mdp.h"
 
 struct external_common_state_type *external_common_state;
+static int number_of_sad;
+
 EXPORT_SYMBOL(external_common_state);
 DEFINE_MUTEX(external_common_state_hpd_mutex);
 EXPORT_SYMBOL(external_common_state_hpd_mutex);
@@ -102,75 +104,14 @@
 const char *video_format_2string(uint32 format)
 {
 	switch (format) {
-	default:
-#ifdef CONFIG_FB_MSM_HDMI_COMMON
-	case HDMI_VFRMT_640x480p60_4_3:    return " 640x 480 p60  4/3";
-	case HDMI_VFRMT_720x480p60_4_3:    return " 720x 480 p60  4/3";
-	case HDMI_VFRMT_720x480p60_16_9:   return " 720x 480 p60 16/9";
-	case HDMI_VFRMT_1280x720p60_16_9:  return "1280x 720 p60 16/9";
-	case HDMI_VFRMT_1920x1080i60_16_9: return "1920x1080 i60 16/9";
-	case HDMI_VFRMT_1440x480i60_4_3:   return "1440x 480 i60  4/3";
-	case HDMI_VFRMT_1440x480i60_16_9:  return "1440x 480 i60 16/9";
-	case HDMI_VFRMT_1440x240p60_4_3:   return "1440x 240 p60  4/3";
-	case HDMI_VFRMT_1440x240p60_16_9:  return "1440x 240 p60 16/9";
-	case HDMI_VFRMT_2880x480i60_4_3:   return "2880x 480 i60  4/3";
-	case HDMI_VFRMT_2880x480i60_16_9:  return "2880x 480 i60 16/9";
-	case HDMI_VFRMT_2880x240p60_4_3:   return "2880x 240 p60  4/3";
-	case HDMI_VFRMT_2880x240p60_16_9:  return "2880x 240 p60 16/9";
-	case HDMI_VFRMT_1440x480p60_4_3:   return "1440x 480 p60  4/3";
-	case HDMI_VFRMT_1440x480p60_16_9:  return "1440x 480 p60 16/9";
-	case HDMI_VFRMT_1920x1080p60_16_9: return "1920x1080 p60 16/9";
-	case HDMI_VFRMT_720x576p50_4_3:    return " 720x 576 p50  4/3";
-	case HDMI_VFRMT_720x576p50_16_9:   return " 720x 576 p50 16/9";
-	case HDMI_VFRMT_1280x720p50_16_9:  return "1280x 720 p50 16/9";
-	case HDMI_VFRMT_1920x1080i50_16_9: return "1920x1080 i50 16/9";
-	case HDMI_VFRMT_1440x576i50_4_3:   return "1440x 576 i50  4/3";
-	case HDMI_VFRMT_1440x576i50_16_9:  return "1440x 576 i50 16/9";
-	case HDMI_VFRMT_1440x288p50_4_3:   return "1440x 288 p50  4/3";
-	case HDMI_VFRMT_1440x288p50_16_9:  return "1440x 288 p50 16/9";
-	case HDMI_VFRMT_2880x576i50_4_3:   return "2880x 576 i50  4/3";
-	case HDMI_VFRMT_2880x576i50_16_9:  return "2880x 576 i50 16/9";
-	case HDMI_VFRMT_2880x288p50_4_3:   return "2880x 288 p50  4/3";
-	case HDMI_VFRMT_2880x288p50_16_9:  return "2880x 288 p50 16/9";
-	case HDMI_VFRMT_1440x576p50_4_3:   return "1440x 576 p50  4/3";
-	case HDMI_VFRMT_1440x576p50_16_9:  return "1440x 576 p50 16/9";
-	case HDMI_VFRMT_1920x1080p50_16_9: return "1920x1080 p50 16/9";
-	case HDMI_VFRMT_1920x1080p24_16_9: return "1920x1080 p24 16/9";
-	case HDMI_VFRMT_1920x1080p25_16_9: return "1920x1080 p25 16/9";
-	case HDMI_VFRMT_1920x1080p30_16_9: return "1920x1080 p30 16/9";
-	case HDMI_VFRMT_2880x480p60_4_3:   return "2880x 480 p60  4/3";
-	case HDMI_VFRMT_2880x480p60_16_9:  return "2880x 480 p60 16/9";
-	case HDMI_VFRMT_2880x576p50_4_3:   return "2880x 576 p50  4/3";
-	case HDMI_VFRMT_2880x576p50_16_9:  return "2880x 576 p50 16/9";
-	case HDMI_VFRMT_1920x1250i50_16_9: return "1920x1250 i50 16/9";
-	case HDMI_VFRMT_1920x1080i100_16_9:return "1920x1080 i100 16/9";
-	case HDMI_VFRMT_1280x720p100_16_9: return "1280x 720 p100 16/9";
-	case HDMI_VFRMT_720x576p100_4_3:   return " 720x 576 p100  4/3";
-	case HDMI_VFRMT_720x576p100_16_9:  return " 720x 576 p100 16/9";
-	case HDMI_VFRMT_1440x576i100_4_3:  return "1440x 576 i100  4/3";
-	case HDMI_VFRMT_1440x576i100_16_9: return "1440x 576 i100 16/9";
-	case HDMI_VFRMT_1920x1080i120_16_9:return "1920x1080 i120 16/9";
-	case HDMI_VFRMT_1280x720p120_16_9: return "1280x 720 p120 16/9";
-	case HDMI_VFRMT_720x480p120_4_3:   return " 720x 480 p120  4/3";
-	case HDMI_VFRMT_720x480p120_16_9:  return " 720x 480 p120 16/9";
-	case HDMI_VFRMT_1440x480i120_4_3:  return "1440x 480 i120  4/3";
-	case HDMI_VFRMT_1440x480i120_16_9: return "1440x 480 i120 16/9";
-	case HDMI_VFRMT_720x576p200_4_3:   return " 720x 576 p200  4/3";
-	case HDMI_VFRMT_720x576p200_16_9:  return " 720x 576 p200 16/9";
-	case HDMI_VFRMT_1440x576i200_4_3:  return "1440x 576 i200  4/3";
-	case HDMI_VFRMT_1440x576i200_16_9: return "1440x 576 i200 16/9";
-	case HDMI_VFRMT_720x480p240_4_3:   return " 720x 480 p240  4/3";
-	case HDMI_VFRMT_720x480p240_16_9:  return " 720x 480 p240 16/9";
-	case HDMI_VFRMT_1440x480i240_4_3:  return "1440x 480 i240  4/3";
-	case HDMI_VFRMT_1440x480i240_16_9: return "1440x 480 i240 16/9";
-#elif defined(CONFIG_FB_MSM_TVOUT)
+#if defined(CONFIG_FB_MSM_TVOUT)
 	case TVOUT_VFRMT_NTSC_M_720x480i:     return "NTSC_M_720x480i";
 	case TVOUT_VFRMT_NTSC_J_720x480i:     return "NTSC_J_720x480i";
 	case TVOUT_VFRMT_PAL_BDGHIN_720x576i: return "PAL_BDGHIN_720x576i";
 	case TVOUT_VFRMT_PAL_M_720x480i:      return "PAL_M_720x480i";
 	case TVOUT_VFRMT_PAL_N_720x480i:      return "PAL_N_720x480i";
 #endif
-
+	default: return "???";
 	}
 }
 EXPORT_SYMBOL(video_format_2string);
@@ -179,83 +120,24 @@
 	struct device_attribute *attr, char *buf)
 {
 	ssize_t ret = snprintf(buf, PAGE_SIZE, "%s\n",
-		video_format_2string(external_common_state->video_resolution));
+		msm_hdmi_mode_2string(external_common_state->video_resolution));
 	DEV_DBG("%s: '%s'\n", __func__,
-		video_format_2string(external_common_state->video_resolution));
+		msm_hdmi_mode_2string(external_common_state->video_resolution));
 	return ret;
 }
 
 #ifdef CONFIG_FB_MSM_HDMI_COMMON
-struct hdmi_disp_mode_timing_type
-	hdmi_common_supported_video_mode_lut[HDMI_VFRMT_MAX] = {
-	HDMI_SETTINGS_640x480p60_4_3,
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x720p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x240p60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x240p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x480i60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x480i60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x240p60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x240p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480p60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x720p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x288p50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x288p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x576i50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x576i50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x288p50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x288p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576p50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p24_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p25_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p30_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x480p60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x480p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x576p50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x576p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1250i50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i100_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x720p100_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p100_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p100_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i100_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i100_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i120_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x720p120_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p120_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p120_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i120_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i120_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p200_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p200_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i200_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i200_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p240_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p240_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i240_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i240_16_9),
-};
+struct msm_hdmi_mode_timing_info
+	hdmi_common_supported_video_mode_lut[HDMI_VFRMT_MAX];
 EXPORT_SYMBOL(hdmi_common_supported_video_mode_lut);
 
-struct hdmi_disp_mode_timing_type
+struct msm_hdmi_mode_timing_info
 	hdmi_mhl_supported_video_mode_lut[HDMI_VFRMT_MAX] = {
-	HDMI_SETTINGS_640x480p60_4_3,
+	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_UNKNOWN),
+	HDMI_VFRMT_640x480p60_4_3_TIMING,
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p60_4_3),
-	HDMI_SETTINGS_720x480p60_16_9,
-	HDMI_SETTINGS_1280x720p60_16_9,
+	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p60_16_9),
+	HDMI_VFRMT_1280x720p60_16_9_TIMING,
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i60_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i60_4_3),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i60_16_9),
@@ -269,7 +151,7 @@
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480p60_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p60_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p50_4_3),
-	HDMI_SETTINGS_720x576p50_16_9,
+	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p50_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x720p50_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i50_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i50_4_3),
@@ -283,9 +165,9 @@
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576p50_4_3),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576p50_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p50_16_9),
-	HDMI_SETTINGS_1920x1080p24_16_9,
-	HDMI_SETTINGS_1920x1080p25_16_9,
-	HDMI_SETTINGS_1920x1080p30_16_9,
+	HDMI_VFRMT_1920x1080p24_16_9_TIMING,
+	HDMI_VFRMT_1920x1080p25_16_9_TIMING,
+	HDMI_VFRMT_1920x1080p30_16_9_TIMING,
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x480p60_4_3),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x480p60_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_2880x576p50_4_3),
@@ -311,6 +193,7 @@
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p240_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i240_4_3),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i240_16_9),
+	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x1024p60_5_4),
 };
 EXPORT_SYMBOL(hdmi_mhl_supported_video_mode_lut);
 
@@ -327,28 +210,28 @@
 		for (i = 0; i < external_common_state->disp_mode_list
 			.num_of_elements; ++i) {
 			if (ret > 0)
-				ret += snprintf(buf+ret, PAGE_SIZE-ret, ",%d",
-					*video_mode++ + 1);
+				ret += scnprintf(buf+ret, PAGE_SIZE-ret, ",%d",
+					*video_mode++);
 			else
-				ret += snprintf(buf+ret, PAGE_SIZE-ret, "%d",
-					*video_mode++ + 1);
+				ret += scnprintf(buf+ret, PAGE_SIZE-ret, "%d",
+					*video_mode++);
 		}
 	} else
-		ret += snprintf(buf+ret, PAGE_SIZE-ret, "%d",
+		ret += scnprintf(buf+ret, PAGE_SIZE-ret, "%d",
 			external_common_state->video_resolution+1);
 
 	if (hdmi_forced_resolution >= 0)
 		ret = snprintf(buf, PAGE_SIZE, "%d", hdmi_forced_resolution+1);
 
 	DEV_DBG("%s: '%s'\n", __func__, buf);
-	ret += snprintf(buf+ret, PAGE_SIZE-ret, "\n");
+	ret += scnprintf(buf+ret, PAGE_SIZE-ret, "\n");
 	return ret;
 }
 
 static ssize_t hdmi_common_rda_edid_physical_address(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	ssize_t ret = snprintf(buf, PAGE_SIZE, "%d\n",
+	ssize_t ret = scnprintf(buf, PAGE_SIZE, "%d\n",
 		external_common_state->physical_address);
 
 	DEV_DBG("%s: '%d'\n", __func__,
@@ -360,7 +243,7 @@
 static ssize_t hdmi_common_rda_edid_scan_info(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	ssize_t ret = snprintf(buf, PAGE_SIZE, "%d, %d, %d\n",
+	ssize_t ret = scnprintf(buf, PAGE_SIZE, "%d, %d, %d\n",
 		external_common_state->pt_scan_info,
 		external_common_state->it_scan_info,
 		external_common_state->ce_scan_info);
@@ -373,10 +256,12 @@
 {
 	uint8 *s = (uint8 *) buf;
 	uint8 *d = external_common_state->spd_vendor_name;
+	ssize_t sz;
 	ssize_t ret = strnlen(buf, PAGE_SIZE);
 	ret = (ret > 8) ? 8 : ret;
 
-	memset(external_common_state->spd_vendor_name, 0, 8);
+	sz = sizeof(external_common_state->spd_vendor_name);
+	memset(external_common_state->spd_vendor_name, 0, sz);
 	while (*s) {
 		if (*s & 0x60 && *s ^ 0x7f) {
 			*d = *s;
@@ -390,6 +275,7 @@
 
 		d++;
 	}
+	external_common_state->spd_vendor_name[sz - 1] = 0;
 
 	DEV_DBG("%s: '%s'\n", __func__,
 			external_common_state->spd_vendor_name);
@@ -414,9 +300,11 @@
 	uint8 *s = (uint8 *) buf;
 	uint8 *d = external_common_state->spd_product_description;
 	ssize_t ret = strnlen(buf, PAGE_SIZE);
+	ssize_t sz;
 	ret = (ret > 16) ? 16 : ret;
 
-	memset(external_common_state->spd_product_description, 0, 16);
+	sz = sizeof(external_common_state->spd_product_description);
+	memset(external_common_state->spd_product_description, 0, sz);
 	while (*s) {
 		if (*s & 0x60 && *s ^ 0x7f) {
 			*d = *s;
@@ -430,6 +318,7 @@
 
 		d++;
 	}
+	external_common_state->spd_product_description[sz - 1] = 0;
 
 	DEV_DBG("%s: '%s'\n", __func__,
 			external_common_state->spd_product_description);
@@ -463,22 +352,22 @@
 			.disp_3d_mode_list;
 		for (i = 0; i < external_common_state->disp_mode_list
 			.num_of_elements; ++i) {
-			video_3d_format_2string(*video_3d_mode++, buff_3d);
+			video_3d_format_2string(*video_3d_mode++, buff_3d, sizeof(buff_3d));
 			if (ret > 0)
-				ret += snprintf(buf+ret, PAGE_SIZE-ret,
+				ret += scnprintf(buf+ret, PAGE_SIZE-ret,
 					",%d=%s",
 					*video_mode++ + 1, buff_3d);
 			else
-				ret += snprintf(buf+ret, PAGE_SIZE-ret,
+				ret += scnprintf(buf+ret, PAGE_SIZE-ret,
 					"%d=%s",
 					*video_mode++ + 1, buff_3d);
 		}
 	} else
-		ret += snprintf(buf+ret, PAGE_SIZE-ret, "%d",
+		ret += scnprintf(buf+ret, PAGE_SIZE-ret, "%d",
 			external_common_state->video_resolution+1);
 
 	DEV_DBG("%s: '%s'\n", __func__, buf);
-	ret += snprintf(buf+ret, PAGE_SIZE-ret, "\n");
+	ret += scnprintf(buf+ret, PAGE_SIZE-ret, "\n");
 	return ret;
 }
 
@@ -655,8 +544,15 @@
 	struct device_attribute *attr, const char *buf, size_t count)
 {
 	int i;
-	int retry = ((struct hdmi_msm_cec_msg *) buf)->retransmit;
+	struct hdmi_msm_cec_msg *msg;
+	int retry;
 
+	msg = (struct hdmi_msm_cec_msg *) buf;
+	retry = msg->retransmit;
+	if (msg->frame_size > CEC_MAX_OPERAND_SIZE) {
+		pr_err("%s: cec msg too large\n", __func__);
+		return -EINVAL;
+	}
 	for (i = 0; i < RETRANSMIT_MAX_NUM; i++) {
 		hdmi_msm_cec_msg_send((struct hdmi_msm_cec_msg *) buf);
 		if (hdmi_msm_state->cec_frame_wr_status
@@ -739,7 +635,7 @@
 	hdmi_msm_rda_cec,
 	hdmi_msm_wta_cec);
 
-static DEVICE_ATTR(cec_logical_addr, S_IRUGO | S_IWUSR,
+static DEVICE_ATTR(cec_logical_addr, S_IRUSR | S_IWUSR,
 	hdmi_msm_rda_cec_logical_addr,
 	hdmi_msm_wta_cec_logical_addr);
 
@@ -767,7 +663,7 @@
 	ssize_t ret = strnlen(buf, PAGE_SIZE);
 	uint32 video_mode;
 #ifdef CONFIG_FB_MSM_HDMI_COMMON
-	const struct hdmi_disp_mode_timing_type *disp_mode;
+	const struct msm_hdmi_mode_timing_info *disp_mode;
 #endif
 	mutex_lock(&external_common_state_hpd_mutex);
 	if (!external_common_state->hpd_state) {
@@ -778,7 +674,7 @@
 	}
 	mutex_unlock(&external_common_state_hpd_mutex);
 
-	video_mode = atoi(buf)-1;
+	video_mode = atoi(buf);
 	DEV_INFO("%s: video_mode is %d\n", __func__, video_mode);
 	kobject_uevent(external_common_state->uevent_kobj, KOBJ_OFFLINE);
 #ifdef CONFIG_FB_MSM_HDMI_COMMON
@@ -794,7 +690,7 @@
 	external_common_state->video_resolution = video_mode;
 #endif
 	DEV_DBG("%s: 'mode=%d %s' successful (sending OFF/ONLINE)\n", __func__,
-		video_mode, video_format_2string(video_mode));
+		video_mode, msm_hdmi_mode_2string(video_mode));
 	kobject_uevent(external_common_state->uevent_kobj, KOBJ_ONLINE);
 	return ret;
 }
@@ -888,47 +784,257 @@
 
 	return ret;
 }
+static ssize_t hdmi_common_wta_audio_caps(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t ret = strnlen(buf, PAGE_SIZE);
+	number_of_sad = atoi(buf);
+	return ret;
+}
 
-static ssize_t external_common_vscr_info_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+
+int hdmi_common_get_audio_capabilities(
+		uint8 *channels, uint8 *formats,
+		uint8 *freq,     uint8 *bitrate,
+		uint8 *spkr_allocation)
 {
-	struct msm_fb_data_type *mfd = external_common_state->mfd;
-	struct fb_info *fbi = mfd->fbi;
-	struct fb_var_screeninfo *var=&fbi->var;
+	uint8 *adb = external_common_state->audio_data_block;
+	int count  = external_common_state->adb_size/3;
 
-	memcpy((struct fb_var_screeninfo*)buf, var, sizeof(struct fb_var_screeninfo));
+	while (count--) {
+		*channels++ = (*adb & 0x07) + 1;
+		*formats++  = (*adb & 0x78) >> 3;
+		*freq++     = *(adb + 1) & 0xFF;
+		*bitrate++  = *(adb + 2) & 0xFF;
 
-	DEV_DBG("%s: <ID=%d %dx%d (%d,%d,%d), (%d,%d,%d) %dMHz>\n", __func__,
-		var->reserved[3] >> 16, var->xres, var->yres,
-		var->right_margin, var->hsync_len, var->left_margin,
-		var->lower_margin, var->vsync_len, var->upper_margin,
-		var->pixclock/1000/1000);
+		adb += 3;
+	}
+
+	*spkr_allocation = external_common_state->spkr_alloc_data_block[0];
 
-	return sizeof(struct fb_var_screeninfo);
+	return external_common_state->adb_size/3;
 }
 
-static ssize_t external_common_vscr_info_store(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t hdmi_common_rda_audio_caps(struct device *dev,
+	struct device_attribute *attr, char *buf)
 {
-	struct msm_fb_data_type *mfd = external_common_state->mfd;
-	struct fb_info *fbi = mfd->fbi;
-	struct fb_var_screeninfo *var=&fbi->var;
+	uint8 channels[16];
+	uint8 formats[16];
+	uint8 frequency[16];
+	uint8 bitrate[16];
+	uint8 spkr_allocation;
+	int count, i;
+	char str[512];
+	int str_size = 512;
+	boolean comma = FALSE;
+
+	if (number_of_sad == 0) {
+		count = external_common_state->adb_size/3;
+		return snprintf(buf, sizeof(int)+1, "%d\n", count);
+	}
+
+	count = hdmi_common_get_audio_capabilities(channels, formats,
+						   frequency, bitrate,
+						   &spkr_allocation);
+
+	strlcpy(str, "\n", str_size);
+	i = number_of_sad - 1;
+	{
+		char t[3];
+		snprintf(t, 3, "%d", i + 1);
+
+		strlcat(str, "\tSHORT AUDIO DESCRIPTOR # ", str_size);
+		strlcat(str, t, str_size);
+		strlcat(str, "\n", str_size);
+		strlcat(str, "Number of channels \t= ", str_size);
+
+		snprintf(t, 3, "%d", channels[i]);
+		strlcat(str, t, str_size);
+
+		strlcat(str, "\n", str_size);
+
+		strlcat(str, "Formats supported \t= ", str_size);
+		switch (formats[i]) {
+		case 1:
+			strlcat(str, "LPCM", str_size);
+			break;
+		case 2:
+			strlcat(str, "AC-3", str_size);
+			break;
+		case 3:
+			strlcat(str, "MPEG1 (Layers 1 & 2)", str_size);
+			break;
+		case 4:
+			strlcat(str, "MP3 (MPEG1 Layer 3)", str_size);
+			break;
+		case 5:
+			strlcat(str, "MPEG2 (multichannel)", str_size);
+			break;
+		case 6:
+			strlcat(str, "AAC", str_size);
+			break;
+		case 7:
+			strlcat(str, "DTS", str_size);
+			break;
+		case 8:
+			strlcat(str, "ATRAC", str_size);
+			break;
+		case 9:
+			strlcat(str, "One-bit audio aka SACD", str_size);
+			break;
+		case 10:
+			strlcat(str, "Dolby Digital +", str_size);
+			break;
+		case 11:
+			strlcat(str, "DTS-HD", str_size);
+			break;
+		case 12:
+			strlcat(str, "MAT (MLP)", str_size);
+			break;
+		case 13:
+			strlcat(str, "DST", str_size);
+			break;
+		case 14:
+			strlcat(str, "WMA Pro", str_size);
+			break;
+		default:
+			break;
+		}
 
-	memcpy(var, (struct fb_var_screeninfo*)buf, sizeof(struct fb_var_screeninfo));
+		strlcat(str, "\n", str_size);
 
-	DEV_DBG("%s: <ID=%d %dx%d (%d,%d,%d), (%d,%d,%d) %dMHz>\n", __func__,
-		var->reserved[3] >> 16, var->xres, var->yres,
-		var->right_margin, var->hsync_len, var->left_margin,
-		var->lower_margin, var->vsync_len, var->upper_margin,
-		var->pixclock/1000/1000);
+		strlcat(str, "Frequency supported \t= ", str_size);
+		comma = FALSE;
+		if (frequency[i] & BIT(0)) {
+			strlcat(str, "32kHz", str_size);
+			comma = TRUE;
+		}
+		if (frequency[i] & BIT(1)) {
+			if (comma)
+				strlcat(str, ", 44kHz", str_size);
+			else
+				strlcat(str, "44kHz", str_size);
+			comma = TRUE;
+		}
+		if (frequency[i] & BIT(2)) {
+			if (comma)
+				strlcat(str, ", 48kHz", str_size);
+			else
+				strlcat(str, "48kHz", str_size);
+			comma = TRUE;
+		}
+		if (frequency[i] & BIT(3)) {
+			if (comma)
+				strlcat(str, ", 88kHz", str_size);
+			else
+				strlcat(str, "88kHz", str_size);
+			comma = TRUE;
+		}
+		if (frequency[i] & BIT(4)) {
+			if (comma)
+				strlcat(str, ", 96kHz", str_size);
+			else
+				strlcat(str, "96kHz", str_size);
+			comma = TRUE;
+		}
+		if (frequency[i] & BIT(5)) {
+			if (comma)
+				strlcat(str, ", 176kHz", str_size);
+			else
+				strlcat(str, "176kHz", str_size);
+			comma = TRUE;
+		}
+		if (frequency[i] & BIT(6)) {
+			if (comma)
+				strlcat(str, ", 192kHz", str_size);
+			else
+				strlcat(str, "192kHz", str_size);
+		}
 
-	return sizeof(struct fb_var_screeninfo);
-}
+		strlcat(str, "\n", str_size);
 
-static DEVICE_ATTR(vscr_info, S_IRUGO | S_IWUSR | S_IWGRP,
-	external_common_vscr_info_show, external_common_vscr_info_store);
+		strlcat(str, "bitrate supported \t= ", str_size);
+		comma = FALSE;
+		if (formats[i] == 1) {
+			if (bitrate[i] & BIT(0)) {
+				strlcat(str, "16bit", str_size);
+				comma = TRUE;
+			}
+			if (bitrate[i] & BIT(1)) {
+				if (comma)
+					strlcat(str, ", 20bit", str_size);
+				else
+					strlcat(str, "20bit", str_size);
+				comma = TRUE;
+			}
+			if (bitrate[i] & BIT(2)) {
+				if (comma)
+					strlcat(str, ", 24bit", str_size);
+				else
+					strlcat(str, "24bit", str_size);
+			}
+		} else {
+			char t[20];
+			snprintf(t, 20, "%d", bitrate[i] * 8);
+			strlcat(str, t, str_size);
+			strlcat(str, "Kbit/s", str_size);
+		}
+
+		strlcat(str, "\n\n", str_size);
+	}
+
+	strlcat(str, "Speaker Allocation \t= ", str_size);
+	comma = FALSE;
+	if (spkr_allocation & BIT(0)) {
+		strlcat(str, "FL/FR", str_size);
+		comma = TRUE;
+	}
+	if (spkr_allocation & BIT(1)) {
+		if (comma)
+			strlcat(str, ", LFE", str_size);
+		else
+			strlcat(str, "LFE", str_size);
+		comma = TRUE;
+	}
+	if (spkr_allocation & BIT(2)) {
+		if (comma)
+			strlcat(str, ", FC", str_size);
+		else
+			strlcat(str, "FC", str_size);
+		comma = TRUE;
+	}
+	if (spkr_allocation & BIT(3)) {
+		if (comma)
+			strlcat(str, ", RL/RR", str_size);
+		else
+			strlcat(str, "RL/RR", str_size);
+		comma = TRUE;
+	}
+	if (spkr_allocation & BIT(4)) {
+		if (comma)
+			strlcat(str, ", RC", str_size);
+		else
+			strlcat(str, "RC", str_size);
+		comma = TRUE;
+	}
+	if (spkr_allocation & BIT(5)) {
+		if (comma)
+			strlcat(str, ", FLC/FRC", str_size);
+		else
+			strlcat(str, "FLC/FRC", str_size);
+		comma = TRUE;
+	}
+	if (spkr_allocation & BIT(6)) {
+		if (comma)
+			strlcat(str, ", RLC/RRC", str_size);
+		else
+			strlcat(str, "RLC/RRC", str_size);
+	}
+
+	return snprintf(buf, str_size, "%s\n", str);
+}
 
-static DEVICE_ATTR(video_mode, S_IRUGO | S_IWUGO,
+static DEVICE_ATTR(video_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 	external_common_rda_video_mode, external_common_wta_video_mode);
 static DEVICE_ATTR(video_mode_str, S_IRUGO, external_common_rda_video_mode_str,
 	NULL);
@@ -936,10 +1042,10 @@
 static DEVICE_ATTR(hdmi_mode, S_IRUGO, external_common_rda_hdmi_mode, NULL);
 #ifdef CONFIG_FB_MSM_HDMI_COMMON
 static DEVICE_ATTR(edid_modes, S_IRUGO, hdmi_common_rda_edid_modes, NULL);
-static DEVICE_ATTR(hpd, S_IRUGO | S_IWUGO, hdmi_common_rda_hpd,
+static DEVICE_ATTR(hpd, S_IRUGO | S_IWUSR | S_IWGRP, hdmi_common_rda_hpd,
 	hdmi_common_wta_hpd);
 static DEVICE_ATTR(hdcp, S_IRUGO, hdmi_common_rda_hdcp, NULL);
-static DEVICE_ATTR(pa, S_IRUGO,
+static DEVICE_ATTR(pa, S_IRUSR,
 	hdmi_common_rda_edid_physical_address, NULL);
 static DEVICE_ATTR(scan_info, S_IRUGO,
 	hdmi_common_rda_edid_scan_info, NULL);
@@ -954,17 +1060,18 @@
 static DEVICE_ATTR(hdcp_present, S_IRUGO, hdmi_common_rda_hdcp_present, NULL);
 #endif
 #ifdef CONFIG_FB_MSM_HDMI_3D
-static DEVICE_ATTR(format_3d, S_IRUGO | S_IWUGO, hdmi_3d_rda_format_3d,
-	hdmi_3d_wta_format_3d);
+static DEVICE_ATTR(format_3d, S_IRUGO | S_IWUSR | S_IWGRP,
+	hdmi_3d_rda_format_3d, hdmi_3d_wta_format_3d);
 #endif
 static DEVICE_ATTR(hdmi_primary, S_IRUGO, hdmi_common_rda_hdmi_primary, NULL);
 static DEVICE_ATTR(audio_data_block, S_IRUGO, hdmi_common_rda_audio_data_block,
 	NULL);
 static DEVICE_ATTR(spkr_alloc_data_block, S_IRUGO,
 	hdmi_common_rda_spkr_alloc_data_block, NULL);
+static DEVICE_ATTR(audio_caps, S_IRUGO | S_IWUSR, hdmi_common_rda_audio_caps,
+	hdmi_common_wta_audio_caps);
 
 static struct attribute *external_common_fs_attrs[] = {
-	&dev_attr_vscr_info.attr,
 	&dev_attr_video_mode.attr,
 	&dev_attr_video_mode_str.attr,
 	&dev_attr_connected.attr,
@@ -993,6 +1100,7 @@
 	&dev_attr_hdmi_primary.attr,
 	&dev_attr_audio_data_block.attr,
 	&dev_attr_spkr_alloc_data_block.attr,
+	&dev_attr_audio_caps.attr,
 	NULL,
 };
 static struct attribute_group external_common_fs_attr_group = {
@@ -1110,6 +1218,8 @@
 	 89909, 119880, 148352, 119880, FALSE},
 	{HDMI_VFRMT_1280x720p120_16_9, 1280, 720, FALSE, 1650, 370, 750, 30,
 	 90000, 120000, 148500, 120000, FALSE},
+	{HDMI_VFRMT_1280x1024p60_5_4, 1280, 1024, FALSE, 1688, 408, 1066, 42,
+	 63981, 60020, 108000, 60000, FALSE},
 
 	/* All 1440 H Active */
 	{HDMI_VFRMT_1440x576i50_4_3, 1440, 576, TRUE,  1728, 288, 625, 24,
@@ -1217,6 +1327,8 @@
 	uint32 offset = start_offset;
 	uint32 end_dbc_offset = in_buf[2];
 
+	if(offset >= 128 || (end_dbc_offset >= (128-offset)))
+		return NULL;
 	*len = 0;
 
 	/*edid buffer 1, byte 2 being 4 means no non-DTD/Data block collection
@@ -1229,7 +1341,8 @@
 	}
 	while (offset < end_dbc_offset) {
 		uint8 block_len = in_buf[offset] & 0x1F;
-		if ((in_buf[offset] >> 5) == type) {
+		if ((block_len < end_dbc_offset  - offset) &&
+				(in_buf[offset] >> 5) == type) {
 			*len = block_len;
 			DEV_DBG("EDID: block=%d found @ %d with length=%d\n",
 				type, offset, block_len);
@@ -1343,6 +1456,11 @@
 			&len);
 	uint32 *adb = external_common_state->audio_data_blocks;
 
+	if (in_buf[3] & (1<<6)) {
+		DEV_INFO("%s: default audio format\n", __func__);
+		audio_ch |= 0x02;
+	}
+
 	if (sad == NULL)
 		return;
 
@@ -1558,7 +1676,7 @@
 	struct hdmi_disp_mode_list_type *disp_mode_list,
 	uint32 video_format)
 {
-	const struct hdmi_disp_mode_timing_type *timing;
+	const struct msm_hdmi_mode_timing_info *timing;
 	boolean supported = false;
 	boolean mhl_supported = true;
 	limit_supported_video_format(&video_format);
@@ -1569,15 +1687,16 @@
 	timing = hdmi_common_get_supported_mode(video_format);
 	supported = timing != NULL;
 	DEV_DBG("EDID: format: %d [%s], %s\n",
-		video_format, video_format_2string(video_format),
+		video_format, msm_hdmi_mode_2string(video_format),
 		supported ? "Supported" : "Not-Supported");
 
 	if (mhl_is_connected() || (0x01 != sii8240_mhl_get_version())) {
-		const struct hdmi_disp_mode_timing_type *mhl_timing =
+		const struct msm_hdmi_mode_timing_info *mhl_timing =
 			hdmi_mhl_get_supported_mode(video_format);
 		mhl_supported = mhl_timing != NULL;
 		DEV_DBG("EDID: format: %d [%s], %s by MHL\n",
-			video_format, video_format_2string(video_format),
+			video_format,
+			msm_hdmi_mode_2string(video_format),
 			mhl_supported ? "Supported" : "Not-Supported");
 	}
 
@@ -1587,8 +1706,7 @@
 		if (video_format == external_common_state->video_resolution) {
 			DEV_DBG("%s: Default resolution %d [%s] supported\n",
 					__func__, video_format,
-					video_format_2string(video_format));
-			external_common_state->default_res_supported = true;
+					msm_hdmi_mode_2string(video_format));
 		}
 	}
 }
@@ -1603,29 +1721,29 @@
 	return "";
 }
 
-ssize_t video_3d_format_2string(uint32 format, char *buf)
+ssize_t video_3d_format_2string(uint32 format, char *buf, u32 size)
 {
 	ssize_t ret, len = 0;
-	ret = snprintf(buf, PAGE_SIZE, "%s",
+	ret = scnprintf(buf, size, "%s",
 		single_video_3d_format_2string(format & FRAME_PACKING));
 	len += ret;
 
 	if (len && (format & TOP_AND_BOTTOM))
-		ret = snprintf(buf + len, PAGE_SIZE - len, ":%s",
+		ret = scnprintf(buf + len, size - len, ":%s",
 			single_video_3d_format_2string(
 				format & TOP_AND_BOTTOM));
 	else
-		ret = snprintf(buf + len, PAGE_SIZE - len, "%s",
+		ret = scnprintf(buf + len, size - len, "%s",
 			single_video_3d_format_2string(
 				format & TOP_AND_BOTTOM));
 	len += ret;
 
 	if (len && (format & SIDE_BY_SIDE_HALF))
-		ret = snprintf(buf + len, PAGE_SIZE - len, ":%s",
+		ret = scnprintf(buf + len, size - len, ":%s",
 			single_video_3d_format_2string(
 				format & SIDE_BY_SIDE_HALF));
 	else
-		ret = snprintf(buf + len, PAGE_SIZE - len, "%s",
+		ret = scnprintf(buf + len, size - len, "%s",
 			single_video_3d_format_2string(
 				format & SIDE_BY_SIDE_HALF));
 	len += ret;
@@ -1649,13 +1767,13 @@
 			break;
 		}
 	}
-	video_3d_format_2string(video_3d_format, string);
+	video_3d_format_2string(video_3d_format, string, sizeof(string));
 	DEV_DBG("EDID[3D]: format: %d [%s], %s %s\n",
-		video_format, video_format_2string(video_format),
+		video_format, msm_hdmi_mode_2string(video_format),
 		string, added ? "added" : "NOT added");
 }
 
-static void hdmi_edid_get_display_vsd_3d_mode(const uint8 *data_buf,
+static int hdmi_edid_get_display_vsd_3d_mode(const uint8 *data_buf,
 	struct hdmi_disp_mode_list_type *disp_mode_list,
 	uint32 num_og_cea_blocks)
 {
@@ -1668,6 +1786,8 @@
 	int i;
 
 	offset = HDMI_VSDB_3D_DATA_OFFSET(vsd);
+	if (offset >= len - 1)
+		return -ETOOSMALL;
 	present_multi_3d = (vsd[offset] & 0x60) >> 5;
 
 	offset += 1;
@@ -1677,11 +1797,15 @@
 		hdmi_vic_len, hdmi_3d_len);
 
 	offset += (hdmi_vic_len + 1);
+	if (offset >= len - 1)
+		return -ETOOSMALL;
 	if (present_multi_3d == 1 || present_multi_3d == 2) {
 		DEV_DBG("EDID[3D]: multi 3D present (%d)\n", present_multi_3d);
 		/* 3d_structure_all */
 		structure_all = (vsd[offset] << 8) | vsd[offset + 1];
 		offset += 2;
+		if (offset >= len - 1)
+			return -ETOOSMALL;
 		hdmi_3d_len -= 2;
 		if (present_multi_3d == 2) {
 			/* 3d_structure_mask */
@@ -1728,6 +1852,8 @@
 
 	i = 0;
 	while (hdmi_3d_len > 0) {
+		 if (offset >= len - 1)
+			 return -ETOOSMALL;
 		DEV_DBG("EDID[3D]: 3D_Structure_%d @ %d: %02x\n",
 			i + 1, offset, vsd[offset]);
 
@@ -1778,16 +1904,18 @@
 		offset += 1;
 		hdmi_3d_len -= 1;
 	}
+	return 0;
 }
 
 static void hdmi_edid_get_display_mode(const uint8 *data_buf,
 	struct hdmi_disp_mode_list_type *disp_mode_list,
 	uint32 num_og_cea_blocks)
 {
-	uint8 i			= 0;
+	uint8 i			= 0, offset = 0, std_blk = 0;
 	uint32 video_format	= HDMI_VFRMT_640x480p60_4_3;
 	boolean has480p		= FALSE;
 	uint8 len;
+	int rc;
 	const uint8 *edid_blk0 = &data_buf[0x0];
 	const uint8 *edid_blk1 = &data_buf[0x80];
 	const uint8 *svd = num_og_cea_blocks ?
@@ -1805,7 +1933,7 @@
 			/* Subtract 1 because it is zero based in the driver,
 			 * while the Video identification code is 1 based in the
 			 * CEA_861D spec */
-			video_format = (*svd & 0x7F) - 1;
+			video_format = (*svd & 0x7F);
 			add_supported_video_format(disp_mode_list,
 				video_format);
 			/* Make a note of the preferred video format */
@@ -1847,7 +1975,7 @@
 				&video_format);
 			DEV_DBG("[%s:%d] Block-0 Adding vid fmt = [%s]\n",
 				__func__, __LINE__,
-				video_format_2string(video_format));
+				msm_hdmi_mode_2string(video_format));
 			add_supported_video_format(disp_mode_list,
 				video_format);
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
@@ -1872,7 +2000,7 @@
 				&video_format);
 			DEV_DBG("[%s:%d] Block-0 Adding vid fmt = [%s]\n",
 				__func__, __LINE__,
-				video_format_2string(video_format));
+				msm_hdmi_mode_2string(video_format));
 			add_supported_video_format(disp_mode_list,
 				video_format);
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
@@ -1900,7 +2028,7 @@
 				&video_format);
 			DEV_DBG("[%s:%d] Block-1 Adding vid fmt = [%s]\n",
 				__func__, __LINE__,
-				video_format_2string(video_format));
+				msm_hdmi_mode_2string(video_format));
 			add_supported_video_format(disp_mode_list,
 				video_format);
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
@@ -1915,6 +2043,66 @@
 		}
 	}
 
+
+	/*
+	 * Check SD Timings if it contains 1280x1024@60Hz.
+	 * SD Timing can be max 8 with 2 byte in size.
+	 */
+	std_blk = 0;
+	offset  = 0;
+	while (std_blk < 8) {
+		if ((edid_blk0[0x26 + offset] == 0x81) &&
+			(edid_blk0[0x26 + offset + 1] == 0x80)) {
+			add_supported_video_format(disp_mode_list,
+					HDMI_VFRMT_1280x1024p60_5_4);
+			break;
+		} else {
+			offset += 2;
+		}
+		std_blk++;
+	}
+
+	/* check if the EDID revision is 4 (version 1.4) */
+	if (edid_blk0[0x13] == 4) {
+		uint8  start = 0x36;
+
+		i = 0;
+
+		/* Check each of 4 - 18 bytes descriptors */
+		while (i < 4) {
+			uint8  itrate   = start;
+			uint32 header_1 = 0;
+			uint8  header_2 = 0;
+
+			/*
+			 * First 5 bytes are header.
+			 * If they match 0x000000F700, it means its an
+			 * established Timing III descriptor.
+			 */
+			header_1 = edid_blk0[itrate++];
+			header_1 = header_1 << 8 | edid_blk0[itrate++];
+			header_1 = header_1 << 8 | edid_blk0[itrate++];
+			header_1 = header_1 << 8 | edid_blk0[itrate++];
+			header_2 = edid_blk0[itrate];
+
+			if (header_1 == 0x000000F7 &&
+			    header_2 == 0x00) {
+				itrate++; /* VESA DMT Standard Version (0x0A)*/
+				itrate++; /* First set of supported formats */
+				itrate++; /* Second set of supported formats */
+				/* BIT(1) indicates 1280x1024@60Hz */
+				if (edid_blk0[itrate] & 0x02) {
+					add_supported_video_format(
+						disp_mode_list,
+						HDMI_VFRMT_1280x1024p60_5_4);
+					break;
+				}
+			}
+			i++;
+			start += 0x12;
+		}
+	}
+
 	/* mandaroty 3d format */
 	if (external_common_state->present_3d) {
 		if (has60hz_mode) {
@@ -1941,8 +2129,10 @@
 		}
 
 		/* 3d format described in Vendor Specific Data */
-		hdmi_edid_get_display_vsd_3d_mode(data_buf, disp_mode_list,
+		rc = hdmi_edid_get_display_vsd_3d_mode(data_buf, disp_mode_list,
 			num_og_cea_blocks);
+		if (!rc)
+			pr_debug("%s: 3D formats in VSD\n", __func__);
 	}
 
 	if (!has480p)
@@ -2030,6 +2220,12 @@
 	external_common_state->present_3d = 0;
 	memset(&external_common_state->disp_mode_list, 0,
 		sizeof(external_common_state->disp_mode_list));
+	memset(external_common_state->audio_data_block, 0,
+		sizeof(external_common_state->audio_data_block));
+	memset(external_common_state->spkr_alloc_data_block, 0,
+		sizeof(external_common_state->spkr_alloc_data_block));
+	external_common_state->adb_size = 0;
+	external_common_state->sadb_size = 0;
 
 	if (0 != memcmp(edid_signature, edid_buf, sizeof(edid_signature))) {
 			status = -EPROTO;
@@ -2129,7 +2325,6 @@
 	external_common_state->disp_mode_list.num_of_elements = 1;
 	external_common_state->disp_mode_list.disp_mode_list[0] =
 		external_common_state->video_resolution;
-	external_common_state->default_res_supported = true;
 	return status;
 }
 EXPORT_SYMBOL(hdmi_common_read_edid);
@@ -2143,10 +2338,10 @@
 	userformat = var->reserved[3] >> 16;
 
 	if (userformat) {
-		format = userformat-1;
+		format = userformat;
 		DEV_DBG("reserved format is %d\n", format);
 	} else if (hdmi_prim_resolution) {
-		format = hdmi_prim_resolution - 1;
+		format = hdmi_prim_resolution;
 	} else {
 		DEV_DBG("detecting resolution from %dx%d use top 2 bytes of"
 			" var->reserved[3] to specify mode", mfd->var_xres,
@@ -2162,7 +2357,9 @@
 				: HDMI_VFRMT_720x576p50_16_9;
 			break;
 		case 1280:
-			if (mfd->var_frame_rate == 50000)
+			if (mfd->var_yres == 1024)
+				format = HDMI_VFRMT_1280x1024p60_5_4;
+			else if (mfd->var_frame_rate == 50)
 				format = HDMI_VFRMT_1280x720p50_16_9;
 			else
 				format = HDMI_VFRMT_1280x720p60_16_9;
@@ -2178,13 +2375,13 @@
 			if (mfd->var_yres == 540) {/* interlaced */
 				format = HDMI_VFRMT_1920x1080i60_16_9;
 			} else if (mfd->var_yres == 1080) {
-				if (mfd->var_frame_rate == 50000)
+				if (mfd->var_frame_rate == 50)
 					format = HDMI_VFRMT_1920x1080p50_16_9;
-				else if (mfd->var_frame_rate == 24000)
+				else if (mfd->var_frame_rate == 24)
 					format = HDMI_VFRMT_1920x1080p24_16_9;
-				else if (mfd->var_frame_rate == 25000)
+				else if (mfd->var_frame_rate == 25)
 					format = HDMI_VFRMT_1920x1080p25_16_9;
-				else if (mfd->var_frame_rate == 30000)
+				else if (mfd->var_frame_rate == 30)
 					format = HDMI_VFRMT_1920x1080p30_16_9;
 				else
 					format = HDMI_VFRMT_1920x1080p60_16_9;
@@ -2195,18 +2392,18 @@
 
 	changed = external_common_state->video_resolution != format;
 	if (external_common_state->video_resolution != format)
-		DEV_DBG("switching %s => %s", video_format_2string(
+		DEV_DBG("switching %s => %s", msm_hdmi_mode_2string(
 			external_common_state->video_resolution),
-			video_format_2string(format));
+			msm_hdmi_mode_2string(format));
 	else
-		DEV_DBG("resolution %s", video_format_2string(
+		DEV_DBG("resolution %s", msm_hdmi_mode_2string(
 			external_common_state->video_resolution));
 	external_common_state->video_resolution = format;
 	return changed;
 }
 EXPORT_SYMBOL(hdmi_common_get_video_format_from_drv_data);
 
-const struct hdmi_disp_mode_timing_type *hdmi_common_get_mode(uint32 mode)
+const struct msm_hdmi_mode_timing_info *hdmi_common_get_mode(uint32 mode)
 {
 	if (mode >= HDMI_VFRMT_MAX)
 		return NULL;
@@ -2215,10 +2412,10 @@
 }
 EXPORT_SYMBOL(hdmi_common_get_mode);
 
-const struct hdmi_disp_mode_timing_type *hdmi_common_get_supported_mode(
+const struct msm_hdmi_mode_timing_info *hdmi_common_get_supported_mode(
 	uint32 mode)
 {
-	const struct hdmi_disp_mode_timing_type *ret
+	const struct msm_hdmi_mode_timing_info *ret
 		= hdmi_common_get_mode(mode);
 
 	if (ret == NULL || !ret->supported)
@@ -2227,7 +2424,7 @@
 }
 EXPORT_SYMBOL(hdmi_common_get_supported_mode);
 
-const struct hdmi_disp_mode_timing_type *hdmi_mhl_get_mode(uint32 mode)
+const struct msm_hdmi_mode_timing_info *hdmi_mhl_get_mode(uint32 mode)
 {
 	if (mode >= HDMI_VFRMT_MAX)
 		return NULL;
@@ -2236,10 +2433,10 @@
 }
 EXPORT_SYMBOL(hdmi_mhl_get_mode);
 
-const struct hdmi_disp_mode_timing_type *hdmi_mhl_get_supported_mode(
+const struct msm_hdmi_mode_timing_info *hdmi_mhl_get_supported_mode(
 	uint32 mode)
 {
-	const struct hdmi_disp_mode_timing_type *ret
+	const struct msm_hdmi_mode_timing_info *ret
 		= hdmi_mhl_get_mode(mode);
 
 	if (ret == NULL || !ret->supported)
@@ -2250,7 +2447,7 @@
 
 void hdmi_common_init_panel_info(struct msm_panel_info *pinfo)
 {
-	const struct hdmi_disp_mode_timing_type *timing =
+	const struct msm_hdmi_mode_timing_info *timing =
 		hdmi_common_get_supported_mode(
 		external_common_state->video_resolution);
 
@@ -2260,7 +2457,7 @@
 	pinfo->xres = timing->active_h;
 	pinfo->yres = timing->active_v;
 	pinfo->clk_rate = timing->pixel_freq*1000;
-	pinfo->frame_rate = 60;
+	pinfo->frame_rate = timing->refresh_rate/1000;
 
 	pinfo->lcdc.h_back_porch = timing->back_porch_h;
 	pinfo->lcdc.h_front_porch = timing->front_porch_h;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/external_common.h msm/external_common.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/external_common.h	2013-12-17 17:08:08.010147360 -0800
+++ msm/external_common.h	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -13,6 +13,7 @@
 #ifndef __EXTERNAL_COMMON_H__
 #define __EXTERNAL_COMMON_H__
 #include <linux/switch.h>
+#include <video/msm_hdmi_modes.h>
 
 #ifdef DEBUG
 #ifndef DEV_DBG_PREFIX
@@ -26,170 +27,13 @@
 #define DEV_WARN(args...)	dev_warn(external_common_state->dev, args)
 #define DEV_ERR(args...)	dev_err(external_common_state->dev, args)
 
-#ifdef CONFIG_FB_MSM_TVOUT
-#define TVOUT_VFRMT_NTSC_M_720x480i		0
-#define TVOUT_VFRMT_NTSC_J_720x480i		1
-#define TVOUT_VFRMT_PAL_BDGHIN_720x576i		2
-#define TVOUT_VFRMT_PAL_M_720x480i		3
-#define TVOUT_VFRMT_PAL_N_720x480i		4
-#elif defined(CONFIG_FB_MSM_HDMI_COMMON)
-/* all video formats defined by EIA CEA 861D */
-#define HDMI_VFRMT_640x480p60_4_3	0
-#define HDMI_VFRMT_720x480p60_4_3	1
-#define HDMI_VFRMT_720x480p60_16_9	2
-#define HDMI_VFRMT_1280x720p60_16_9	3
-#define HDMI_VFRMT_1920x1080i60_16_9	4
-#define HDMI_VFRMT_720x480i60_4_3	5
-#define HDMI_VFRMT_1440x480i60_4_3	HDMI_VFRMT_720x480i60_4_3
-#define HDMI_VFRMT_720x480i60_16_9	6
-#define HDMI_VFRMT_1440x480i60_16_9	HDMI_VFRMT_720x480i60_16_9
-#define HDMI_VFRMT_720x240p60_4_3	7
-#define HDMI_VFRMT_1440x240p60_4_3	HDMI_VFRMT_720x240p60_4_3
-#define HDMI_VFRMT_720x240p60_16_9	8
-#define HDMI_VFRMT_1440x240p60_16_9	HDMI_VFRMT_720x240p60_16_9
-#define HDMI_VFRMT_2880x480i60_4_3	9
-#define HDMI_VFRMT_2880x480i60_16_9	10
-#define HDMI_VFRMT_2880x240p60_4_3	11
-#define HDMI_VFRMT_2880x240p60_16_9	12
-#define HDMI_VFRMT_1440x480p60_4_3	13
-#define HDMI_VFRMT_1440x480p60_16_9	14
-#define HDMI_VFRMT_1920x1080p60_16_9	15
-#define HDMI_VFRMT_720x576p50_4_3	16
-#define HDMI_VFRMT_720x576p50_16_9	17
-#define HDMI_VFRMT_1280x720p50_16_9	18
-#define HDMI_VFRMT_1920x1080i50_16_9	19
-#define HDMI_VFRMT_720x576i50_4_3	20
-#define HDMI_VFRMT_1440x576i50_4_3	HDMI_VFRMT_720x576i50_4_3
-#define HDMI_VFRMT_720x576i50_16_9	21
-#define HDMI_VFRMT_1440x576i50_16_9	HDMI_VFRMT_720x576i50_16_9
-#define HDMI_VFRMT_720x288p50_4_3	22
-#define HDMI_VFRMT_1440x288p50_4_3	HDMI_VFRMT_720x288p50_4_3
-#define HDMI_VFRMT_720x288p50_16_9	23
-#define HDMI_VFRMT_1440x288p50_16_9	HDMI_VFRMT_720x288p50_16_9
-#define HDMI_VFRMT_2880x576i50_4_3	24
-#define HDMI_VFRMT_2880x576i50_16_9	25
-#define HDMI_VFRMT_2880x288p50_4_3	26
-#define HDMI_VFRMT_2880x288p50_16_9	27
-#define HDMI_VFRMT_1440x576p50_4_3	28
-#define HDMI_VFRMT_1440x576p50_16_9	29
-#define HDMI_VFRMT_1920x1080p50_16_9	30
-#define HDMI_VFRMT_1920x1080p24_16_9	31
-#define HDMI_VFRMT_1920x1080p25_16_9	32
-#define HDMI_VFRMT_1920x1080p30_16_9	33
-#define HDMI_VFRMT_2880x480p60_4_3	34
-#define HDMI_VFRMT_2880x480p60_16_9	35
-#define HDMI_VFRMT_2880x576p50_4_3	36
-#define HDMI_VFRMT_2880x576p50_16_9	37
-#define HDMI_VFRMT_1920x1250i50_16_9	38
-#define HDMI_VFRMT_1920x1080i100_16_9	39
-#define HDMI_VFRMT_1280x720p100_16_9	40
-#define HDMI_VFRMT_720x576p100_4_3	41
-#define HDMI_VFRMT_720x576p100_16_9	42
-#define HDMI_VFRMT_720x576i100_4_3	43
-#define HDMI_VFRMT_1440x576i100_4_3	HDMI_VFRMT_720x576i100_4_3
-#define HDMI_VFRMT_720x576i100_16_9	44
-#define HDMI_VFRMT_1440x576i100_16_9	HDMI_VFRMT_720x576i100_16_9
-#define HDMI_VFRMT_1920x1080i120_16_9	45
-#define HDMI_VFRMT_1280x720p120_16_9	46
-#define HDMI_VFRMT_720x480p120_4_3	47
-#define HDMI_VFRMT_720x480p120_16_9	48
-#define HDMI_VFRMT_720x480i120_4_3	49
-#define HDMI_VFRMT_1440x480i120_4_3	HDMI_VFRMT_720x480i120_4_3
-#define HDMI_VFRMT_720x480i120_16_9	50
-#define HDMI_VFRMT_1440x480i120_16_9	HDMI_VFRMT_720x480i120_16_9
-#define HDMI_VFRMT_720x576p200_4_3	51
-#define HDMI_VFRMT_720x576p200_16_9	52
-#define HDMI_VFRMT_720x576i200_4_3	53
-#define HDMI_VFRMT_1440x576i200_4_3	HDMI_VFRMT_720x576i200_4_3
-#define HDMI_VFRMT_720x576i200_16_9	54
-#define HDMI_VFRMT_1440x576i200_16_9	HDMI_VFRMT_720x576i200_16_9
-#define HDMI_VFRMT_720x480p240_4_3	55
-#define HDMI_VFRMT_720x480p240_16_9	56
-#define HDMI_VFRMT_720x480i240_4_3	57
-#define HDMI_VFRMT_1440x480i240_4_3	HDMI_VFRMT_720x480i240_4_3
-#define HDMI_VFRMT_720x480i240_16_9	58
-#define HDMI_VFRMT_1440x480i240_16_9	HDMI_VFRMT_720x480i240_16_9
-#define HDMI_VFRMT_MAX			59
-#define HDMI_VFRMT_FORCE_32BIT		0x7FFFFFFF
-
+#if defined(CONFIG_FB_MSM_HDMI_COMMON)
 extern int ext_resolution;
 
-struct hdmi_disp_mode_timing_type {
-	uint32	video_format;
-	uint32	active_h;
-	uint32	front_porch_h;
-	uint32	pulse_width_h;
-	uint32	back_porch_h;
-	boolean	active_low_h;
-	uint32	active_v;
-	uint32	front_porch_v;
-	uint32	pulse_width_v;
-	uint32	back_porch_v;
-	boolean	active_low_v;
-	/* Must divide by 1000 to get the actual frequency in MHZ */
-	uint32	pixel_freq;
-	/* Must divide by 1000 to get the actual frequency in HZ */
-	uint32	refresh_rate;
-	boolean	interlaced;
-	boolean	supported;
-};
-
-#define HDMI_SETTINGS_640x480p60_4_3					\
-	{HDMI_VFRMT_640x480p60_4_3,      640,  16,  96,  48,  TRUE,	\
-	 480, 10, 2, 33, TRUE, 25200, 60000, FALSE, TRUE}
-#define HDMI_SETTINGS_720x480p60_4_3					\
-	{HDMI_VFRMT_720x480p60_4_3,      720,  16,  62,  60,  TRUE,	\
-	 480, 9, 6, 30,  TRUE, 27030, 60000, FALSE, TRUE}
-#define HDMI_SETTINGS_720x480p60_16_9					\
-	{HDMI_VFRMT_720x480p60_16_9,     720,  16,  62,  60,  TRUE,	\
-	 480, 9, 6, 30,  TRUE, 27030, 60000, FALSE, TRUE}
-#define HDMI_SETTINGS_1280x720p60_16_9					\
-	{HDMI_VFRMT_1280x720p60_16_9,    1280, 110, 40,  220, FALSE,	\
-	 720, 5, 5, 20, FALSE, 74250, 60000, FALSE, TRUE}
-#define HDMI_SETTINGS_1920x1080i60_16_9					\
-	{HDMI_VFRMT_1920x1080i60_16_9,   1920, 88,  44,  148, FALSE,	\
-	 540, 2, 5, 5, FALSE, 74250, 60000, TRUE, FALSE}
-#define HDMI_SETTINGS_1440x480i60_4_3					\
-	{HDMI_VFRMT_1440x480i60_4_3,     1440, 38,  124, 114, TRUE,	\
-	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, FALSE}
-#define HDMI_SETTINGS_1440x480i60_16_9					\
-	{HDMI_VFRMT_1440x480i60_16_9,    1440, 38,  124, 114, TRUE,	\
-	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, FALSE}
-#define HDMI_SETTINGS_1920x1080p60_16_9					\
-	{HDMI_VFRMT_1920x1080p60_16_9,   1920, 88,  44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 148500, 60000, FALSE, TRUE}
-#define HDMI_SETTINGS_720x576p50_4_3					\
-	{HDMI_VFRMT_720x576p50_4_3,      720,  12,  64,  68,   TRUE,	\
-	 576,  5, 5, 39, TRUE, 27000, 50000, FALSE, TRUE}
-#define HDMI_SETTINGS_720x576p50_16_9					\
-	{HDMI_VFRMT_720x576p50_16_9,     720,  12,  64,  68,   TRUE,	\
-	 576,  5, 5, 39, TRUE, 27000, 50000, FALSE, TRUE}
-#define HDMI_SETTINGS_1280x720p50_16_9					\
-	{HDMI_VFRMT_1280x720p50_16_9,    1280, 440, 40,  220,  FALSE,	\
-	 720,  5, 5, 20, FALSE, 74250, 50000, FALSE, TRUE}
-#define HDMI_SETTINGS_1440x576i50_4_3					\
-	{HDMI_VFRMT_1440x576i50_4_3,     1440, 24,  126, 138,  TRUE,	\
-	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, FALSE}
-#define HDMI_SETTINGS_1440x576i50_16_9					\
-	{HDMI_VFRMT_1440x576i50_16_9,    1440, 24,  126, 138,  TRUE,	\
-	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, FALSE}
-#define HDMI_SETTINGS_1920x1080p50_16_9					\
-	{HDMI_VFRMT_1920x1080p50_16_9,   1920,  528,  44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 148500, 50000, FALSE, TRUE}
-#define HDMI_SETTINGS_1920x1080p24_16_9					\
-	{HDMI_VFRMT_1920x1080p24_16_9,   1920,  638,  44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 74250, 24000, FALSE, TRUE}
-#define HDMI_SETTINGS_1920x1080p25_16_9					\
-	{HDMI_VFRMT_1920x1080p25_16_9,   1920,  528,  44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 74250, 25000, FALSE, TRUE}
-#define HDMI_SETTINGS_1920x1080p30_16_9					\
-	{HDMI_VFRMT_1920x1080p30_16_9,   1920,  88,   44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 74250, 30000, FALSE, TRUE}
-
 /* A lookup table for all the supported display modes by the HDMI
  * hardware and driver.  Use HDMI_SETUP_LUT in the module init to
  * setup the LUT with the supported modes. */
-extern struct hdmi_disp_mode_timing_type
+extern struct msm_hdmi_mode_timing_info
 	hdmi_common_supported_video_mode_lut[HDMI_VFRMT_MAX];
 
 /* Structure that encapsulates all the supported display modes by the HDMI sink
@@ -216,10 +60,10 @@
 
 struct external_common_state_type {
 	boolean hpd_state;
+	boolean pre_suspend_hpd_state;
 	struct kobject *uevent_kobj;
 	struct msm_fb_data_type *mfd;
 	uint32 video_resolution;
-	boolean default_res_supported;
 	struct device *dev;
 	struct switch_dev sdev;
 	struct switch_dev audio_sdev;
@@ -240,8 +84,8 @@
 	uint8 pt_scan_info;
 	uint8 it_scan_info;
 	uint8 ce_scan_info;
-	uint8 spd_vendor_name[8];
-	uint8 spd_product_description[16];
+	uint8 spd_vendor_name[9];
+	uint8 spd_product_description[17];
 	boolean present_3d;
 	boolean present_hdcp;
 	uint32 audio_data_blocks[16];
@@ -262,27 +106,18 @@
 extern struct mutex hdmi_msm_state_mutex;
 
 #ifdef CONFIG_FB_MSM_HDMI_COMMON
-#define VFRMT_NOT_SUPPORTED(VFRMT) \
-	{VFRMT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FALSE}
-#define HDMI_SETUP_LUT(MODE) do {					\
-		struct hdmi_disp_mode_timing_type mode			\
-			= HDMI_SETTINGS_ ## MODE;			\
-		hdmi_common_supported_video_mode_lut[mode.video_format]	\
-			= mode;						\
-	} while (0)
-
 int hdmi_common_read_edid(void);
 const char *video_format_2string(uint32 format);
 bool hdmi_common_get_video_format_from_drv_data(struct msm_fb_data_type *mfd);
-const struct hdmi_disp_mode_timing_type *hdmi_common_get_mode(uint32 mode);
-const struct hdmi_disp_mode_timing_type *hdmi_common_get_supported_mode(
+const struct msm_hdmi_mode_timing_info *hdmi_common_get_mode(uint32 mode);
+const struct msm_hdmi_mode_timing_info *hdmi_common_get_supported_mode(
 	uint32 mode);
-const struct hdmi_disp_mode_timing_type *hdmi_mhl_get_mode(uint32 mode);
-const struct hdmi_disp_mode_timing_type *hdmi_mhl_get_supported_mode(
+const struct msm_hdmi_mode_timing_info *hdmi_mhl_get_mode(uint32 mode);
+const struct msm_hdmi_mode_timing_info *hdmi_mhl_get_supported_mode(
 	uint32 mode);
 void hdmi_common_init_panel_info(struct msm_panel_info *pinfo);
 
-ssize_t video_3d_format_2string(uint32 format, char *buf);
+ssize_t video_3d_format_2string(uint32 format, char *buf, u32 size);
 #endif
 
 int external_common_state_create(struct platform_device *pdev);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/hdmi_msm.c msm/hdmi_msm.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/hdmi_msm.c	2013-12-17 17:08:08.014147355 -0800
+++ msm/hdmi_msm.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -58,8 +58,11 @@
 #define HDCP_DDC_CTRL_1		0x0124
 #define HDMI_DDC_CTRL		0x020C
 
+
 #define HPD_DISCONNECT_POLARITY	0
 #define HPD_CONNECT_POLARITY	1
+#define HPD_EVENT_OFFLINE 0
+#define HPD_EVENT_ONLINE  1
 
 #define SWITCH_SET_HDMI_AUDIO(d, force) \
 	do {\
@@ -78,7 +81,7 @@
 struct hdmi_msm_state_type *hdmi_msm_state;
 
 /* Enable HDCP by default */
-static bool hdcp_feature_on;
+static bool hdcp_feature_on = false;
 
 DEFINE_MUTEX(hdmi_msm_state_mutex);
 EXPORT_SYMBOL(hdmi_msm_state_mutex);
@@ -631,23 +634,16 @@
 /* Valid Pixel-Clock rates: 25.2MHz, 27MHz, 27.03MHz, 74.25MHz, 148.5MHz */
 static void hdmi_msm_setup_video_mode_lut(void)
 {
-	HDMI_SETUP_LUT(640x480p60_4_3);
-	HDMI_SETUP_LUT(720x480p60_4_3);
-	HDMI_SETUP_LUT(720x480p60_16_9);
-	HDMI_SETUP_LUT(1280x720p60_16_9);
-	HDMI_SETUP_LUT(1920x1080i60_16_9);
-	HDMI_SETUP_LUT(1440x480i60_4_3);
-	HDMI_SETUP_LUT(1440x480i60_16_9);
-	HDMI_SETUP_LUT(1920x1080p60_16_9);
-	HDMI_SETUP_LUT(720x576p50_4_3);
-	HDMI_SETUP_LUT(720x576p50_16_9);
-	HDMI_SETUP_LUT(1280x720p50_16_9);
-	HDMI_SETUP_LUT(1440x576i50_4_3);
-	HDMI_SETUP_LUT(1440x576i50_16_9);
-	HDMI_SETUP_LUT(1920x1080p50_16_9);
-	HDMI_SETUP_LUT(1920x1080p24_16_9);
-	HDMI_SETUP_LUT(1920x1080p25_16_9);
-	HDMI_SETUP_LUT(1920x1080p30_16_9);
+	/* Init video mode timings */
+	MSM_HDMI_MODES_INIT_TIMINGS(hdmi_common_supported_video_mode_lut);
+
+	/* Add all supported CEA modes to the lut */
+	MSM_HDMI_MODES_SET_SUPP_TIMINGS(
+		hdmi_common_supported_video_mode_lut, MSM_HDMI_MODES_CEA);
+
+	/* Add any other supported timings (DVI modes, etc.) */
+	MSM_HDMI_MODES_SET_TIMING(hdmi_common_supported_video_mode_lut,
+		HDMI_VFRMT_1280x1024p60_5_4);
 }
 
 #ifdef PORT_DEBUG
@@ -771,6 +767,14 @@
 static int hdmi_msm_read_edid(void);
 static void hdmi_msm_hpd_off(void);
 
+static bool hdmi_ready(void)
+{
+	return MSM_HDMI_BASE &&
+			hdmi_msm_state &&
+				hdmi_msm_state->hdmi_app_clk &&
+					hdmi_msm_state->hpd_initialized;
+}
+
 static void hdmi_msm_send_event(boolean on)
 {
 	char *envp[2];
@@ -830,8 +834,7 @@
 
 static void hdmi_msm_hpd_state_work(struct work_struct *work)
 {
-	if (!hdmi_msm_state || !hdmi_msm_state->hpd_initialized ||
-		!MSM_HDMI_BASE) {
+	if (!hdmi_ready()) {
 		DEV_ERR("hdmi: %s: ignored, probe failed\n", __func__);
 		return;
 	}
@@ -949,6 +952,7 @@
 		DEV_INFO("HDCP: AUTH_FAIL_INT received, LINK0_STATUS=0x%08x\n",
 			link_status);
 		if (hdmi_msm_state->full_auth_done) {
+	       SWITCH_SET_HDMI_AUDIO(0, 0);
 #ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 0);
 			DEV_INFO("Hdmi state switched to %d: %s\n",
@@ -1024,8 +1028,7 @@
 	static uint32 sample_drop_int_occurred;
 	const uint32 occurrence_limit = 5;
 
-	if (!hdmi_msm_state || !hdmi_msm_state->hpd_initialized ||
-		!MSM_HDMI_BASE) {
+	if (!hdmi_ready()) {
 		DEV_DBG("ISR ignored, probe failed\n");
 		return IRQ_HANDLED;
 	}
@@ -3071,7 +3074,7 @@
 	uint32 end_h     = 0;
 	uint32 start_v   = 0;
 	uint32 end_v     = 0;
-	const struct hdmi_disp_mode_timing_type *timing =
+	const struct msm_hdmi_mode_timing_info *timing =
 		hdmi_common_get_supported_mode(video_format);
 
 	/* timing register setup */
@@ -3177,7 +3180,7 @@
 	acr_pck_ctrl_reg &= ~(3 << 4);
 
 	if (enabled) {
-		const struct hdmi_disp_mode_timing_type *timing =
+		const struct msm_hdmi_mode_timing_info *timing =
 			hdmi_common_get_supported_mode(video_format);
 		const struct hdmi_msm_audio_arcs *audio_arc =
 			&hdmi_msm_audio_acr_lut[0];
@@ -3654,36 +3657,49 @@
 	return 0;
 }
 
-
-static uint8 hdmi_msm_avi_iframe_lut[][16] = {
+static uint8 hdmi_msm_avi_iframe_lut[][17] = {
 /*	480p60	480i60	576p50	576i50	720p60	 720p50	1080p60	1080i60	1080p50
-	1080i50	1080p24	1080p30	1080p25	640x480p 480p60_16_9 576p50_4_3 */
+	1080i50	1080p24	1080p30	1080p25	640x480p 480p60_16_9 576p50_4_3 1024p*/
+
+	/* Data Byte 01: 0 Y1 Y0 A0 B1 B0 S1 S0 */
 	{0x10,	0x10,	0x10,	0x10,	0x10,	 0x10,	0x10,	0x10,	0x10,
-	 0x10,	0x10,	0x10,	0x10,	0x10, 0x10, 0x10}, /*00*/
+	 0x10,	0x10,	0x10,	0x10,	0x10, 0x10, 0x10, 0x10}, /*00*/
+	/* Data Byte 02: C1 C0 M1 M0 R3 R2 R1 R0 */
 	{0x18,	0x18,	0x28,	0x28,	0x28,	 0x28,	0x28,	0x28,	0x28,
-	 0x28,	0x28,	0x28,	0x28,	0x18, 0x28, 0x18}, /*01*/
-	{0x00,	0x04,	0x00,	0x04,	0x00,	 0x00,	0x00,	0x04,	0x00,
-	 0x04,	0x00,	0x00,	0x00,	0x88, 0x00, 0x04}, /*02*/
-	{0x02,	0x06,	0x11,	0x15,	0x04,	 0x13,	0x10,	0x05,	0x1F,
-	 0x14,	0x20,	0x22,	0x21,	0x01, 0x03, 0x11}, /*03*/
+	 0x28,	0x28,	0x28,	0x28,	0x18, 0x28, 0x18, 0x08}, /*01*/
+	/* Data Byte 03: ITC EC2 EC1 EC0 Q1 Q0 SC1 SC0 */
+	{0x00,	0x04,	0x04,	0x04,	0x04,	 0x04,	0x04,	0x04,	0x04,
+	 0x04,	0x04,	0x04,	0x04,	0x88, 0x00, 0x04, 0x04}, /*02*/
+	/* Data Byte 04: 0 VIC6 VIC5 VIC4 VIC3 VIC2 VIC1 VIC0 */
+	{0x02,	0x06,	0x12,	0x15,	0x04,	 0x13,	0x10,	0x05,	0x1F,
+	 0x14,	0x20,	0x22,	0x21,	0x01, 0x03, 0x11, 0x00}, /*03*/
+	/* Data Byte 05: 0 0 0 0 PR3 PR2 PR1 PR0 */
 	{0x00,	0x01,	0x00,	0x01,	0x00,	 0x00,	0x00,	0x00,	0x00,
-	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00}, /*04*/
+	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00, 0x00}, /*04*/
+	/* Data Byte 06: LSB Line No of End of Top Bar */
 	{0x00,	0x00,	0x00,	0x00,	0x00,	 0x00,	0x00,	0x00,	0x00,
-	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00}, /*05*/
+	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00, 0x00}, /*05*/
+	/* Data Byte 07: MSB Line No of End of Top Bar */
 	{0x00,	0x00,	0x00,	0x00,	0x00,	 0x00,	0x00,	0x00,	0x00,
-	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00}, /*06*/
+	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00, 0x00}, /*06*/
+	/* Data Byte 08: LSB Line No of Start of Bottom Bar */
 	{0xE1,	0xE1,	0x41,	0x41,	0xD1,	 0xd1,	0x39,	0x39,	0x39,
-	 0x39,	0x39,	0x39,	0x39,	0xe1, 0xE1, 0x41}, /*07*/
+	 0x39,	0x39,	0x39,	0x39,	0xe1, 0xE1, 0x41, 0x01}, /*07*/
+	/* Data Byte 09: MSB Line No of Start of Bottom Bar */
 	{0x01,	0x01,	0x02,	0x02,	0x02,	 0x02,	0x04,	0x04,	0x04,
-	 0x04,	0x04,	0x04,	0x04,	0x01, 0x01, 0x02}, /*08*/
+	 0x04,	0x04,	0x04,	0x04,	0x01, 0x01, 0x02, 0x04}, /*08*/
+	/* Data Byte 10: LSB Pixel Number of End of Left Bar */
 	{0x00,	0x00,	0x00,	0x00,	0x00,	 0x00,	0x00,	0x00,	0x00,
-	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00}, /*09*/
+	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00, 0x00}, /*09*/
+	/* Data Byte 11: MSB Pixel Number of End of Left Bar */
 	{0x00,	0x00,	0x00,	0x00,	0x00,	 0x00,	0x00,	0x00,	0x00,
-	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00}, /*10*/
+	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00, 0x00}, /*10*/
+	/* Data Byte 12: LSB Pixel Number of Start of Right Bar */
 	{0xD1,	0xD1,	0xD1,	0xD1,	0x01,	 0x01,	0x81,	0x81,	0x81,
-	 0x81,	0x81,	0x81,	0x81,	0x81, 0xD1, 0xD1}, /*11*/
+	 0x81,	0x81,	0x81,	0x81,	0x81, 0xD1, 0xD1, 0x01}, /*11*/
+	/* Data Byte 13: MSB Pixel Number of Start of Right Bar */
 	{0x02,	0x02,	0x02,	0x02,	0x05,	 0x05,	0x07,	0x07,	0x07,
-	 0x07,	0x07,	0x07,	0x07,	0x02, 0x02, 0x02}  /*12*/
+	 0x07,	0x07,	0x07,	0x07,	0x02, 0x02, 0x02, 0x05}  /*12*/
 };
 
 static void hdmi_msm_avi_info_frame(void)
@@ -3746,6 +3762,9 @@
 	case HDMI_VFRMT_720x576p50_4_3:
 		mode = 15;
 		break;
+	case HDMI_VFRMT_1280x1024p60_5_4:
+		mode = 16;
+		break;
 	default:
 		DEV_INFO("%s: mode %d not supported\n", __func__,
 			external_common_state->video_resolution);
@@ -4214,19 +4233,28 @@
 }
 #endif
 
-static void hdmi_msm_hpd_polarity_setup(bool polarity, bool trigger)
+static void hdmi_msm_hpd_polarity_setup(void)
 {
 	u32 cable_sense;
+	bool polarity = !external_common_state->hpd_state;
+	bool trigger = false;
+
 	if (polarity)
 		HDMI_OUTP(0x0254, BIT(2) | BIT(1));
 	else
 		HDMI_OUTP(0x0254, BIT(2));
 
 	cable_sense = (HDMI_INP(0x0250) & BIT(1)) >> 1;
-	DEV_DBG("%s: listen=%s, sense=%s\n", __func__,
+
+	if (cable_sense == polarity)
+		trigger = true;
+
+	DEV_DBG("%s: listen=%s, sense=%s, trigger=%s\n", __func__,
 		polarity ? "connect" : "disconnect",
-		cable_sense ? "connect" : "disconnect");
-	if (trigger && (cable_sense == polarity)) {
+		cable_sense ? "connect" : "disconnect",
+		trigger ? "Yes" : "No");
+
+	if (trigger) {
 		u32 reg_val = HDMI_INP(0x0258);
 
 		/* Toggle HPD circuit to trigger HPD sense */
@@ -4327,8 +4355,8 @@
 		/* Turn on HPD HW circuit */
 		HDMI_OUTP(0x0258, hpd_ctrl | BIT(28));
 
-		/* Set up HPD_CTRL to sense HPD event */
-		hdmi_msm_hpd_polarity_setup(HPD_CONNECT_POLARITY, true);
+		/* Set HPD cable sense polarity */
+		hdmi_msm_hpd_polarity_setup();
 	}
 
 	DEV_DBG("%s: (IRQ, 5V on)\n", __func__);
@@ -4355,10 +4383,26 @@
 		if (hdmi_prim_display ||
 			external_common_state->hpd_feature_on) {
 			DEV_DBG("%s: Turning HPD ciruitry on\n", __func__);
+
+			if (external_common_state->pre_suspend_hpd_state) {
+				external_common_state->pre_suspend_hpd_state =
+					 false;
+
+				hdmi_msm_send_event(HPD_EVENT_OFFLINE);
+			}
+
 			rc = hdmi_msm_hpd_on();
+			if (rc) {
+				DEV_ERR("%s: HPD ON FAILED\n", __func__);
+				return rc;
+			}
 		}
 	} else {
 		DEV_DBG("%s: Turning HPD ciruitry off\n", __func__);
+
+		external_common_state->pre_suspend_hpd_state =
+			external_common_state->hpd_state;
+
 		hdmi_msm_hpd_off();
 	}
 
@@ -4368,60 +4412,54 @@
 static int hdmi_msm_power_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
-	bool changed;
+	int ret = 0;
 
-	if (!hdmi_msm_state || !hdmi_msm_state->hdmi_app_clk || !MSM_HDMI_BASE)
-		return -ENODEV;
+	if (!hdmi_ready()) {
+		DEV_ERR("%s: HDMI/HPD not initialized\n", __func__);
+		return ret;
+	}
 
-	if (!hdmi_msm_state->hpd_initialized ||
-		!external_common_state->hpd_state) {
-		DEV_DBG("%s: HPD not initialized/cable not conn. Returning\n",
-				__func__);
-		return 0;
+	if (!external_common_state->hpd_state) {
+		DEV_DBG("%s:HDMI cable not connected\n", __func__);
+		goto error;
 	}
 
-	DEV_INFO("power: ON (%dx%d %d)\n", mfd->var_xres, mfd->var_yres,
-		mfd->var_pixclock);
+	hdmi_common_get_video_format_from_drv_data(mfd);
 
-	/* Only start transmission with supported resolution */
-	changed = hdmi_common_get_video_format_from_drv_data(mfd);
-	if (changed || external_common_state->default_res_supported) {
-		hdmi_msm_audio_info_setup(TRUE, 0, 0, 0, FALSE);
-		mutex_lock(&external_common_state_hpd_mutex);
+	mutex_lock(&external_common_state_hpd_mutex);
+	if (external_common_state->hpd_state && hdmi_msm_is_power_on()) {
+		mutex_unlock(&external_common_state_hpd_mutex);
+
+		DEV_INFO("HDMI cable connected %s(%dx%d, %d)\n",
+				__func__, mfd->var_xres, mfd->var_yres,
+				mfd->var_pixclock);
+
+		hdmi_msm_turn_on();
 		hdmi_msm_state->panel_power_on = TRUE;
-		if (external_common_state->hpd_state &&
-				hdmi_msm_is_power_on()) {
-			DEV_DBG("%s: Turning HDMI on\n", __func__);
-			mutex_unlock(&external_common_state_hpd_mutex);
-			hdmi_msm_turn_on();
 
-			if (hdmi_msm_state->hdcp_enable) {
-				/* Kick off HDCP Authentication */
-				mutex_lock(&hdcp_auth_state_mutex);
-				hdmi_msm_state->reauth = FALSE;
-				hdmi_msm_state->full_auth_done = FALSE;
-				mutex_unlock(&hdcp_auth_state_mutex);
-				mod_timer(&hdmi_msm_state->hdcp_timer,
-						jiffies + HZ/2);
-			}
-		} else {
-			mutex_unlock(&external_common_state_hpd_mutex);
+		if (hdmi_msm_state->hdcp_enable) {
+			/* Kick off HDCP Authentication */
+			mutex_lock(&hdcp_auth_state_mutex);
+			hdmi_msm_state->reauth = FALSE;
+			hdmi_msm_state->full_auth_done = FALSE;
+			mutex_unlock(&hdcp_auth_state_mutex);
+			mod_timer(&hdmi_msm_state->hdcp_timer, jiffies + HZ/2);
 		}
-
-		hdmi_msm_dump_regs("HDMI-ON: ");
-		DEV_INFO("power=%s DVI= %s\n",
-			hdmi_msm_is_power_on() ? "ON" : "OFF" ,
-			hdmi_msm_is_dvi_mode() ? "ON" : "OFF");
 	} else {
-		DEV_ERR("%s: Video fmt %d not supp. Returning\n",
-				__func__,
-				external_common_state->video_resolution);
+		mutex_unlock(&external_common_state_hpd_mutex);
 	}
 
-	/* Enable HPD interrupt and listen to disconnect interrupts */
-	hdmi_msm_hpd_polarity_setup(HPD_DISCONNECT_POLARITY,
-			external_common_state->hpd_state);
-	return 0;
+	hdmi_msm_dump_regs("HDMI-ON: ");
+
+	DEV_INFO("power=%s DVI= %s\n",
+		hdmi_msm_is_power_on() ? "ON" : "OFF" ,
+		hdmi_msm_is_dvi_mode() ? "ON" : "OFF");
+
+error:
+	/* Set HPD cable sense polarity */
+	hdmi_msm_hpd_polarity_setup();
+
+	return ret;
 }
 
 void mhl_connect_api(boolean on)
@@ -4470,12 +4508,22 @@
  */
 static int hdmi_msm_power_off(struct platform_device *pdev)
 {
-	if (!hdmi_msm_state->hdmi_app_clk)
-		return -ENODEV;
+	int ret = 0;
+
+	/*
+	don't check for hpd_initialized here since user space may
+	turn off HPD via hdmi_msm_hpd_feature() before power off is
+	called which leads to HDCP HW lockup on the next power on.
+	*/
+	if (!(MSM_HDMI_BASE && hdmi_msm_state &&
+			hdmi_msm_state->hdmi_app_clk)) {
+		DEV_ERR("%s: HDMI not initialized\n", __func__);
+		return ret;
+	}
 
 	if (!hdmi_msm_state->panel_power_on) {
-		DEV_DBG("%s: panel not on. returning\n", __func__);
-		return 0;
+		DEV_DBG("%s: panel not ON\n", __func__);
+		goto error;
 	}
 
 	if (hdmi_msm_state->hdcp_enable) {
@@ -4497,6 +4545,7 @@
 		cancel_work_sync(&hdmi_msm_state->hdcp_reauth_work);
 		cancel_work_sync(&hdmi_msm_state->hdcp_work);
 		del_timer_sync(&hdmi_msm_state->hdcp_timer);
+		hdmi_msm_state->reauth = FALSE;
 
 		hdcp_deauthenticate();
 	}
@@ -4511,11 +4560,13 @@
 	hdmi_msm_state->panel_power_on = FALSE;
 	DEV_INFO("power: OFF (audio off)\n");
 
-	/* Enable HPD interrupt and listen to connect interrupts */
-	hdmi_msm_hpd_polarity_setup(HPD_CONNECT_POLARITY,
-				!external_common_state->hpd_state);
+	if (!completion_done(&hdmi_msm_state->hpd_event_processed))
+		complete(&hdmi_msm_state->hpd_event_processed);
+error:
+	/* Set HPD cable sense polarity */
+	hdmi_msm_hpd_polarity_setup();
 
-	return 0;
+	return ret;
 }
 
 void hdmi_msm_config_hdcp_feature(void)
@@ -4540,10 +4591,26 @@
 			hdmi_msm_state->hdcp_enable ? "Enabled" : "Disabled");
 }
 
+static void hdmi_msm_update_panel_info(struct msm_fb_data_type *mfd)
+{
+	if (!mfd)
+		return;
+
+	if (hdmi_common_get_video_format_from_drv_data(mfd))
+		hdmi_common_init_panel_info(&mfd->panel_info);
+}
+
+static bool hdmi_msm_cable_connected(void)
+{
+	return hdmi_msm_state->hpd_initialized &&
+			external_common_state->hpd_state;
+}
+
 static int __devinit hdmi_msm_probe(struct platform_device *pdev)
 {
 	int rc;
 	struct platform_device *fb_dev;
+	struct msm_fb_data_type *mfd = NULL;
 
 	if (!hdmi_msm_state) {
 		pr_err("%s: hdmi_msm_state is NULL\n", __func__);
@@ -4594,21 +4661,21 @@
 	hdmi_msm_state->hdmi_app_clk = clk_get(&pdev->dev, "core_clk");
 	if (IS_ERR(hdmi_msm_state->hdmi_app_clk)) {
 		DEV_ERR("'core_clk' clk not found\n");
-		rc = IS_ERR(hdmi_msm_state->hdmi_app_clk);
+		rc = PTR_ERR(hdmi_msm_state->hdmi_app_clk);
 		goto error;
 	}
 
 	hdmi_msm_state->hdmi_m_pclk = clk_get(&pdev->dev, "master_iface_clk");
 	if (IS_ERR(hdmi_msm_state->hdmi_m_pclk)) {
 		DEV_ERR("'master_iface_clk' clk not found\n");
-		rc = IS_ERR(hdmi_msm_state->hdmi_m_pclk);
+		rc = PTR_ERR(hdmi_msm_state->hdmi_m_pclk);
 		goto error;
 	}
 
 	hdmi_msm_state->hdmi_s_pclk = clk_get(&pdev->dev, "slave_iface_clk");
 	if (IS_ERR(hdmi_msm_state->hdmi_s_pclk)) {
 		DEV_ERR("'slave_iface_clk' clk not found\n");
-		rc = IS_ERR(hdmi_msm_state->hdmi_s_pclk);
+		rc = PTR_ERR(hdmi_msm_state->hdmi_s_pclk);
 		goto error;
 	}
 
@@ -4673,6 +4740,10 @@
 		goto error;
 	}
 
+	mfd = platform_get_drvdata(fb_dev);
+	mfd->update_panel_info = hdmi_msm_update_panel_info;
+	mfd->is_panel_ready = hdmi_msm_cable_connected;
+
 	if (hdmi_prim_display) {
 		rc = hdmi_msm_hpd_on();
 		if (rc)
@@ -4778,15 +4849,22 @@
 		if (external_common_state->sii8240_connected)
 			rc = hdmi_msm_hpd_on();
 	} else {
-		external_common_state->hpd_state = 0;
+		if (external_common_state->hpd_state) {
+			/* Send offline event to switch OFF HDMI and HAL FD */
+			hdmi_msm_send_event(HPD_EVENT_OFFLINE);
+
+			/* Wait for HDMI and FD to close */
+			INIT_COMPLETION(hdmi_msm_state->hpd_event_processed);
+			wait_for_completion_interruptible_timeout(
+				&hdmi_msm_state->hpd_event_processed, HZ);
+
+			external_common_state->hpd_state = 0;
+		}
+
 		hdmi_msm_hpd_off();
-                DEV_INFO("hdmi: HDMI HPD: sense DISCONNECTED: send OFFLINE\n");
-                hdmi_msm_state->hpd_on_offline = FALSE;
-                kobject_uevent(external_common_state->uevent_kobj,
-                        KOBJ_OFFLINE);
-                /*sending hdmi_audio_ch*/
-                switch_set_state(&hdmi_msm_state->hdmi_audio_ch, -1);
-                switch_set_state(&hdmi_msm_state->hdmi_audio_switch, 0);
+		/*sending hdmi_audio_ch*/
+		switch_set_state(&hdmi_msm_state->hdmi_audio_ch, -1);
+		switch_set_state(&hdmi_msm_state->hdmi_audio_switch, 0);
 #ifdef QCT_SWITCH_STATE_CMD
 		SWITCH_SET_HDMI_AUDIO(0, 0);
 
@@ -4887,6 +4965,7 @@
 
 	hdmi_common_init_panel_info(&hdmi_msm_panel_data.panel_info);
 	init_completion(&hdmi_msm_state->ddc_sw_done);
+	init_completion(&hdmi_msm_state->hpd_event_processed);
 	INIT_WORK(&hdmi_msm_state->hpd_state_work, hdmi_msm_hpd_state_work);
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/hdmi_msm.h msm/hdmi_msm.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/hdmi_msm.h	2013-12-17 17:08:08.014147355 -0800
+++ msm/hdmi_msm.h	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -39,11 +39,12 @@
  * Ref. HDMI 1.4a
  * Supplement-1 CEC Section 6, 7
  */
+#define CEC_MAX_OPERAND_SIZE 15
 struct hdmi_msm_cec_msg {
 	uint8 sender_id;
 	uint8 recvr_id;
 	uint8 opcode;
-	uint8 operand[15];
+	uint8 operand[CEC_MAX_OPERAND_SIZE];
 	uint8 frame_size;
 	uint8 retransmit;
 };
@@ -107,9 +108,9 @@
 
 	struct external_common_state_type common;
 	boolean is_mhl_enabled;
+	struct completion hpd_event_processed;
 	struct switch_dev	hdmi_audio_switch;
 	struct switch_dev	hdmi_audio_ch;
-	boolean	boot_completion;
 	boolean hpd_on_offline;
 };
 
@@ -124,7 +125,7 @@
 void hdmi_msm_reset_core(void);
 void hdmi_msm_init_phy(int video_format);
 void hdmi_msm_powerdown_phy(void);
-void hdmi_frame_ctrl_cfg(const struct hdmi_disp_mode_timing_type *timing);
+void hdmi_frame_ctrl_cfg(const struct msm_hdmi_mode_timing_info *timing);
 void hdmi_msm_phy_status_poll(void);
 #endif
 
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/Kconfig msm/Kconfig
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/Kconfig	2013-12-17 17:08:08.010147360 -0800
+++ msm/Kconfig	2013-12-11 02:38:33.000000000 -0800
@@ -233,6 +233,10 @@
 	bool
 	select FB_MSM_MIPI_DSI
 
+config FB_MSM_MIPI_DSI_NT35590
+	bool
+	select FB_MSM_MIPI_DSI
+
 config FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
 	bool
 	select FB_MSM_MIPI_DSI
@@ -413,6 +417,15 @@
         select FB_MSM_MIPI_DSI_NT35516
         default n
 
+config FB_MSM_MIPI_NT35590_CMD_720P_PT
+        bool
+        select FB_MSM_MIPI_DSI_NT35590
+        default n
+
+config FB_MSM_MIPI_NT35590_VIDEO_720P_PT
+        bool
+        select FB_MSM_MIPI_DSI_NT35590
+        default n
 
 config FB_MSM_MIPI_CHIMEI_WXGA
 	bool "LVDS Chimei WXGA Panel using Toshiba MIPI DSI-to-LVDS bridge."
@@ -493,12 +506,6 @@
 	select FB_MSM_MIPI_DSI_RENESAS_TFT
 	default n
 
-config FB_MSM_ENABLE_LCD_EN2
-	bool "LCD_EN2 Enable for J Active project"
-	default n
-	---help---
-		Enable LCD EN2 pin to control AVDD
-
 config FB_MSM_MIPI_SAMSUNG_OCTA_VIDEO_FULL_HD_PT
 	bool
 	select FB_MSM_MIPI_DSI_SAMSUNG_OCTA
@@ -638,6 +645,8 @@
 	select FB_MSM_MIPI_ORISE_CMD_720P_PT
 	select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
 	select FB_MSM_MIPI_NT35516_CMD_QHD_PT
+	select FB_MSM_MIPI_NT35590_CMD_720P_PT
+	select FB_MSM_MIPI_NT35590_VIDEO_720P_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
 	select FB_MSM_MIPI_CHIMEI_WXGA
 	select FB_MSM_MIPI_CHIMEI_WUXGA
@@ -678,6 +687,8 @@
 	select FB_MSM_MIPI_NT35510_CMD_WVGA_PT
 	select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
 	select FM_MSM_MIPI_NT35516_CMD_QHD_PT
+	select FM_MSM_MIPI_NT35590_CMD_720P_PT
+	select FM_MSM_MIPI_NT35590_VIDEO_720P_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
 	---help---
 	  Support for LCDC + MIPI panel auto detect
@@ -686,6 +697,7 @@
 	bool "LVDS + MIPI Panel Auto Detect"
 	select FB_MSM_LVDS_CHIMEI_WXGA
 	select FB_MSM_LVDS_FRC_FHD
+	select FB_MSM_MIPI_NT35590_VIDEO_720P_PT
 	select FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT
 	select FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT
 	select FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA
@@ -696,6 +708,7 @@
 	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
 	select FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT
 	select FB_MSM_MIPI_NT35510_CMD_WVGA_PT
+	select FB_MSM_MIPI_NT35590_CMD_720P_PT
 	select FB_MSM_MIPI_ORISE_VIDEO_720P_PT
 	select FB_MSM_MIPI_ORISE_CMD_720P_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
@@ -802,6 +815,24 @@
         bool "MIPI NT35516 Command qHD PT Panel"
         select FB_MSM_MIPI_NT35516_CMD_QHD_PT
 
+config FB_MSM_MIPI_NT35590_CMD_720P_PT_PANEL
+        bool "MIPI NT35590 Command 720p PT Panel"
+        select FB_MSM_MIPI_NT35590_CMD_720P_PT
+	---help---
+	Support for Truly NT35590 panel. This
+	panel supports MIPI DSI interface in
+	Command mode. The panel resolution is
+	720p (720x1280).
+
+config FB_MSM_MIPI_NT35590_VIDEO_720P_PT_PANEL
+        bool "MIPI NT35590 Video 720p PT Panel"
+        select FB_MSM_MIPI_NT35590_VIDEO_720P_PT
+	---help---
+	Support for Truly NT35590 panel. This
+	panel supports MIPI DSI interface in
+	Video mode. The panel resolution is
+	720p (720x1280).
+
 config FB_MSM_MIPI_SIMULATOR_VIDEO_PANEL
 	bool "MIPI Simulator Video Panel"
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/logo.c msm/logo.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/logo.c	2013-12-17 17:08:08.014147355 -0800
+++ msm/logo.c	2013-12-11 02:38:33.000000000 -0800
@@ -134,12 +134,12 @@
 				bits += n << 1;
 				bits += pad;
 			} else {
-			memset16(bits, ptr[1], n << 1);
-			bits += n;
+				memset16(bits, ptr[1], n << 1);
+				bits += n;
+				max -= n;
+				ptr += 2;
+				count -= 4;
 			}
-			max -= n;
-			ptr += 2;
-			count -= 4;
 		}
 	}
 #ifndef CONFIG_FRAMEBUFFER_CONSOLE
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/lvds.c msm/lvds.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/lvds.c	2013-12-17 17:08:08.014147355 -0800
+++ msm/lvds.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -63,6 +63,7 @@
 static void lvds_init(struct msm_fb_data_type *mfd)
 {
 	unsigned int lvds_intf = 0, lvds_phy_cfg0 = 0;
+	mdp_clk_ctrl(1);
 
 	MDP_OUTP(MDP_BASE + 0xc2034, 0x33);
 	usleep(1000);
@@ -231,6 +232,7 @@
 	usleep(1);
 	/* MDP_LVDSPHY_CFG0, enable serialization */
 	MDP_OUTP(MDP_BASE +  0xc3100, lvds_phy_cfg0);
+	mdp_clk_ctrl(0);
 }
 
 static int lvds_off(struct platform_device *pdev)
@@ -244,9 +246,11 @@
 	if (lvds_clk)
 		clk_disable_unprepare(lvds_clk);
 
+	mdp_clk_ctrl(1);
 	MDP_OUTP(MDP_BASE +  0xc3100, 0x0);
 	MDP_OUTP(MDP_BASE + 0xc3000, 0x0);
 	usleep(10);
+	mdp_clk_ctrl(0);
 
 	if (lvds_pdata && lvds_pdata->lcdc_power_save)
 		lvds_pdata->lcdc_power_save(0);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/Makefile msm/Makefile
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/Makefile	2013-12-17 17:08:08.010147360 -0800
+++ msm/Makefile	2013-12-11 02:38:33.000000000 -0800
@@ -87,6 +87,7 @@
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TRULY) += mipi_truly.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35510) += mipi_NT35510.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35516) += mipi_truly_tft540960_1_e.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35590) += mipi_NT35590.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_SIMULATOR) += mipi_simulator.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_SAMSUNG_OLED) += mipi_samsung_oled.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_RENESAS_TFT) += mipi_samsung_tft.o
@@ -132,6 +133,7 @@
 obj-y += mipi_renesas_video_fwvga_pt.o mipi_renesas_cmd_fwvga_pt.o
 obj-y += mipi_NT35510_video_wvga_pt.o mipi_NT35510_cmd_wvga_pt.o
 obj-y += mipi_truly_tft540960_1_e_video_qhd_pt.o mipi_truly_tft540960_1_e_cmd_qhd_pt.o
+obj-y += mipi_NT35590_cmd_720p_pt.o mipi_NT35590_video_720p_pt.o
 obj-y += mipi_chimei_wxga_pt.o
 obj-y += mipi_chimei_wuxga.o
 obj-y += mipi_truly_video_wvga_pt.o
@@ -151,6 +153,8 @@
 obj-$(CONFIG_FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT) += mipi_NT35510_video_wvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_NT35516_CMD_QHD_PT) += mipi_truly_tft540960_1_e_cmd_qhd_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_NT35516_VIDEO_QHD_PT) += mipi_truly_tft540960_1_e_video_qhd_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35590_CMD_720P_PT) += mipi_NT35590_cmd_720p_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35590_VIDEO_720P_PT) += mipi_NT35590_video_720p_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO) += mipi_simulator_video.o
 obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WXGA) += mipi_chimei_wxga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WUXGA) += mipi_chimei_wuxga.o
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mddihost.c msm/mddihost.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mddihost.c	2013-12-17 17:08:08.014147355 -0800
+++ msm/mddihost.c	2013-12-11 02:38:33.000000000 -0800
@@ -11,6 +11,7 @@
  *
  */
 
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdnie_lite_tuning.c msm/mdnie_lite_tuning.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdnie_lite_tuning.c	2013-12-17 17:08:08.014147355 -0800
+++ msm/mdnie_lite_tuning.c	2013-12-11 02:38:33.000000000 -0800
@@ -71,7 +71,7 @@
 
 int play_speed_1_5;
 #if defined(CONFIG_FB_MSM_MIPI_RENESAS_TFT_VIDEO_FULL_HD_PT_PANEL)
-static int cabc = -1;
+static int cabc = 0;
 extern int mipi_samsung_cabc_onoff ( int enable );
 #endif
 
@@ -996,11 +996,6 @@
 	return size;
 }
 
-int is_cabc_on ( void )
-{
-	return cabc;
-}
-
 static DEVICE_ATTR(cabc, 0664,
 			cabc_show,
 			cabc_store);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdnie_lite_tuning_data_jactiveltexx.h msm/mdnie_lite_tuning_data_jactiveltexx.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdnie_lite_tuning_data_jactiveltexx.h	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdnie_lite_tuning_data_jactiveltexx.h	2013-12-11 02:38:33.000000000 -0800
@@ -981,7 +981,7 @@
 	0x01, //mdnie_en
 	0x00, //data_width mask 00 000
 	0x33, //scr_roi 1 scr algo_roi 1 algo 00 1 0 00 1 0
-	0x06, //sharpen cc gamma 00 0 0
+	0x0e, //sharpen cc gamma 00 0 0
 };
 
 static char STANDARD_VIDEO_2[] = {
@@ -1100,7 +1100,7 @@
 	0x01, //mdnie_en
 	0x00, //data_width mask 00 000
 	0x33, //scr_roi 1 scr algo_roi 1 algo 00 1 0 00 1 0
-	0x0b, //sharpen cc gamma 00 0 0
+	0x0f, //sharpen cc gamma 00 0 0
 };
 
 static char DYNAMIC_VIDEO_2[] = {
@@ -1338,7 +1338,7 @@
 	0x01, //mdnie_en
 	0x00, //data_width mask 00 000
 	0x33, //scr_roi 1 scr algo_roi 1 algo 00 1 0 00 1 0
-	0x06, //sharpen cc gamma 00 0 0
+	0x0e, //sharpen cc gamma 00 0 0
 };
 
 char AUTO_VIDEO_2[] = {
@@ -1937,7 +1937,7 @@
 	0x01, //mdnie_en
 	0x00, //data_width mask 00 000
 	0x33, //scr_roi 1 scr algo_roi 1 algo 00 1 0 00 1 0
-	0x02, //sharpen cc gamma 00 0 0
+	0x00, //sharpen cc gamma 00 0 0
 };
 
 static char CAMERA_2[] = {
@@ -2031,24 +2031,24 @@
 	0x20, //curve23 a
 	0x00, //curve24 b
 	0xFF, //curve24 a
-	0x04, //cc r1 0.1
-	0x48,
+	0x04, //cc r1 0.06
+	0x2b,
 	0x1f, //cc r2
-	0xc4,
+	0xdc,
 	0x1f, //cc r3
-	0xf4,
+	0xf9,
 	0x1f, //cc g1
-	0xe1,
+	0xee,
 	0x04, //cc g2
-	0x2b,
+	0x19,
 	0x1f, //cc g3
-	0xf4,
+	0xf9,
 	0x1f, //cc b1
-	0xe1,
+	0xee,
 	0x1f, //cc b2
-	0xc4,
+	0xdc,
 	0x04, //cc b3
-	0x5b,
+	0x36,
 };
 
 char AUTO_CAMERA_1[] = {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdnie_lite_tuning.h msm/mdnie_lite_tuning.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdnie_lite_tuning.h	2013-12-17 17:08:08.014147355 -0800
+++ msm/mdnie_lite_tuning.h	2013-12-11 02:38:33.000000000 -0800
@@ -127,9 +127,6 @@
 void mdnie_lite_tuning_init(void);
 void init_mdnie_class(void);
 void is_negative_on(void);
-#if defined(CONFIG_FB_MSM_MIPI_RENESAS_TFT_VIDEO_FULL_HD_PT_PANEL)
-int is_cabc_on ( void );
-#endif
 
 void coordinate_tunning(int x, int y);
 
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_dtv.c msm/mdp4_dtv.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_dtv.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_dtv.c	2013-12-11 02:38:33.000000000 -0800
@@ -83,34 +83,10 @@
 static struct lcdc_platform_data *dtv_pdata;
 #ifdef CONFIG_MSM_BUS_SCALING
 static uint32_t dtv_bus_scale_handle;
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
-static uint32_t dtv_bus_scale_override;
-static uint32_t dtv_current_bus_vector_index;
-#endif
 #else
 static struct clk *ebi1_clk;
 #endif
 
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
-void dtv_update_camera_vector_override(uint8_t enable)
-{
-#ifdef CONFIG_MSM_BUS_SCALING
-	if (dtv_bus_scale_handle <= 0)
-		return;
-	if (enable) {
-		dtv_bus_scale_override = 1;
-		if (dtv_current_bus_vector_index)
-			msm_bus_scale_client_update_request(dtv_bus_scale_handle, 2);
-	} else {
-		dtv_bus_scale_override = 0;
-		if (dtv_current_bus_vector_index)
-			msm_bus_scale_client_update_request(dtv_bus_scale_handle,
-				dtv_current_bus_vector_index);
-	}
-#endif
-}
-#endif
-
 static int dtv_off(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -169,17 +145,9 @@
 	if (dtv_pdata && dtv_pdata->lcdc_gpio_config)
 		ret = dtv_pdata->lcdc_gpio_config(0);
 #ifdef CONFIG_MSM_BUS_SCALING
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
-	if (dtv_bus_scale_handle > 0) {
-		dtv_current_bus_vector_index = 0;
-		msm_bus_scale_client_update_request(dtv_bus_scale_handle,
-							0);
-	}
-#else
 	if (dtv_bus_scale_handle > 0)
 		msm_bus_scale_client_update_request(dtv_bus_scale_handle,
 							0);
-#endif
 #else
 	if (ebi1_clk)
 		clk_disable_unprepare(ebi1_clk);
@@ -212,21 +180,9 @@
 		pm_qos_rate = 58000;
 	mdp4_extn_disp = 1;
 #ifdef CONFIG_MSM_BUS_SCALING
-#if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
-	if (dtv_bus_scale_handle > 0) {
-		if (dtv_bus_scale_override)
-			msm_bus_scale_client_update_request(dtv_bus_scale_handle,
-							2);
-		else
-			msm_bus_scale_client_update_request(dtv_bus_scale_handle,
-							1);
-		dtv_current_bus_vector_index = 1;
-	}
-#else
 	if (dtv_bus_scale_handle > 0)
 		msm_bus_scale_client_update_request(dtv_bus_scale_handle,
 							1);
-#endif
 #else
 	if (ebi1_clk) {
 		clk_set_rate(ebi1_clk, pm_qos_rate * 1000);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4.h msm/mdp4.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4.h	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4.h	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,5 @@
-/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+/*
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -32,10 +33,8 @@
 extern u64 mdp_max_bw;
 extern u32 mdp_bw_ab_factor;
 extern u32 mdp_bw_ib_factor;
-extern u32 mdp_iommu_max_map_size;
-
-#define MDP4_BW_AB_DEFAULT_FACTOR (115) /* 1.15 */
-#define MDP4_BW_IB_DEFAULT_FACTOR (150) /* 1.5 */
+#define MDP4_BW_AB_FACTOR (200)	/* 2.00 */
+#define MDP4_BW_IB_FACTOR (210)	/* 2.10 */
 #define MDP_BUS_SCALE_AB_STEP (0x4000000)
 
 #define MDP4_OVERLAYPROC0_BASE	0x10000
@@ -46,11 +45,6 @@
 #define MDP4_VIDEO_OFF 0x10000
 #define MDP4_VIDEO_CSC_OFF 0x4000
 
-#define CSC_MV_OFF	0x400
-#define CSC_BV_OFF	0x500
-#define CSC_LV_OFF	0x600
-#define CSC_POST_OFF	0x80
-
 #define MDP4_RGB_BASE 0x40000
 #define MDP4_RGB_OFF 0x10000
 
@@ -304,7 +298,8 @@
 	uint32 src_format;
 	uint32 src_width;	/* source img width */
 	uint32 src_height;	/* source img height */
-	uint32 frame_size;	/* TILE frame size */
+	uint32 prev_src_width;  /* source img width */
+	uint32 prev_src_height; /* source img height */
 	uint32 is_3d;
 	uint32 src_width_3d;	/* source img width */
 	uint32 src_height_3d;	/* source img height */
@@ -505,6 +500,8 @@
 void mdp4_dtv_wait4vsync(int cndx);
 void mdp4_dtv_vsync_ctrl(struct fb_info *info, int enable);
 void mdp4_dtv_base_swap(int cndx, struct mdp4_overlay_pipe *pipe);
+void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
+int mdp4_dtv_pipe_commit(int cndx, int wait);
 #else
 static inline void mdp4_overlay_dtv_start(void)
 {
@@ -551,10 +548,18 @@
 {
 	return;
 }
-static inline void mdp4_dtv_base_swap(struct mdp4_overlay_pipe *pipe)
+static inline void mdp4_dtv_base_swap(int cndx, struct mdp4_overlay_pipe *pipe)
+{
+	/* empty */
+}
+static inline void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe)
 {
 	/* empty */
 }
+static inline int mdp4_dtv_pipe_commit(int cndx, int wait)
+{
+	return 0;
+}
 #endif /* CONFIG_FB_MSM_DTV */
 
 void mdp4_dtv_set_black_screen(void);
@@ -578,11 +583,9 @@
 void mdp4_primary_rdptr(void);
 void mdp4_dsi_cmd_overlay(struct msm_fb_data_type *mfd);
 int mdp4_overlay_commit(struct fb_info *info);
-void mdp4_overlay_commit_finish(struct fb_info *info);
 int mdp4_dsi_video_pipe_commit(int cndx, int wait);
-int mdp4_dsi_cmd_pipe_commit(int cndx, int wait, u32 *release_busy);
+int mdp4_dsi_cmd_pipe_commit(int cndx, int wait);
 int mdp4_lcdc_pipe_commit(int cndx, int wait);
-int mdp4_dtv_pipe_commit(int cndx, int wait);
 int mdp4_dsi_cmd_update_cnt(int cndx);
 void mdp4_dsi_rdptr_init(int cndx);
 void mdp4_dsi_vsync_init(int cndx);
@@ -626,7 +629,6 @@
 void mdp4_mixer_stage_commit(int mixer);
 void mdp4_dsi_cmd_do_update(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_lcdc_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
-void mdp4_dtv_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_overlay_pipe_free(struct mdp4_overlay_pipe *pipe, int all);
 void mdp4_overlay_dmap_cfg(struct msm_fb_data_type *mfd, int lcdc);
 void mdp4_overlay_dmap_xy(struct mdp4_overlay_pipe *pipe);
@@ -808,6 +810,7 @@
 void mdp4_dsi_cmd_base_swap(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_dsi_cmd_wait4vsync(int cndx);
 void mdp4_dsi_video_wait4vsync(int cndx);
+void mdp4_mixer_reset(int mixer);
 void mdp4_dsi_cmd_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_dsi_video_pipe_queue(int cndx, struct mdp4_overlay_pipe *pipe);
 void mdp4_dsi_cmd_vsync_ctrl(struct fb_info *info, int enable);
@@ -872,6 +875,7 @@
 {
 	/* empty */
 }
+
 #endif /* CONFIG_FB_MSM_MIPI_DSI */
 
 void mdp4_dsi_cmd_kickoff_ui(struct msm_fb_data_type *mfd,
@@ -934,6 +938,7 @@
 int mdp4_pcc_cfg(struct mdp_pcc_cfg_data *cfg_ptr);
 int mdp4_argc_cfg(struct mdp_pgc_lut_data *pgc_ptr);
 int mdp4_qseed_cfg(struct mdp_qseed_cfg_data *cfg);
+int mdp4_calib_config(struct mdp_calib_config_data *cfg);
 int mdp4_qseed_access_cfg(struct mdp_qseed_cfg *cfg, uint32_t base);
 u32  mdp4_allocate_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
 void mdp4_init_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
@@ -956,10 +961,14 @@
 			      struct msm_fb_data_type *mfd);
 int mdp4_calc_blt_mdp_bw(struct msm_fb_data_type *mfd,
 			 struct mdp4_overlay_pipe *pipe);
-int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd);
+int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
+				struct mdp4_overlay_pipe *plist);
 void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd, int flag);
+int mdp4_update_base_blend(struct msm_fb_data_type *mfd,
+				struct mdp_blend_cfg *mdp_blend_cfg);
 u32 mdp4_get_mixer_num(u32 panel_type);
 int mdp4_overlay_reset(void);
+void mdp4_vg_csc_restore(void);
 void dump_underrun_pipe_info(void);
 #if defined(CONFIG_MACH_JACTIVE_ATT) || defined(CONFIG_MACH_JACTIVE_EUR)
 void dtv_update_camera_vector_override(uint8_t enable);
@@ -988,7 +997,6 @@
 #if defined(CONFIG_FB_MSM_CAMERA_CSC)
 #define CSC_UPDATA_SIZE 10
 #endif
-
 #ifdef CONFIG_FB_MSM_OVERLAY
 int mdp4_unmap_sec_resource(struct msm_fb_data_type *mfd);
 #else
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay.c msm/mdp4_overlay.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_overlay.c	2013-12-11 02:38:33.000000000 -0800
@@ -62,6 +62,7 @@
 	uint32 flush[MDP4_MIXER_MAX];
 	struct iommu_free_list iommu_free[MDP4_MIXER_MAX];
 	struct iommu_free_list iommu_free_prev[MDP4_MIXER_MAX];
+	uint32 dmap_cfg[5];
 	uint32 cs_controller;
 	uint32 panel_3d;
 	uint32 panel_mode;
@@ -113,7 +114,6 @@
 };
 
 static DEFINE_MUTEX(iommu_mutex);
-static DEFINE_MUTEX(perf_mutex);
 static struct mdp4_overlay_ctrl *ctrl = &mdp4_overlay_db;
 
 struct mdp4_overlay_perf {
@@ -121,18 +121,17 @@
 	u32 use_ov_blt[MDP4_MIXER_MAX];
 	u64 mdp_ov_ab_bw[MDP4_MIXER_MAX];
 	u64 mdp_ov_ib_bw[MDP4_MIXER_MAX];
-	u32 pipe_cnt;
 	u64 mdp_ab_bw;
 	u64 mdp_ib_bw;
 	u64 mdp_ab_port0_bw;
 	u64 mdp_ib_port0_bw;
 	u64 mdp_ab_port1_bw;
 	u64 mdp_ib_port1_bw;
-
+	u32 pipe_cnt;
 };
 
-static struct mdp4_overlay_perf perf_request;
-static struct mdp4_overlay_perf perf_current;
+struct mdp4_overlay_perf perf_request;
+struct mdp4_overlay_perf perf_current;
 
 void  mdp4_overlay_free_base_pipe(struct msm_fb_data_type *mfd)
 {
@@ -220,17 +219,12 @@
 {
 	int i;
 	struct ion_handle *ihdl;
-
 	struct iommu_free_list *flist, *pflist;
 
 	if (mixer >= MDP4_MIXER_MAX)
 		return;
 
-	if (!display_iclient) 
-		return;
-
 	mutex_lock(&iommu_mutex);
-
 	pflist = &ctrl->iommu_free_prev[mixer];
 	flist = &ctrl->iommu_free[mixer];
 	pr_debug("%s: mixer=%d fndx=%d %d\n", __func__,
@@ -334,8 +328,6 @@
 	struct ion_handle **srcp_ihdl)
 {
 	struct mdp4_iommu_pipe_info *iom;
-	unsigned long size = 0, map_size = 0;
-	int ret;
 
 	if (!display_iclient)
 		return -EINVAL;
@@ -349,33 +341,14 @@
 	pr_debug("mixer %u, pipe %u, plane %u\n", pipe->mixer_num,
 		pipe->pipe_ndx, plane);
 
-	if(mdp4_overlay_format2type(pipe->src_format) == OVERLAY_TYPE_RGB) {
-		ret = ion_handle_get_size(display_iclient, *srcp_ihdl, &size);
-		if (ret)
-			pr_err("ion_handle_get_size failed with ret %d\n", ret);
-		map_size = mdp_iommu_max_map_size;
-		if(map_size < size)
-			map_size = size;
-
-		if (ion_map_iommu(display_iclient, *srcp_ihdl,
-				DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K, map_size, start,
-				len, 0, 0)) {
+	if (ion_map_iommu(display_iclient, *srcp_ihdl,
+			DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K, 0, start,
+			len, 0, 0)) {
 			ion_free(display_iclient, *srcp_ihdl);
-			pr_err("%s(): ion_map_iommu() failed\n",
-					__func__);
-			return -EINVAL;
-		}
-	} else {
-
-		if (ion_map_iommu(display_iclient, *srcp_ihdl,
-				DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K, 0, start,
-				len, 0, 0)) {
-			ion_free(display_iclient, *srcp_ihdl);
-			pr_err("%s(): ion_map_iommu() failed\n",
-					__func__);
-			return -EINVAL;
-		}
+		pr_err("ion_map_iommu() failed\n");
+		return -EINVAL;
 	}
+
 	mutex_lock(&iommu_mutex);
 	iom = &pipe->iommu;
 	if (iom->prev_ihdl[plane]) {
@@ -625,6 +598,7 @@
 	mask = 0x0FFFFFFF;
 	dma2_cfg_reg = (dma2_cfg_reg & mask) | (curr & ~mask);
 	MDP_OUTP(MDP_BASE + 0x90000, dma2_cfg_reg);
+	ctrl->dmap_cfg[0] = dma2_cfg_reg;
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 }
@@ -648,24 +622,40 @@
 		off = 0;
 		if (pipe->dmap_cnt & 0x01)
 			off = pipe->src_height * pipe->src_width * bpp;
+		ctrl->dmap_cfg[2] = pipe->dma_blt_addr + off;
 		MDP_OUTP(MDP_BASE + 0x90008, pipe->dma_blt_addr + off);
 		/* RGB888, output of overlay blending */
 		MDP_OUTP(MDP_BASE + 0x9000c, pipe->src_width * bpp);
+                ctrl->dmap_cfg[3] = pipe->src_width * bpp;
 	} else {
 		MDP_OUTP(MDP_BASE + 0x90008, pipe->srcp0_addr);
+		ctrl->dmap_cfg[2] = pipe->srcp0_addr;
 		MDP_OUTP(MDP_BASE + 0x9000c, pipe->srcp0_ystride);
+		ctrl->dmap_cfg[3] = pipe->srcp0_ystride;
 	}
 	/* dma_p source */
 	MDP_OUTP(MDP_BASE + 0x90004,
 			(pipe->src_height << 16 | pipe->src_width));
+	ctrl->dmap_cfg[1] = (pipe->src_height << 16 | pipe->src_width);
 
 	/* dma_p dest */
 	MDP_OUTP(MDP_BASE + 0x90010, (pipe->dst_y << 16 | pipe->dst_x));
+	ctrl->dmap_cfg[4] = (pipe->dst_y << 16 | pipe->dst_x);
 
 	if (!in_interrupt())
 		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 }
 
+static void mdp4_overlay_dmap_reconfig(void)
+{
+        MDP_OUTP(MDP_BASE + 0x90000, ctrl->dmap_cfg[0]);
+        MDP_OUTP(MDP_BASE + 0x90004, ctrl->dmap_cfg[1]);
+        MDP_OUTP(MDP_BASE + 0x90008, ctrl->dmap_cfg[2]);
+        MDP_OUTP(MDP_BASE + 0x9000c, ctrl->dmap_cfg[3]);
+        MDP_OUTP(MDP_BASE + 0x90010, ctrl->dmap_cfg[4]);
+}
+
+
 #define MDP4_VG_PHASE_STEP_DEFAULT	0x20000000
 #define MDP4_VG_PHASE_STEP_SHIFT	29
 
@@ -1068,13 +1058,28 @@
 	outpdw(vg_base + 0x0008, dst_size);	/* MDP_RGB_DST_SIZE */
 	outpdw(vg_base + 0x000c, dst_xy);	/* MDP_RGB_DST_XY */
 
-	/* TILE frame size */
 	if (pipe->frame_format != MDP4_FRAME_FORMAT_LINEAR) {
-		if ((ctrl->panel_mode & MDP4_PANEL_DSI_CMD && pipe->mixer_num == 0) ||
-			(ctrl->panel_mode & MDP4_PANEL_WRITEBACK && pipe->mixer_num == 2))
-			outpdw(vg_base + 0x0048, frame_size);
-		else
-			pipe->frame_size = frame_size;
+		struct mdp4_overlay_pipe *real_pipe;
+		u32 psize, csize;
+
+		/*
+		 * video tile frame size register is NOT double buffered.
+		 * when this register updated, it kicks in immediatly
+		 * During transition from smaller resolution to higher
+		 * resolution  it may have possibility that mdp still fetch
+		 * from smaller resolution buffer with new higher resolution
+		 * frame size. This will cause iommu page fault.
+		 */
+		real_pipe = mdp4_overlay_ndx2pipe(pipe->pipe_ndx);
+		psize = real_pipe->prev_src_height * real_pipe->prev_src_width;
+		csize = pipe->src_height * pipe->src_width;
+		if (psize && (csize > psize)) {
+			frame_size = (real_pipe->prev_src_height << 16 |
+					real_pipe->prev_src_width);
+		}
+		outpdw(vg_base + 0x0048, frame_size);	/* TILE frame size */
+		real_pipe->prev_src_height = pipe->src_height;
+		real_pipe->prev_src_width = pipe->src_width;
 	}
 
 	/*
@@ -1137,6 +1142,7 @@
 		}
 	}
 
+
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	mdp4_stat.pipe[pipe->pipe_num]++;
@@ -1800,6 +1806,50 @@
 	return cnt;
 }
 
+void mdp4_mixer_reset(int mixer)
+{
+	uint32 data, data1, mask;
+	int i, ndx, min, max, bit;
+
+	mdp_clk_ctrl(1);
+	/* MDP_LAYERMIXER_IN_CFG, shard by both mixer 0 and 1  */
+	data = inpdw(MDP_BASE + 0x10100);
+	data1 = data;
+
+	if (mixer == 0) {
+		min = 1;
+		max = 8;
+		bit = 0x03; /* mixer0, dmap */
+	} else {
+		min = 9;
+		max = 0xf;
+		bit = 0x0C; /* mixer1, dmae */
+	}
+	mask = 0x0f;
+	for (i = 0 ; i < 8 ; i++) {
+		ndx = data & mask;
+		ndx >>= (i * 4);
+		if (ndx >= min && ndx <= max)
+			data1 &= ~mask;  /* unstage pipe from mixer */
+		mask <<= 4;
+	}
+	pr_debug("%s: => MIXER_RESET, data1=%x data=%x bit=%x\n",
+				__func__, data1, data, bit);
+	/* unstage pipes of mixer to be reset */
+	outpdw(MDP_BASE + 0x10100, data1); /* MDP_LAYERMIXER_IN_CFG */
+	outpdw(MDP_BASE + 0x18000, 0);
+
+	mdp4_sw_reset(bit); /* reset mixer */   /* 0 => mixer0, dmap */
+
+	/* restore origianl stage */
+	outpdw(MDP_BASE + 0x10100, data); /* MDP_LAYERMIXER_IN_CFG */
+	outpdw(MDP_BASE + 0x18000, 0);
+
+	mdp4_vg_csc_restore();
+	mdp4_overlay_dmap_reconfig();
+	mdp_clk_ctrl(0);
+}
+
 void mdp4_mixer_stage_commit(int mixer)
 {
 	struct mdp4_overlay_pipe *pipe;
@@ -1863,6 +1913,7 @@
 	mdp_clk_ctrl(0);
 }
 
+
 void mdp4_mixer_stage_up(struct mdp4_overlay_pipe *pipe, int commit)
 {
 	struct mdp4_overlay_pipe *pp;
@@ -1897,7 +1948,7 @@
 			ctrl->stage[mixer][i] = NULL;  /* clear it */
 	}
 
-	if (commit)
+	if (commit || (mixer > 0 && !hdmi_prim_display))
 		mdp4_mixer_stage_commit(mixer);
 }
 /*
@@ -1908,10 +1959,9 @@
 void mdp4_overlay_borderfill_stage_up(struct mdp4_overlay_pipe *pipe)
 {
 	struct mdp4_overlay_pipe *bspipe;
-	struct mdp4_iommu_pipe_info iom;
 	int ptype, pnum, pndx, mixer;
 	int format, alpha_enable, alpha;
-	int i = 0;
+	struct mdp4_iommu_pipe_info iom;
 
 	if (pipe->pipe_type != OVERLAY_TYPE_BF)
 		return;
@@ -1925,11 +1975,13 @@
 	}
 
 	bspipe = ctrl->stage[mixer][MDP4_MIXER_STAGE_BASE];
-	if(!bspipe) {
-		pr_err("%s:%d base pipe in NULL", __func__, __LINE__);
-		return;
-	}
-	
+
+        if (bspipe == NULL) {
+                pr_err("%s: no base layer at mixer=%d\n",
+                                __func__, mixer);
+                return;
+        }
+
 	/*
 	 * bspipe is clone here
 	 * get real pipe
@@ -1940,6 +1992,12 @@
 		return;
 	}
 
+        if (bspipe == NULL) {
+                pr_err("%s: mdp4_overlay_ndx2pipe returned null pipe ndx\n",
+                                __func__);
+                return;
+        }
+
 	/* save original base layer */
 	ctrl->baselayer[mixer] = bspipe;
 
@@ -1960,11 +2018,6 @@
 	pipe->alpha = alpha;
 	pipe->iommu = iom;
 
-	for(i = 0; i < MDP4_MAX_PLANE; i++) {
-		pipe->iommu.prev_ihdl[i] = NULL;
-		pipe->iommu.ihdl[i] = NULL;
-	}
-
 	/* free original base layer pipe to be sued as normal pipe */
 	bspipe->pipe_used = 0;
 
@@ -2148,51 +2201,51 @@
 		blend++;
 	}
 }
-static void mdp4_set_blend_by_op(struct mdp4_overlay_pipe *s_pipe,        
-					struct mdp4_overlay_pipe *d_pipe,                                
-					int alpha_drop,                                                  
-					struct blend_cfg *blend)                                         
-{                                                                         
-	int d_alpha, s_alpha;                                                    
-	u32 op;                                                                  
-                                                                          
-	d_alpha = d_pipe->alpha_enable;                                          
-	s_alpha = s_pipe->alpha_enable;                                          
-	/* base on fg's alpha */                                                 
-	blend->fg_alpha = s_pipe->alpha;                                         
-	blend->bg_alpha = 0x0ff - s_pipe->alpha;                                 
-	blend->op = MDP4_BLEND_FG_ALPHA_FG_CONST |                               
-	MDP4_BLEND_BG_ALPHA_BG_CONST;                                            
-	blend->co3_sel = 1; /* use fg alpha */                                   
-	op = s_pipe->blend_op;                                                   
-	if (op == BLEND_OP_OPAQUE) {                                             
-		blend->bg_alpha = 0;                                                   
-		blend->fg_alpha = 0xff;                                                
-	} else if ((op == BLEND_OP_PREMULTIPLIED) &&                             
-			(!alpha_drop) && s_alpha) {                                          
-		blend->op = MDP4_BLEND_FG_ALPHA_FG_CONST |                             
-			MDP4_BLEND_BG_INV_ALPHA |                                            
-			MDP4_BLEND_BG_ALPHA_FG_PIXEL;                                        
-		if (blend->fg_alpha != 0xff) {                                         
-			blend->bg_alpha = blend->fg_alpha;                                   
-			blend->op |= MDP4_BLEND_BG_MOD_ALPHA;                                
-		}                                                                      
-	} else if (!alpha_drop && s_alpha) {                                     
-		blend->op = MDP4_BLEND_FG_ALPHA_FG_PIXEL |                             
-			MDP4_BLEND_BG_INV_ALPHA |                                            
-			MDP4_BLEND_BG_ALPHA_FG_PIXEL;                                        
-		if (blend->fg_alpha != 0xff) {                                         
-			blend->bg_alpha = blend->fg_alpha;                                   
-            blend->op |= MDP4_BLEND_FG_MOD_ALPHA |
-				MDP4_BLEND_BG_MOD_ALPHA;                                           
-		}                                                                      
-	}                                                                        
-	if (!s_alpha && d_alpha)                                                 
-		blend->co3_sel = 0;                                                    
-	pr_debug("%s: op %d bg alpha %d, fg alpha %d blend: %x\n",               
-		__func__, op, blend->bg_alpha, blend->fg_alpha, blend->op);            
-}
 
+static void mdp4_set_blend_by_op(struct mdp4_overlay_pipe *s_pipe,
+					struct mdp4_overlay_pipe *d_pipe,
+					int alpha_drop,
+					struct blend_cfg *blend)
+{
+	int d_alpha, s_alpha;
+	u32 op;
+
+	d_alpha = d_pipe->alpha_enable;
+	s_alpha = s_pipe->alpha_enable;
+	/* base on fg's alpha */
+	blend->fg_alpha = s_pipe->alpha;
+	blend->bg_alpha = 0x0ff - s_pipe->alpha;
+	blend->op = MDP4_BLEND_FG_ALPHA_FG_CONST |
+	MDP4_BLEND_BG_ALPHA_BG_CONST;
+	blend->co3_sel = 1; /* use fg alpha */
+	op = s_pipe->blend_op;
+	if (op == BLEND_OP_OPAQUE) {
+		blend->bg_alpha = 0;
+		blend->fg_alpha = 0xff;
+	} else if ((op == BLEND_OP_PREMULTIPLIED) &&
+			(!alpha_drop) && s_alpha) {
+		blend->op = MDP4_BLEND_FG_ALPHA_FG_CONST |
+			MDP4_BLEND_BG_INV_ALPHA |
+			MDP4_BLEND_BG_ALPHA_FG_PIXEL;
+		if (blend->fg_alpha != 0xff) {
+			blend->bg_alpha = blend->fg_alpha;
+			blend->op |= MDP4_BLEND_BG_MOD_ALPHA;
+		}
+	} else if (!alpha_drop && s_alpha) {
+		blend->op = MDP4_BLEND_FG_ALPHA_FG_PIXEL |
+			MDP4_BLEND_BG_INV_ALPHA |
+			MDP4_BLEND_BG_ALPHA_FG_PIXEL;
+		if (blend->fg_alpha != 0xff) {
+			blend->bg_alpha = blend->fg_alpha;
+			blend->op |= MDP4_BLEND_FG_MOD_ALPHA |
+				MDP4_BLEND_BG_MOD_ALPHA;
+		}
+	}
+	if (!s_alpha && d_alpha)
+		blend->co3_sel = 0;
+	pr_debug("%s: op %d bg alpha %d, fg alpha %d blend: %x\n",
+		__func__, op, blend->bg_alpha, blend->fg_alpha, blend->op);
+}
 
 static void mdp4_set_blend_by_fmt(struct mdp4_overlay_pipe *s_pipe,
 					struct mdp4_overlay_pipe *d_pipe,
@@ -2251,7 +2304,7 @@
 	struct blend_cfg *blend;
 	int i, off, alpha_drop;
 	unsigned char *overlay_base;
-	uint32 c0, c1, c2;
+	uint32 c0, c1, c2, base_premulti;
 
 
 	d_pipe = ctrl->stage[mixer][MDP4_MIXER_STAGE_BASE];
@@ -2261,6 +2314,8 @@
 	}
 
 	blend = &ctrl->blend[mixer][MDP4_MIXER_STAGE0];
+	base_premulti = ctrl->blend[mixer][MDP4_MIXER_STAGE_BASE].op &
+		MDP4_BLEND_FG_ALPHA_BG_CONST;	
 	for (i = MDP4_MIXER_STAGE0; i < MDP4_MIXER_STAGE_MAX; i++) {
 		blend->solidfill = 0;
 		blend->op = (MDP4_BLEND_FG_ALPHA_FG_CONST |
@@ -2282,18 +2337,20 @@
 			alpha_drop = 1;
 
 		d_pipe = mdp4_background_layer(mixer, s_pipe);
+
 		pr_debug("%s: stage=%d: bg: ndx=%d da=%d dalpha=%x "
 			"fg: ndx=%d sa=%d salpha=%x is_fg=%d alpha_drop=%d\n",
-		__func__, i-2, d_pipe->pipe_ndx, d_pipe->alpha_enable,
-		d_pipe->alpha, s_pipe->pipe_ndx, s_pipe->alpha_enable,
-		s_pipe->alpha, s_pipe->is_fg, alpha_drop);
-		if ((s_pipe->blend_op == BLEND_OP_NOT_DEFINED) ||
-			(s_pipe->blend_op >= BLEND_OP_MAX))
-			mdp4_set_blend_by_fmt(s_pipe, d_pipe,
-				alpha_drop, blend);
-		else
+			__func__, i-2, d_pipe->pipe_ndx, d_pipe->alpha_enable,	  
+			d_pipe->alpha, s_pipe->pipe_ndx, s_pipe->alpha_enable,	  
+			s_pipe->alpha, s_pipe->is_fg, alpha_drop);				  
+		if ((s_pipe->blend_op == BLEND_OP_NOT_DEFINED) ||		  
+			(s_pipe->blend_op >= BLEND_OP_MAX)) 					
+			mdp4_set_blend_by_fmt(s_pipe, d_pipe,					
+				alpha_drop, blend); 								  
+		else													  
 			mdp4_set_blend_by_op(s_pipe, d_pipe, alpha_drop, blend);
 
+
 		if (s_pipe->transp != MDP_TRANSP_NOP) {
 			if (s_pipe->is_fg) {
 				transp_color_key(s_pipe->src_format,
@@ -2466,7 +2523,8 @@
 	num = pipe->pipe_num;
 	ndx = pipe->pipe_ndx;
 	mixer = pipe->mixer_num;
-/* No need for borderfill pipe */
+
+	/* No need for borderfill pipe */
 	if (pipe->pipe_type != OVERLAY_TYPE_BF)
 		mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, all);
 
@@ -2842,12 +2900,11 @@
 		mfd->panel_info.xres;
 
 	/*
-	 * For the scaling cases, adding 20% margin
+	 * For the scaling cases, adding extra 20% margin
 	 */
 	if ((src_h != dst_h) || (src_w != dst_w)) {
 		hsync *= 100;
 		hsync /= 120;
-
 	}
 
 	if (!hsync) {
@@ -2899,7 +2956,7 @@
 	} else {		/* upscale */
 		yscale = dst_h;
 		yscale <<= shift;
-		yscale /= dst_h;
+		yscale /= src_h;
 	}
 
 	yscale *= src_w;
@@ -2923,8 +2980,8 @@
 	 * required(FIR).
 	 */
 	if ((mfd->panel_info.lcdc.v_back_porch <= 4) &&
-		(src_h != dst_h) &&
-		(mfd->panel_info.lcdc.v_back_porch)) {
+	    (src_h != dst_h) &&
+	    (mfd->panel_info.lcdc.v_back_porch)) {
 		u32 clk = 0;
 		clk = 4 * (pclk >> shift) / mfd->panel_info.lcdc.v_back_porch;
 		clk <<= shift;
@@ -2947,14 +3004,12 @@
 	pr_debug("%s: required mdp clk %d\n", __func__, (u32)rst);
 
 	return (u32)rst;
-
 }
 
 static int mdp4_calc_req_blt(struct msm_fb_data_type *mfd,
 			     struct mdp_overlay *req)
 {
 	int ret = 0;
-	int clk = 0;
 
 	if (!req) {
 		pr_err("%s: req is null!\n", __func__);
@@ -2966,12 +3021,10 @@
 		return ret;
 	}
 
-	clk = mdp4_calc_req_mdp_clk(mfd, req->src_rect.h, req->dst_rect.h,
-		 req->src_rect.w, req->dst_rect.w);
-	if (clk > mdp_max_clk) {
-		pr_err("%s: clk requested=%d > max=%d", __func__, clk, mdp_max_clk);
+	if (mdp4_calc_req_mdp_clk
+		(mfd, req->src_rect.h, req->dst_rect.h,
+		 req->src_rect.w, req->dst_rect.w) > mdp_max_clk)
 		ret = -EINVAL;
-	}
 
 	return ret;
 }
@@ -3049,18 +3102,20 @@
 	
 	quota >>= shift;
 	/* factor 1.15 for ab */
-    quota = quota * mdp_bw_ab_factor / 100;
-	/* downscaling factor for ab */
+	pipe->bw_ab_quota = quota * MDP4_BW_AB_FACTOR / 100;
+	/* factor 1.25 for ib */
+	pipe->bw_ib_quota = quota * MDP4_BW_IB_FACTOR / 100;
+	/* down scaling factor for ib */
 	if ((pipe->dst_h) && (pipe->src_h) &&
 	    (pipe->src_h > pipe->dst_h)) {
-		quota = quota * pipe->src_h / pipe->dst_h;
-		pr_debug("%s: src_h=%d dst_h=%d mdp ab %llu\n",
-			__func__, pipe->src_h, pipe->dst_h, ((u64)quota << 16));
+		u32 ib = quota; 
+		ib *= pipe->src_h;
+		ib /= pipe->dst_h;
+		pipe->bw_ib_quota = max((u64)ib, pipe->bw_ib_quota); 
+		pr_debug("%s: src_h=%d dst_h=%d mdp ib %u, ib_quota=%llu\n", 
+			 __func__, pipe->src_h, pipe->dst_h,
+			 ib<<shift, pipe->bw_ib_quota<<shift);
 	}
-	pipe->bw_ab_quota = quota;
-
-	/* factor 1.5 for ib */
-	pipe->bw_ib_quota = quota * mdp_bw_ib_factor / 100;
 
 	pipe->bw_ab_quota <<= shift;
 	pipe->bw_ib_quota <<= shift;
@@ -3091,7 +3146,7 @@
 		pr_err("%s: mfd is null!\n", __func__);
 		return ret;
 	}
-	mutex_lock(&perf_mutex);
+
 	bpp = BLT_BPP;
 	fps = mdp_get_panel_framerate(mfd);
 
@@ -3100,10 +3155,10 @@
 	quota >>= shift;
 
 	perf_req->mdp_ov_ab_bw[pipe->mixer_num] =
-		quota * mdp_bw_ab_factor / 100;
+		quota * MDP4_BW_AB_FACTOR / 100;
 
 	perf_req->mdp_ov_ib_bw[pipe->mixer_num] =
-		quota * mdp_bw_ib_factor / 100;
+		quota * MDP4_BW_IB_FACTOR / 100;
 
 	perf_req->mdp_ov_ab_bw[pipe->mixer_num] <<= shift;
 	perf_req->mdp_ov_ib_bw[pipe->mixer_num] <<= shift;
@@ -3116,7 +3171,6 @@
 		 perf_req->mdp_ov_ab_bw[pipe->mixer_num],
 		 perf_req->mdp_ov_ib_bw[pipe->mixer_num]);
 
-	mutex_unlock(&perf_mutex);
 	return 0;
 }
 static int mdp4_axi_port_read_client_pipe(struct mdp4_overlay_pipe *pipe)
@@ -3176,42 +3230,44 @@
 	return port;
 }
 
-int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd)
+int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
+			      struct mdp4_overlay_pipe *plist)
 {
 	u32 worst_mdp_clk = 0;
 	int i;
 	struct mdp4_overlay_perf *perf_req = &perf_request;
-	struct mdp4_overlay_pipe *pipe;
+	struct mdp4_overlay_pipe *pipe = plist;
 	int verysmallarea =0;
 	int yuvcount =0;
 	int src_h_total = 0;
 	int src_w_total = 0;
-
-    u32 cnt = 0;
-
-	int ret = -EINVAL;
-	u64 ab_quota_total = 0, ib_quota_total = 0;
+	static u64 minimum_ab=0;
+	static u64 minimum_ib=0;
+	
 	u64 ab_quota_port0 = 0, ib_quota_port0 = 0;
 	u64 ab_quota_port1 = 0, ib_quota_port1 = 0;
-	u64 ib_quota_min = 0;
+	
+	u32 cnt = 0;
+	int ret = -EINVAL;
+	u64 ab_quota_total = 0, ib_quota_total = 0;
 
 	if (!mfd) {
 		pr_err("%s: mfd is null!\n", __func__);
 		return ret;
 	}
 
-	mutex_lock(&perf_mutex);
-	pipe = ctrl->plist;
+	if (!plist) {
+		pr_err("%s: plist is null!\n", __func__);
+		return ret;
+	}
 
 	for (i = 0; i < MDP4_MIXER_MAX; i++)
 		perf_req->use_ov_blt[i] = 0;
 
 	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
 
-		if (!pipe) {
-			mutex_unlock(&perf_mutex);
+		if (!pipe)
 			return ret;
-		}
 
 		if (!pipe->pipe_used)
 			continue;
@@ -3229,18 +3285,13 @@
 			ab_quota_total += pipe->bw_ab_quota;
 			ib_quota_total += pipe->bw_ib_quota;
 			if (mdp4_axi_port_read_client_pipe(pipe)) {
-				ab_quota_port1 += pipe->bw_ab_quota;
-				ib_quota_port1 += pipe->bw_ib_quota;
-			} else {
-				ab_quota_port0 += pipe->bw_ab_quota;
-				ib_quota_port0 += pipe->bw_ib_quota;
-			}
-		} else {
-			if (ib_quota_min == 0)
-				ib_quota_min = pipe->bw_ib_quota;
-			else
-				ib_quota_min = min(ib_quota_min,
-						   pipe->bw_ib_quota);
+                   ab_quota_port1 += pipe->bw_ab_quota;
+                   ib_quota_port1 += pipe->bw_ib_quota;
+           } else {
+                   ab_quota_port0 += pipe->bw_ab_quota;
+                   ib_quota_port0 += pipe->bw_ib_quota;
+           }
+ 
 		}
 
 		if(pipe->pipe_type == OVERLAY_TYPE_RGB){
@@ -3304,8 +3355,56 @@
 			}
 		}
 	}
+	
+	if(minimum_ab == 0 ||minimum_ib == 0){
+		minimum_ab = (1920*1080*4*60)>>16;
+		minimum_ab = (minimum_ab*MDP4_BW_AB_FACTOR/100)<<16;
+		minimum_ib = (1920*1080*4*60)>>16;
+		minimum_ib = (minimum_ib*MDP4_BW_IB_FACTOR/100)<<16;
+	}
 
-	ib_quota_total = max(ib_quota_total, ib_quota_min);
+	/*
+	 * For small video + small rgb layers above them
+	 * offset some bw
+	 */
+	if((cnt>=3)&&(ab_quota_total<minimum_ab)&&yuvcount==1){
+		if((verysmallarea+yuvcount)==(cnt-1)){
+			ab_quota_total +=MDP_BUS_SCALE_AB_STEP;
+			ib_quota_total +=MDP_BUS_SCALE_AB_STEP;
+			ab_quota_port1 +=MDP_BUS_SCALE_AB_STEP;				
+			ib_quota_port1 +=MDP_BUS_SCALE_AB_STEP;
+			ab_quota_port0 +=MDP_BUS_SCALE_AB_STEP;
+			ib_quota_port0 +=MDP_BUS_SCALE_AB_STEP;					
+		}
+		else{
+			ab_quota_total= minimum_ab;
+			ib_quota_total= minimum_ib;
+			ab_quota_port1 = minimum_ab >> 1;				
+			ib_quota_port1 = minimum_ib >> 1;
+			ab_quota_port0 = minimum_ab >> 1;
+			ib_quota_port0 = minimum_ib >> 1;
+		}
+	}
+
+	/*
+	 * For Small RGB layers without video layer offset some
+	 * bandwidth to prevent underruns
+	 */
+	if((cnt>=2) && (src_h_total * src_w_total < 1920*1080) 
+			&& (ab_quota_total<minimum_ab) && yuvcount == 0) {
+		u64 bw_extra =  (minimum_ab - ab_quota_total) >>  1 ;
+		int fact = ((int) (bw_extra>>16))/((int)(ab_quota_total>>16));
+
+		/* Do not increase bw for layers which require more than 3 folds */
+		if(fact <= 3 ) {
+			ab_quota_total += bw_extra;
+			ib_quota_total += bw_extra;
+			ab_quota_port1 += bw_extra >> 1;				
+			ib_quota_port1 += bw_extra >> 1;
+			ab_quota_port0 += bw_extra >> 1;
+			ib_quota_port0 += bw_extra >> 1;
+		} 
+	}
 
 	perf_req->mdp_ab_bw = roundup(ab_quota_total, MDP_BUS_SCALE_AB_STEP);
 	perf_req->mdp_ib_bw = roundup(ib_quota_total, MDP_BUS_SCALE_AB_STEP);
@@ -3319,20 +3418,20 @@
 	perf_req->mdp_ib_port1_bw =
 		roundup(ib_quota_total, MDP_BUS_SCALE_AB_STEP);
 
-
 	pr_debug("%s %d: ab_quota_total=(%llu, %llu) ib_quota_total=(%llu, %llu)\n",
 		 __func__, __LINE__,
 		 ab_quota_total, perf_req->mdp_ab_bw,
 		 ib_quota_total, perf_req->mdp_ib_bw);
+
 	pr_debug("%s %d: ab_quota_port0=(%llu, %llu) ib_quota_port0=(%llu, %llu)\n",
-			 __func__, __LINE__,
-			 ab_quota_port0, perf_req->mdp_ab_port0_bw,
-			 ib_quota_port0, perf_req->mdp_ib_port0_bw);
+		 __func__, __LINE__,
+		 ab_quota_port0, perf_req->mdp_ab_port0_bw,
+		 ib_quota_port0, perf_req->mdp_ib_port0_bw);
 
 	pr_debug("%s %d: ab_quota_port1=(%llu, %llu) ib_quota_port1=(%llu, %llu)\n",
-			 __func__, __LINE__,
-			 ab_quota_port1, perf_req->mdp_ab_port1_bw,
-			 ib_quota_port1, perf_req->mdp_ib_port1_bw);
+		 __func__, __LINE__,
+		 ab_quota_port1, perf_req->mdp_ab_port1_bw,
+		 ib_quota_port1, perf_req->mdp_ib_port1_bw);
 
 	if (ab_quota_total > mdp_max_bw)
 		pr_debug("%s: req ab bw=%llu is larger than max bw=%llu",
@@ -3347,7 +3446,6 @@
 		 perf_req->use_ov_blt[0],
 		 perf_req->use_ov_blt[1]);
 
-	mutex_unlock(&perf_mutex);
 	return 0;
 }
 
@@ -3381,7 +3479,6 @@
 		 perf_cur->mdp_clk_rate,
 		 flag);
 
-	mutex_lock(&perf_mutex);
 	if (!mdp4_extn_disp)
 		perf_cur->use_ov_blt[1] = 0;
 
@@ -3404,15 +3501,12 @@
 				 perf_req->mdp_ab_port1_bw,
 				 perf_req->mdp_ib_port1_bw);
 			pr_debug("%s mdp ab_bw is changed [%d] from %llu to %llu\n",
-
-                __func__,
+				__func__,
 				flag,
 				perf_cur->mdp_ab_bw,
 				perf_req->mdp_ab_bw);
 			pr_debug("%s mdp ib_bw is changed [%d] from %llu to %llu\n",
-
-                __func__,
-
+				__func__,
 				flag,
 				perf_cur->mdp_ib_bw,
 				perf_req->mdp_ib_bw);
@@ -3454,15 +3548,13 @@
 				 perf_req->mdp_ib_port0_bw,
 				 perf_req->mdp_ab_port1_bw,
 				 perf_req->mdp_ib_port1_bw);
-
 			pr_debug("%s mdp ab bw is changed [%d] from %llu to %llu\n",
 				__func__,
 				flag,
 				perf_cur->mdp_ab_bw,
 				perf_req->mdp_ab_bw);
 			pr_debug("%s mdp ib bw is changed [%d] from %llu to %llu\n",
-
-                __func__,
+				__func__,
 				flag,
 				perf_cur->mdp_ib_bw,
 				perf_req->mdp_ib_bw);
@@ -3487,8 +3579,6 @@
 			perf_cur->use_ov_blt[0] = perf_req->use_ov_blt[0];
 		}
 	}
-
-	mutex_unlock(&perf_mutex);
 	return;
 }
 
@@ -3660,7 +3750,7 @@
 		mdp4_calc_pipe_mdp_clk(mfd, pipe) == 0 &&
 		pipe->req_clk > mdp_max_clk)	{
 		if (req->id == MSMFB_NEW_REQUEST)
-			mdp4_overlay_pipe_free(pipe, 0);
+			mdp4_overlay_pipe_free(pipe, 1);//need_check
 		mutex_unlock(&mfd->dma->ov_mutex);
 		return -EINVAL;
 	}
@@ -3907,24 +3997,6 @@
 	* non double buffer register update here
 	* perf level, new clock rate should be done here
 	*/
-	struct mdp4_overlay_pipe *pipe;
-	char *vg_base;
-	int i, pnum;
-	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
-		pipe = ctrl->stage[mixer][i];
-		if (pipe) {
-			if (pipe->pipe_type == OVERLAY_TYPE_VIDEO &&
-						(pipe->frame_format !=
-						MDP4_FRAME_FORMAT_LINEAR) &&
-						pipe->frame_size) {
-				pnum = pipe->pipe_num - OVERLAY_PIPE_VG1;
-				vg_base = MDP_BASE + MDP4_VIDEO_BASE;
-				vg_base += (MDP4_VIDEO_OFF * pnum);
-				outpdw(vg_base + 0x0048, pipe->frame_size);
-				pipe->frame_size = 0;
-			}
-		}
-	}
 }
 
 /*
@@ -4083,7 +4155,7 @@
 		}
 	}
 
-	mdp4_overlay_mdp_perf_req(mfd);
+	mdp4_overlay_mdp_perf_req(mfd, ctrl->plist);
 
 	if (pipe->mixer_num == MDP4_MIXER0) {
 		if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
@@ -4113,29 +4185,27 @@
 
 int mdp4_overlay_commit(struct fb_info *info)
 {
-	int ret = 0, release_busy = true;
+	int ret = 0;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 	int mixer;
 
-	if (mfd == NULL) {
-		ret = -ENODEV;
-		goto mdp4_overlay_commit_exit;
-	}
+	if (mfd == NULL)
+		return -ENODEV;
 
-	if (!mfd->panel_power_on) {
-		ret = -EINVAL;
-		goto mdp4_overlay_commit_exit;
-	}
+	if (!mfd->panel_power_on) /* suspended */
+		return -EINVAL;
 
 	mixer = mfd->panel_info.pdest;	/* DISPLAY_1 or DISPLAY_2 */
 
 	mutex_lock(&mfd->dma->ov_mutex);
 
+	mdp4_overlay_mdp_perf_upd(mfd, 1);
+
 	msm_fb_wait_for_fence(mfd);
 
 	switch (mfd->panel.type) {
 	case MIPI_CMD_PANEL:
-		mdp4_dsi_cmd_pipe_commit(0, 1, &release_busy);
+		mdp4_dsi_cmd_pipe_commit(0, 1);
 		break;
 	case MIPI_VIDEO_PANEL:
 		mdp4_dsi_video_pipe_commit(0, 1);
@@ -4157,19 +4227,11 @@
 	}
 	msm_fb_signal_timeline(mfd);
 
+	mdp4_overlay_mdp_perf_upd(mfd, 0);
 	mdp4_unmap_sec_resource(mfd);
-	if (release_busy)
-		mutex_unlock(&mfd->dma->ov_mutex);
-mdp4_overlay_commit_exit:
-	if (release_busy)
-		msm_fb_release_busy(mfd);
-	return ret;
-}
+	mutex_unlock(&mfd->dma->ov_mutex);
 
-void mdp4_overlay_commit_finish(struct fb_info *info)
-{
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-	mdp4_overlay_mdp_perf_upd(mfd, 0);
+	return ret;
 }
 
 struct msm_iommu_ctx {
@@ -4390,6 +4452,25 @@
 }
 #endif
 
+int mdp4_update_base_blend(struct msm_fb_data_type *mfd,
+			struct mdp_blend_cfg *mdp_blend_cfg)
+{
+	int ret = 0;
+	u32 mixer_num;
+	struct blend_cfg *blend;
+	mixer_num = mdp4_get_mixer_num(mfd->panel_info.type);
+	if (!ctrl)
+		return -EPERM;
+	blend = &ctrl->blend[mixer_num][MDP4_MIXER_STAGE_BASE];
+	if (mdp_blend_cfg->is_premultiplied) {
+		blend->bg_alpha = 0xFF;
+		blend->op = MDP4_BLEND_FG_ALPHA_BG_CONST;
+	} else {
+		blend->op = MDP4_BLEND_FG_ALPHA_FG_PIXEL;
+		blend->bg_alpha = 0;
+	}
+	return ret;
+}
 int mdp4_overlay_reset()
 {
 #if 0
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_dsi_cmd.c msm/mdp4_overlay_dsi_cmd.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_dsi_cmd.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_overlay_dsi_cmd.c	2013-12-11 02:38:33.000000000 -0800
@@ -41,8 +41,6 @@
  */
 #define VSYNC_EXPIRE_TICK 4
 
-#define VSYNC_MIN_DIFF_MS 4
-
 static struct vsycn_ctrl {
 	struct device *dev;
 	int inited;
@@ -57,6 +55,7 @@
 	uint32 rdptr_intr_tot;
 	uint32 rdptr_sirq_tot;
 	atomic_t suspend;
+	int wait_vsync_cnt;
 	int blt_change;
 	int blt_free;
 	int blt_end;
@@ -64,17 +63,17 @@
 	struct mutex update_lock;
 	struct completion ov_comp;
 	struct completion dmap_comp;
+	struct completion vsync_comp;
 	spinlock_t spin_lock;
 	struct msm_fb_data_type *mfd;
 	struct mdp4_overlay_pipe *base_pipe;
 	struct vsync_update vlist[2];
 	int vsync_enabled;
 	int clk_enabled;
+	int new_update;
 	int clk_control;
 	ktime_t vsync_time;
-	u32 last_vsync_ms;
 	struct work_struct clk_work;
-	wait_queue_head_t wait_queue;
 } vsync_ctrl_db[MAX_CONTROLLER];
 
 static void vsync_irq_enable(int intr, int term)
@@ -156,7 +155,7 @@
 	int cndx = 0;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
-	int need_wait = 0;
+	int need_wait;
 
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
@@ -269,7 +268,7 @@
 static void mdp4_dsi_cmd_blt_ov_update(struct mdp4_overlay_pipe *pipe);
 static int mdp4_dsi_cmd_clk_check(struct vsycn_ctrl *vctrl);
 
-int mdp4_dsi_cmd_pipe_commit(int cndx, int wait, u32 *release_busy)
+int mdp4_dsi_cmd_pipe_commit(int cndx, int wait)
 {
 	int  i, undx;
 	int mixer = 0;
@@ -288,12 +287,6 @@
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
-	if (pipe == NULL) {
-		pr_err("%s: NO base pipe\n", __func__);
-		mutex_unlock(&vctrl->update_lock);
-		return 0;
-	}
-
 	mixer = pipe->mixer_num;
 
         mdp_update_pm(vctrl->mfd, vctrl->vsync_time);
@@ -312,13 +305,10 @@
 		if (vctrl->blt_free == 0)
 			mdp4_free_writeback_buf(vctrl->mfd, mixer);
 	}
+	mutex_unlock(&vctrl->update_lock);
 
-	if (mdp4_dsi_cmd_clk_check(vctrl) < 0) {
-		mdp4_dsi_cmd_pipe_clean(vp);
-		mutex_unlock(&vctrl->update_lock);
+	if (mdp4_dsi_cmd_clk_check(vctrl) < 0)
 		return 0;
-	}
-	mutex_unlock(&vctrl->update_lock);
 
 	/* free previous committed iommu back to pool */
 	mdp4_overlay_iommu_unmap_freelist(mixer);
@@ -326,10 +316,8 @@
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
 		/* Blt */
-		if (vctrl->blt_wait) {
-			INIT_COMPLETION(vctrl->dmap_comp);
+		if (vctrl->blt_wait)
 			need_dmap_wait = 1;
-		}
 		if (vctrl->ov_koff != vctrl->ov_done) {
 			INIT_COMPLETION(vctrl->ov_comp);
 			need_ov_wait = 1;
@@ -409,23 +397,14 @@
 	pr_debug("%s: kickoff, pid=%d\n", __func__, current->pid);
 	/* kickoff overlay engine */
 	mdp4_stat.kickoff_ov0++;
-	mdp_pipe_kickoff_simplified(MDP_OVERLAY0_TERM);
+	outpdw(MDP_BASE + 0x0004, 0);
 	mb(); /* make sure kickoff ececuted */
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
 	mdp4_stat.overlay_commit[pipe->mixer_num]++;
-
-	if (wait) {
-		if (release_busy) {
-			msm_fb_release_busy(vctrl->mfd);
-			*release_busy = false;
-			mutex_unlock(&vctrl->mfd->dma->ov_mutex);
-		}
-		if (pipe->ov_blt_addr)
-			mdp4_dsi_cmd_wait4ov(0);
-		else
-			mdp4_dsi_cmd_wait4dmap(0);
-	}
+	if (wait)
+		mdp4_dsi_cmd_wait4vsync(0);
+	
 
 	return cnt;
 }
@@ -462,9 +441,8 @@
 			mipi_dsi_clk_cfg(1);
 			mdp_clk_ctrl(1);
 			vctrl->clk_enabled = 1;
+			vctrl->new_update = 1;
 			clk_set_on = 1;
-			vctrl->last_vsync_ms =
-				ktime_to_ms(ktime_get()) - VSYNC_MIN_DIFF_MS;
 		}
 		if (clk_set_on) {
 			vsync_irq_enable(INTR_PRIMARY_RDPTR,
@@ -482,6 +460,7 @@
 {
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
+	unsigned long flags;
 
 	if (cndx >= MAX_CONTROLLER) {
 		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
@@ -494,9 +473,13 @@
 	if (atomic_read(&vctrl->suspend) > 0)
 		return;
 
-	wait_event_interruptible_timeout(vctrl->wait_queue, 1,
-			msecs_to_jiffies(VSYNC_PERIOD * 8));
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	if (vctrl->wait_vsync_cnt == 0)
+		INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
+	wait_for_completion(&vctrl->vsync_comp);
 	mdp4_stat.wait4vsync0++;
 }
 
@@ -542,8 +525,7 @@
 static void primary_rdptr_isr(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
-	u32 cur_vsync_ms;
-	int vsync_diff;
+
 	vctrl = &vsync_ctrl_db[cndx];
 	pr_debug("%s: ISR, tick=%d pan=%d cpu=%d\n", __func__,
 		vctrl->expire_tick, vctrl->pan_display, smp_processor_id());
@@ -551,16 +533,15 @@
 
 	spin_lock(&vctrl->spin_lock);
 	vctrl->vsync_time = ktime_get();
-	cur_vsync_ms =  ktime_to_ms(vctrl->vsync_time);
-	vsync_diff = (int)(cur_vsync_ms - vctrl->last_vsync_ms);
 
-	if ((vsync_diff >= 0) && (vsync_diff < VSYNC_MIN_DIFF_MS)) {
+	if (vctrl->new_update) {
+		vctrl->new_update = 0;
 		spin_unlock(&vctrl->spin_lock);
 		return;
 	}
 
-	vctrl->last_vsync_ms = cur_vsync_ms;
-	wake_up_interruptible_all(&vctrl->wait_queue);
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
 
 	if (vctrl->expire_tick) {
 		vctrl->expire_tick--;
@@ -582,6 +563,7 @@
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
 	int diff;
+
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
@@ -695,23 +677,34 @@
 	int cndx;
 	struct vsycn_ctrl *vctrl;
 	ssize_t ret = 0;
+	unsigned long flags;
 	u64 vsync_tick;
-	ktime_t timestamp;
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
-	timestamp = vctrl->vsync_time;
 
 	sec_debug_mdp_set_value(SEC_DEBUG_VSYNC_SYSFS_EVENT, SEC_DEBUG_IN);
+	if (atomic_read(&vctrl->suspend) > 0)
+		return 0;
 
-	ret = wait_event_interruptible(vctrl->wait_queue,
-			!ktime_equal(timestamp, vctrl->vsync_time) &&
-			vctrl->vsync_enabled);
-	if (ret == -ERESTARTSYS)
-		return ret;
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	if (vctrl->wait_vsync_cnt == 0)
+		INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 4));
+	if (ret <= 0) {
+		vctrl->wait_vsync_cnt = 0;
+		vctrl->vsync_time = ktime_get();
+	}
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	vsync_tick = ktime_to_ns(vctrl->vsync_time);
-	ret = scnprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
 	buf[strlen(buf) + 1] = '\0';
 	sec_debug_mdp_set_value(SEC_DEBUG_VSYNC_SYSFS_EVENT, SEC_DEBUG_OUT);
 	return ret;
@@ -735,8 +728,8 @@
 	mutex_init(&vctrl->update_lock);
 	init_completion(&vctrl->ov_comp);
 	init_completion(&vctrl->dmap_comp);
+	init_completion(&vctrl->vsync_comp);
 	spin_lock_init(&vctrl->spin_lock);
-	init_waitqueue_head(&vctrl->wait_queue);
 	atomic_set(&vctrl->suspend, 1);
 	INIT_WORK(&vctrl->clk_work, clk_ctrl_work);
 }
@@ -764,60 +757,32 @@
 void mdp4_mipi_vsync_enable(struct msm_fb_data_type *mfd,
 		struct mdp4_overlay_pipe *pipe, int which)
 {
-	uint32 data, tear_en;
+	uint32 start_y, data, tear_en;
 
 	tear_en = (1 << which);
 
-	mdp_clk_ctrl(1);
-
-	data = inpdw(MDP_BASE + 0x20c);
 	if ((mfd->use_mdp_vsync) && (mfd->ibuf.vsync_enable) &&
-	    (mfd->panel_info.lcd.vsync_enable)) {
-		data |= tear_en;
-		/*
-		 * rdptr init and irq cannot be same due to h/w bug.
-		 * if they are same, rdptr irqs could be missed.
-		 */
-		if (mfd->panel_info.lcd.primary_vsync_init ||
-			mfd->panel_info.lcd.primary_rdptr_irq) {
-			MDP_OUTP(MDP_BASE + 0x128,
-				mfd->panel_info.lcd.primary_vsync_init);
-			MDP_OUTP(MDP_BASE + 0x21C,
-				mfd->panel_info.lcd.primary_rdptr_irq);
-		} else {
-			MDP_OUTP(MDP_BASE + 0x128, 0);
-			MDP_OUTP(MDP_BASE + 0x21C, 1);
-		}
+		(mfd->panel_info.lcd.vsync_enable)) {
 
-		/*
-		 * adjust start position and threshold to make sure
-		 * write ptr follows read pts (TE is effective), and
-		 * at the same write is not throttled(shorter dmap
-		 * time)
-		 */
-		if (mfd->panel_info.lcd.primary_start_pos)
-			MDP_OUTP(MDP_BASE + 0x210,
-				mfd->panel_info.lcd.primary_start_pos);
+		if (vsync_start_y_adjust <= pipe->dst_y)
+			start_y = pipe->dst_y - vsync_start_y_adjust;
 		else
-			MDP_OUTP(MDP_BASE + 0x210,
-				 mfd->panel_info.lcd.v_back_porch +
-				 mfd->panel_info.lcd.v_front_porch +
-				 vsync_start_y_adjust);
-
-		if (mfd->panel_info.lcd.vsync_threshold_continue &&
-				mfd->panel_info.lcd.vsync_threshold_start)
-			MDP_OUTP(MDP_BASE + 0x200,
-			 ((mfd->panel_info.lcd.vsync_threshold_continue << 16) |
-				mfd->panel_info.lcd.vsync_threshold_start));
+			start_y = (mfd->total_lcd_lines - 1) -
+				(vsync_start_y_adjust - pipe->dst_y);
+		if (which == 0)
+			MDP_OUTP(MDP_BASE + 0x210, start_y);	/* primary */
 		else
-			MDP_OUTP(MDP_BASE + 0x200,
-			 ((4 << 16) | mfd->panel_info.lcd.v_pulse_width));
-	} else
+			MDP_OUTP(MDP_BASE + 0x214, start_y);	/* secondary */
+
+		data = inpdw(MDP_BASE + 0x20c);
+		data |= tear_en;
+		MDP_OUTP(MDP_BASE + 0x20c, data);
+	} else {
+		data = inpdw(MDP_BASE + 0x20c);
 		data &= ~tear_en;
-	MDP_OUTP(MDP_BASE + 0x20c, data);
-	mdp_clk_ctrl(0);
+		MDP_OUTP(MDP_BASE + 0x20c, data);
+	}
 }
-
 void mdp4_dsi_cmd_free_base_pipe(struct msm_fb_data_type *mfd)
 {
 	struct vsycn_ctrl *vctrl;
@@ -933,9 +898,10 @@
 
 	/* TE enabled */
 	mdp4_mipi_vsync_enable(mfd, pipe, 0);
-
+	
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
 	mdp4_calc_blt_mdp_bw(mfd, pipe);
+	MDP_OUTP(MDP_BASE + 0x021c, 10); /* read pointer */
 
 	/*
 	 * configure dsi stream id
@@ -945,8 +911,6 @@
 	/* disable dsi trigger */
 	MDP_OUTP(MDP_BASE + 0x000a4, 0x00);
 
-	mdp4_overlay_solidfill_init(pipe);
-
 	mdp4_overlay_setup_pipe_addr(mfd, pipe);
 
 	mdp4_overlay_rgb_setup(pipe);
@@ -1072,12 +1036,9 @@
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 	mfd->cont_splash_done = 1;
 
-	mutex_lock(&mfd->dma->ov_mutex);
-
 	vctrl = &vsync_ctrl_db[cndx];
 	vctrl->mfd = mfd;
 	vctrl->dev = mfd->fbi->dev;
-	vctrl->vsync_enabled = 0;
 
 	mdp_clk_ctrl(1);
 	mdp4_overlay_update_dsi_cmd(mfd);
@@ -1087,8 +1048,6 @@
 
 	atomic_set(&vctrl->suspend, 0);
 
-	mutex_unlock(&mfd->dma->ov_mutex);
-
 	pr_debug("%s-:\n", __func__);
 
 	return ret;
@@ -1105,25 +1064,23 @@
 	int undx;
 	int need_wait, cnt;
 	unsigned long flags;
-	int mixer = 0;
 
 	pr_debug("%s+: pid=%d\n", __func__, current->pid);
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
-	mutex_lock(&mfd->dma->ov_mutex);
-
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 	if (pipe == NULL) {
 		pr_err("%s: NO base pipe\n", __func__);
-		mutex_unlock(&mfd->dma->ov_mutex);
 		return ret;
 	}
 
 	need_wait = 0;
 	mutex_lock(&vctrl->update_lock);
-	wake_up_interruptible_all(&vctrl->wait_queue);
+	atomic_set(&vctrl->suspend, 1);
+
+	complete_all(&vctrl->vsync_comp);
 
 	pr_debug("%s: clk=%d pan=%d\n", __func__,
 			vctrl->clk_enabled, vctrl->pan_display);
@@ -1152,6 +1109,14 @@
 		pr_err("%s: Error, SET_CLK_OFF by force\n", __func__);
 	}
 
+	/* sanity check, free pipes besides base layer */
+	mdp4_overlay_unset_mixer(pipe->mixer_num);
+	mdp4_mixer_stage_down(pipe, 1);
+	if (mfd->ref_cnt == 0) {
+		mdp4_overlay_pipe_free(pipe, 1);
+		vctrl->base_pipe = NULL;
+	}
+
 	if (vctrl->vsync_enabled) {
 		vsync_irq_disable(INTR_PRIMARY_RDPTR, MDP_PRIM_RDPTR_TERM);
 		vctrl->vsync_enabled = 0;
@@ -1168,41 +1133,33 @@
 		mdp4_dsi_cmd_pipe_clean(vp);
 	}
 
+	pr_debug("%s-:\n", __func__);
+	return ret;
+}
+
+void mdp_dsi_cmd_overlay_suspend(struct msm_fb_data_type *mfd)
+{
+	int cndx = 0;
+	struct vsycn_ctrl *vctrl;
+	struct mdp4_overlay_pipe *pipe;
+
+	vctrl = &vsync_ctrl_db[cndx];
+	pipe = vctrl->base_pipe;
+	/* dis-engage rgb0 from mixer0 */
 	if (pipe) {
-		/* sanity check, free pipes besides base layer */
-		mixer = pipe->mixer_num;
-		mdp4_overlay_unset_mixer(mixer);
 		if (mfd->ref_cnt == 0) {
 			/* adb stop */
 			if (pipe->pipe_type == OVERLAY_TYPE_BF)
 				mdp4_overlay_borderfill_stage_down(pipe);
 
-			/* base pipe may change after borderfill_stage_down */
-			pipe = vctrl->base_pipe;
-			mdp4_mixer_stage_down(pipe, 1);
-			mdp4_overlay_pipe_free(pipe, 1);
+			/* pipe == rgb1 */
+			mdp4_overlay_unset_mixer(pipe->mixer_num);
 			vctrl->base_pipe = NULL;
 		} else {
-			/* system suspending */
 			mdp4_mixer_stage_down(pipe, 1);
 			mdp4_overlay_iommu_pipe_free(pipe->pipe_ndx, 1);
 		}
 	}
-
-	atomic_set(&vctrl->suspend, 1);
-
-	/*
-	 * clean up ion freelist
-	 * there need two stage to empty ion free list
-	 * therefore need call unmap freelist twice
-	 */
-	mdp4_overlay_iommu_unmap_freelist(mixer);
-	mdp4_overlay_iommu_unmap_freelist(mixer);
-
-	mutex_unlock(&mfd->dma->ov_mutex);
-
-	pr_debug("%s-:\n", __func__);
-	return ret;
 }
 
 static int mdp4_dsi_cmd_clk_check(struct vsycn_ctrl *vctrl)
@@ -1210,7 +1167,9 @@
 	int clk_set_on = 0;
 	unsigned long flags;
 
+	mutex_lock(&vctrl->update_lock);
 	if (atomic_read(&vctrl->suspend)) {
+		mutex_unlock(&vctrl->update_lock);
 		pr_err("%s: suspended, no more pan display\n", __func__);
 		return -EPERM;
 	}
@@ -1232,6 +1191,8 @@
 		vsync_irq_enable(INTR_PRIMARY_RDPTR, MDP_PRIM_RDPTR_TERM);
 	}
 
+	mutex_unlock(&vctrl->update_lock);
+
 	return 0;
 }
 
@@ -1256,6 +1217,11 @@
 		return;
 	}
 
+	if (mdp4_dsi_cmd_clk_check(vctrl) < 0) {
+		mutex_unlock(&mfd->dma->ov_mutex);
+		return;
+	}
+
 	if (pipe->mixer_stage == MDP4_MIXER_STAGE_BASE) {
 		mdp4_mipi_vsync_enable(mfd, pipe, 0);
 		mdp4_overlay_setup_pipe_addr(mfd, pipe);
@@ -1263,8 +1229,8 @@
 	}
 
 	mdp4_overlay_mdp_perf_upd(mfd, 1);
-	mdp4_dsi_cmd_pipe_commit(cndx, 1, NULL);
+	mdp4_dsi_cmd_pipe_commit(cndx, 0);
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
 	mutex_unlock(&mfd->dma->ov_mutex);
 
-}
+}
\ No newline at end of file
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_dsi_video.c msm/mdp4_overlay_dsi_video.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_dsi_video.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_overlay_dsi_video.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -209,6 +209,7 @@
 	}
 	mutex_unlock(&vctrl->update_lock);
 
+
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->ov_koff != vctrl->ov_done) {
 		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
@@ -218,6 +219,18 @@
 	}
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
+	if (vctrl->blt_change) {
+		pipe = vctrl->base_pipe;
+		spin_lock_irqsave(&vctrl->spin_lock, flags);
+		INIT_COMPLETION(vctrl->dmap_comp);
+		INIT_COMPLETION(vctrl->ov_comp);
+		vsync_irq_enable(INTR_DMA_P_DONE, MDP_DMAP_TERM);
+		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+		mdp4_dsi_video_wait4dmap(0);
+		if (pipe->ov_blt_addr)
+			mdp4_dsi_video_wait4ov(0);
+	}
+
 	pipe = vp->plist;
 
 	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
@@ -230,16 +243,6 @@
 				 * and not be unset yet
 				 */
 				mdp4_overlay_vsync_commit(pipe);
-				if (pipe->frame_format !=
-						MDP4_FRAME_FORMAT_LINEAR) {
-					spin_lock_irqsave(&vctrl->spin_lock,
-									flags);
-					INIT_COMPLETION(vctrl->dmap_comp);
-					vsync_irq_enable(INTR_DMA_P_DONE,
-								MDP_DMAP_TERM);
-				       spin_unlock_irqrestore(&vctrl->spin_lock,
-								flags);
-				}
 			}
  		}
 	}
@@ -277,7 +280,8 @@
 		pipe->pipe_used = 0; /* clear */
 		}
 	}
-    pipe = vctrl->base_pipe;
+
+	pipe = vctrl->base_pipe;
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
 		mdp4_dsi_video_blt_ov_update(pipe);
@@ -474,9 +478,10 @@
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
-	timestamp = vctrl->vsync_time;
 
 	sec_debug_mdp_set_value(SEC_DEBUG_VSYNC_SYSFS_EVENT, SEC_DEBUG_IN);
+	timestamp = vctrl->vsync_time;
+
 	ret = wait_event_interruptible(vctrl->wait_queue,
 			!ktime_equal(timestamp, vctrl->vsync_time) &&
 			vctrl->vsync_irq_enabled);
@@ -661,7 +666,8 @@
 
 	if (!(mfd->cont_splash_done)) {
 		mfd->cont_splash_done = 1;
-		mdp4_dsi_video_tg_off(vctrl);
+		mdp4_dsi_video_wait4vsync(0);
+		MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
 		mipi_dsi_controller_cfg(0);
 		/* Clks are enabled in probe.
 		   Disabling clocks now */
@@ -805,9 +811,6 @@
 
 	mdp4_dsi_video_wait4vsync(cndx);
 
-	if (pipe == NULL)
-		return -EINVAL;
-		
 	if (pipe->ov_blt_addr) {
 		spin_lock_irqsave(&vctrl->spin_lock, flags);
 		if (vctrl->ov_koff != vctrl->ov_done)
@@ -819,6 +822,8 @@
 
 	mdp_histogram_ctrl_all(FALSE);
 
+	mdp4_dsi_video_tg_off(vctrl);
+
 	dsi_video_enabled = 0;
 
 	undx =  vctrl->update_ndx;
@@ -846,6 +851,7 @@
 			mdp4_mixer_stage_down(pipe, 1);
 			mdp4_overlay_pipe_free(pipe, 1);
 			vctrl->base_pipe = NULL;
+			msleep(20);
 		} else {
 			/* system suspending */
 			mdp4_mixer_stage_down(vctrl->base_pipe, 1);
@@ -854,10 +860,7 @@
 		}
 	}
 
-	mdp4_dsi_video_tg_off(vctrl);
-
 	atomic_set(&vctrl->suspend, 1);
-
 	if (vctrl->vsync_irq_enabled) {
 		vctrl->vsync_irq_enabled = 0;
 		mdp4_video_vsync_irq_ctrl(cndx, 0);
@@ -1032,6 +1035,7 @@
 	int cndx;
 	struct vsycn_ctrl *vctrl;
 
+
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[cndx];
 	pr_debug("%s: cpu=%d\n", __func__, smp_processor_id());
@@ -1068,6 +1072,17 @@
 	if (vctrl->blt_change) {
 		mdp4_overlayproc_cfg(pipe);
 		mdp4_overlay_dmap_xy(pipe);
+		if (pipe->ov_blt_addr) {
+			mdp4_dsi_video_blt_ov_update(pipe);
+			pipe->ov_cnt++;
+			/* Prefill one frame */
+			vsync_irq_enable(INTR_OVERLAY0_DONE,
+						MDP_OVERLAY0_TERM);
+			/* kickoff overlay0 engine */
+			mdp4_stat.kickoff_ov0++;
+			vctrl->ov_koff++;	/* make up for prefill */
+			outpdw(MDP_BASE + 0x0004, 0);
+		}
 		vctrl->blt_change = 0;
 	}
 
@@ -1168,17 +1183,6 @@
 		}
 		mdp4_overlayproc_cfg(pipe);
 		mdp4_overlay_dmap_xy(pipe);
-		if (pipe->ov_blt_addr) {
-			mdp4_dsi_video_blt_ov_update(pipe);
-			pipe->ov_cnt++;
-			/* Prefill one frame */
-			vsync_irq_enable(INTR_OVERLAY0_DONE,
-						MDP_OVERLAY0_TERM);
-			/* kickoff overlay0 engine */
-			mdp4_stat.kickoff_ov0++;
-			vctrl->ov_koff++;	/* make up for prefill */
-			outpdw(MDP_BASE + 0x0004, 0);
-		}
 		if (tg_enabled) {
 			/*
 			 * need wait for more than 1 ms to
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_dtv.c msm/mdp4_overlay_dtv.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_dtv.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_overlay_dtv.c	2013-12-11 02:38:33.000000000 -0800
@@ -31,7 +31,6 @@
 #include "msm_fb.h"
 #include "hdmi_msm.h"
 #include "mdp4.h"
-#include "hdmi_msm.h"
 
 #define DTV_BASE	0xD0000
 
@@ -280,7 +279,6 @@
 			pipe->pipe_used = 0; /* clear */
 		}
 	}
-
 	pipe = vctrl->base_pipe;
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
@@ -350,6 +348,7 @@
 	vctrl->vsync_irq_enabled = enable;
 
 	mdp4_dtv_vsync_irq_ctrl(cndx, enable);
+
 }
 
 void mdp4_dtv_wait4vsync(int cndx)
@@ -378,7 +377,6 @@
 
 	mdp4_dtv_vsync_irq_ctrl(cndx, 0);
 	mdp4_stat.wait4vsync1++;
-	
 }
 
 static void mdp4_dtv_wait4dmae(int cndx)
@@ -422,7 +420,6 @@
 	buf[strlen(buf) + 1] = '\0';
 	return ret;
 }
-
 void mdp4_dtv_vsync_init(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
@@ -848,8 +845,8 @@
 
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
 	mdp4_calc_blt_mdp_bw(mfd, pipe);
-	mdp4_overlay_mdp_perf_req(mfd);
-	mdp4_overlay_mdp_perf_upd(mfd, 1);
+//	mdp4_overlay_mdp_perf_req(mfd, pipe);//need_check
+//	mdp4_overlay_mdp_perf_upd(mfd, 1);
 
 	ret = mdp4_overlay_format2pipe(pipe);
 	if (ret < 0)
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_lcdc.c msm/mdp4_overlay_lcdc.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_lcdc.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_overlay_lcdc.c	2013-12-11 02:38:33.000000000 -0800
@@ -53,19 +53,21 @@
 	int ov_koff;
 	int ov_done;
 	atomic_t suspend;
+	atomic_t vsync_resume;
+	int wait_vsync_cnt;
 	int blt_change;
 	int blt_free;
 	int sysfs_created;
 	struct mutex update_lock;
 	struct completion ov_comp;
 	struct completion dmap_comp;
+	struct completion vsync_comp;
 	spinlock_t spin_lock;
 	struct msm_fb_data_type *mfd;
 	struct mdp4_overlay_pipe *base_pipe;
 	struct vsync_update vlist[2];
 	int vsync_irq_enabled;
 	ktime_t vsync_time;
-	wait_queue_head_t wait_queue;
 } vsync_ctrl_db[MAX_CONTROLLER];
 
 
@@ -183,11 +185,6 @@
 	undx =  vctrl->update_ndx;
 	vp = &vctrl->vlist[undx];
 	pipe = vctrl->base_pipe;
-	if (pipe == NULL) {
-		pr_err("%s: NO base pipe\n", __func__);
-		mutex_unlock(&vctrl->update_lock);
-		return 0;
-	}
 	mixer = pipe->mixer_num;
 
         mdp_update_pm(vctrl->mfd, vctrl->vsync_time);
@@ -208,6 +205,9 @@
 	}
 	mutex_unlock(&vctrl->update_lock);
 
+	/* free previous committed iommu back to pool */
+	mdp4_overlay_iommu_unmap_freelist(mixer);
+
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (vctrl->ov_koff != vctrl->ov_done) {
 		spin_unlock_irqrestore(&vctrl->spin_lock, flags);
@@ -274,6 +274,7 @@
 		}
 	}
 
+
 	pipe = vctrl->base_pipe;
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	if (pipe->ov_blt_addr) {
@@ -345,12 +346,16 @@
 	
 	mdp4_lcdc_vsync_irq_ctrl(cndx, enable);
 
+
+	if (vctrl->vsync_irq_enabled &&  atomic_read(&vctrl->suspend) == 0)
+		atomic_set(&vctrl->vsync_resume, 1);
 }
 
 void mdp4_lcdc_wait4vsync(int cndx)
 {
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
+	unsigned long flags;
 
 	if (cndx >= MAX_CONTROLLER) {
 		pr_err("%s: out or range: cndx=%d\n", __func__, cndx);
@@ -363,11 +368,19 @@
 	if (atomic_read(&vctrl->suspend) > 0)
 		return;
 
+	/* start timing generator & mmu if they are not started yet */
+	mdp4_overlay_lcdc_start();
+	
 	mdp4_lcdc_vsync_irq_ctrl(cndx, 1);
+	
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
 
-	wait_event_interruptible_timeout(vctrl->wait_queue, 1,
-			msecs_to_jiffies(VSYNC_PERIOD * 8));
+	if (vctrl->wait_vsync_cnt == 0)
+		INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
+	wait_for_completion(&vctrl->vsync_comp);
 	mdp4_lcdc_vsync_irq_ctrl(cndx, 0);
 	mdp4_stat.wait4vsync0++;
 }
@@ -412,21 +425,58 @@
 	int cndx;
 	struct vsycn_ctrl *vctrl;
 	ssize_t ret = 0;
+	unsigned long flags;
 	u64 vsync_tick;
-	ktime_t timestamp;
+	ktime_t ctime;
+	u32 ctick, ptick;
+	int diff;
 
 	cndx = 0;
 	vctrl = &vsync_ctrl_db[0];
-	timestamp = vctrl->vsync_time;
 
-	ret = wait_event_interruptible(vctrl->wait_queue,
-			!ktime_equal(timestamp, vctrl->vsync_time) &&
-			vctrl->vsync_irq_enabled);
-	if (ret == -ERESTARTSYS)
-		return ret;
+	if (atomic_read(&vctrl->suspend) > 0 ||
+		atomic_read(&vctrl->vsync_resume) == 0)
+		return 0;
+	/*
+	 * show_event thread keep spinning on vctrl->vsync_comp
+	 * race condition on x.done if multiple thread blocked
+	 * at wait_for_completion(&vctrl->vsync_comp)
+	 *
+	 * if show_event thread waked up first then it will come back
+	 * and call INIT_COMPLETION(vctrl->vsync_comp) which set x.done = 0
+	 * then second thread wakeed up which set x.done = 0x7ffffffd
+	 * after that wait_for_completion will never wait.
+	 * To avoid this, force show_event thread to sleep 5 ms here
+	 * since it has full vsycn period (16.6 ms) to wait
+	 */
+	ctime = ktime_get();
+	ctick = (u32)ktime_to_us(ctime);
+	ptick = (u32)ktime_to_us(vctrl->vsync_time);
+	ptick += 5000;	/* 5ms */
+	diff = ptick - ctick;
+	if (diff > 0) {
+		if (diff > 1000) /* 1 ms */
+			diff = 1000;
+		usleep(diff);
+	}
 
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
+	if (vctrl->wait_vsync_cnt == 0)
+		INIT_COMPLETION(vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt++;
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+	ret = wait_for_completion_interruptible_timeout(&vctrl->vsync_comp,
+		msecs_to_jiffies(VSYNC_PERIOD * 4));
+	if (ret <= 0) {
+		vctrl->wait_vsync_cnt = 0;
+		vctrl->vsync_time = ktime_get();
+	}
+
+	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	vsync_tick = ktime_to_ns(vctrl->vsync_time);
-	ret = scnprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
+	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
+
+	ret = snprintf(buf, PAGE_SIZE, "VSYNC=%llu", vsync_tick);
 	buf[strlen(buf) + 1] = '\0';
 	return ret;
 }
@@ -449,13 +499,13 @@
 	vctrl->inited = 1;
 	vctrl->update_ndx = 0;
 	mutex_init(&vctrl->update_lock);
+	init_completion(&vctrl->vsync_comp);
 	init_completion(&vctrl->dmap_comp);
 	init_completion(&vctrl->ov_comp);
 	atomic_set(&vctrl->suspend, 1);
+	atomic_set(&vctrl->vsync_resume, 1);
 	spin_lock_init(&vctrl->spin_lock);
-	init_waitqueue_head(&vctrl->wait_queue);
 }
-
 void mdp4_lcdc_free_base_pipe(struct msm_fb_data_type *mfd)
 {
 	struct vsycn_ctrl *vctrl;
@@ -542,11 +592,8 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	mutex_lock(&mfd->dma->ov_mutex);
-
 	vctrl->mfd = mfd;
 	vctrl->dev = mfd->fbi->dev;
-	vctrl->vsync_irq_enabled = 0;
 
 	/* mdp clock on */
 	mdp_clk_ctrl(1);
@@ -601,8 +648,6 @@
 	pipe->srcp0_ystride = fbi->fix.line_length;
 	pipe->bpp = bpp;
 
-	mdp4_overlay_solidfill_init(pipe);
-
 	mdp4_overlay_mdp_pipe_req(pipe, mfd);
 	mdp4_calc_blt_mdp_bw(mfd, pipe);
 
@@ -615,7 +660,6 @@
 
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_up(pipe, 0);
-	mdp4_mixer_stage_commit(pipe->mixer_num);
 
 
 	/*
@@ -710,23 +754,10 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
 	mdp_histogram_ctrl_all(TRUE);
-	mdp4_overlay_lcdc_start();
-	mutex_unlock(&mfd->dma->ov_mutex);
 
 	return ret;
 }
 
-/* timing generator off */
-static void mdp4_lcdc_tg_off(struct vsycn_ctrl *vctrl)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vctrl->spin_lock, flags);
-	MDP_OUTP(MDP_BASE + LCDC_BASE, 0); /* turn off timing generator */
-	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
-
-	mdp4_lcdc_wait4vsync(0);
-}
 int mdp4_lcdc_off(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -737,18 +768,20 @@
 	struct vsync_update *vp;
 	unsigned long flags;
 	int undx, need_wait = 0;
-	int mixer = 0;
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
-
-	mutex_lock(&mfd->dma->ov_mutex);
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
-	mdp4_lcdc_wait4vsync(cndx);
+	atomic_set(&vctrl->suspend, 1);
+	atomic_set(&vctrl->vsync_resume, 0);
 
-	wake_up_interruptible_all(&vctrl->wait_queue);
+	msleep(20);	/* >= 17 ms */
 
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
+	if (pipe == NULL)
+		return -EINVAL;
 	if (pipe->ov_blt_addr) {
 		spin_lock_irqsave(&vctrl->spin_lock, flags);
 		if (vctrl->ov_koff != vctrl->ov_done)
@@ -760,6 +793,8 @@
 
 	mdp_histogram_ctrl_all(FALSE);
 
+	MDP_OUTP(MDP_BASE + LCDC_BASE, 0);
+
 	lcdc_enabled = 0;
 
 	undx =  vctrl->update_ndx;
@@ -775,8 +810,7 @@
 
 	if (pipe) {
 		/* sanity check, free pipes besides base layer */
-		mixer = pipe->mixer_num;
-		mdp4_overlay_unset_mixer(mixer);
+		mdp4_overlay_unset_mixer(pipe->mixer_num);
 		if (mfd->ref_cnt == 0) {
 			/* adb stop */
 			if (pipe->pipe_type == OVERLAY_TYPE_BF)
@@ -795,24 +829,10 @@
 		}
 	}
 
-	mdp4_lcdc_tg_off(vctrl);
-
-	atomic_set(&vctrl->suspend, 1);
-
-	/*
-	 * clean up ion freelist
-	 * there need two stage to empty ion free list
-	 * therefore need call unmap freelist twice
-	 */
-	mdp4_overlay_iommu_unmap_freelist(mixer);
-	mdp4_overlay_iommu_unmap_freelist(mixer);
-
 	/* MDP clock disable */
 	mdp_clk_ctrl(0);
 	mdp_pipe_ctrl(MDP_OVERLAY0_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
-	mutex_unlock(&mfd->dma->ov_mutex);
-
 	return ret;
 }
 
@@ -877,7 +897,9 @@
 
 	spin_lock(&vctrl->spin_lock);
 	vctrl->vsync_time = ktime_get();
-	wake_up_interruptible_all(&vctrl->wait_queue);
+
+	complete_all(&vctrl->vsync_comp);
+	vctrl->wait_vsync_cnt = 0;
 	spin_unlock(&vctrl->spin_lock);
 }
 
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_writeback.c msm/mdp4_overlay_writeback.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_overlay_writeback.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_overlay_writeback.c	2013-12-11 02:38:33.000000000 -0800
@@ -423,11 +423,13 @@
 		}
 	}
 
-	mdp_clk_ctrl(1);
-
 	mdp4_mixer_stage_commit(mixer);
 
 	pipe = vctrl->base_pipe;
+	if (!pipe->ov_blt_addr) {
+		schedule_work(&vctrl->clk_work);
+		return cnt;
+	}
 	spin_lock_irqsave(&vctrl->spin_lock, flags);
 	vctrl->ov_koff++;
 	INIT_COMPLETION(vctrl->ov_comp);
@@ -539,6 +541,7 @@
 	mdp4_overlay_mdp_perf_upd(mfd, 0);
 
 	mutex_unlock(&mfd->dma->ov_mutex);
+
 }
 
 static int mdp4_overlay_writeback_register_buffer(
@@ -603,7 +606,7 @@
 					  (ulong *)&temp->addr,
 					  (ulong *)&len,
 					  0,
-					  0)) {
+					  ION_IOMMU_UNMAP_DELAYED)) {
 				ion_free(mfd->iclient, srcp_ihdl);
 				pr_err("%s: unable to get ion mapping addr\n",
 				       __func__);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_util.c msm/mdp4_util.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp4_util.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp4_util.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,5 @@
-/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+/*
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -32,7 +33,10 @@
 #include "mdp.h"
 #include "msm_fb.h"
 #include "mdp4.h"
-
+#define CSC_MV_OFF	0x400
+#define CSC_BV_OFF	0x500
+#define CSC_LV_OFF	0x600
+#define CSC_POST_OFF	0x80
 struct mdp4_statistic mdp4_stat;
 
 struct mdp_csc_cfg_data csc_cfg_matrix[CSC_MAX_BLOCKS] = {
@@ -199,13 +203,14 @@
 
 	bits &= 0x1f;	/* 5 bits */
 	outpdw(MDP_BASE + 0x001c, bits);	/* MDP_SW_RESET */
+	wmb();
 
 	while (inpdw(MDP_BASE + 0x001c) & bits) /* self clear when complete */
 		;
 	/* MDP cmd block disable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
-	MSM_FB_DEBUG("mdp4_sw_reset: 0x%x\n", (int)bits);
+	pr_debug("mdp4_sw_reset: 0x%x\n", (int)bits);
 }
 
 void mdp4_overlay_cfg(int overlayer, int blt_mode, int refresh, int direct_out)
@@ -507,6 +512,7 @@
 	/* MDP cmd block enable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	mdp_clk_ctrl(1);
+	mdp_bus_scale_restore_request();
 
 #ifdef MDP4_ERROR
 	/*
@@ -558,6 +564,8 @@
 
 	/* max read pending cmd config */
 	outpdw(MDP_BASE + 0x004c, 0x02222);	/* 3 pending requests */
+	outpdw(MDP_BASE + 0x0400, 0x7FF);
+	outpdw(MDP_BASE + 0x0404, 0x30050);
 
 #ifndef CONFIG_FB_MSM_OVERLAY
 	/* both REFRESH_MODE and DIRECT_OUT are ignored at BLT mode */
@@ -1507,6 +1515,14 @@
 	},
 };
 
+void mdp4_vg_csc_restore(void)
+{
+        int i;
+
+        for (i = 0; i < CSC_MAX_BLOCKS; i++)
+                mdp4_csc_config(&csc_cfg_matrix[i]);
+}
+
 
 void mdp4_vg_csc_update(struct mdp_csc *p)
 {
@@ -2330,6 +2346,11 @@
 	return 0;
 }
 
+#define CSC_MV_OFF	0x400
+#define CSC_BV_OFF	0x500
+#define CSC_LV_OFF	0x600
+#define CSC_POST_OFF	0x80
+
 void mdp4_csc_write(struct mdp_csc_cfg *data, uint32_t base)
 {
 	int i;
@@ -3208,3 +3229,102 @@
 	}
 	return mixer_num;
 }
+
+static int is_valid_calib_addr(void *addr)
+{
+	int ret = 0;
+	unsigned int ptr;
+
+	ptr = (unsigned int) addr;
+
+	if (mdp_rev >= MDP_REV_30 && mdp_rev < MDP_REV_40) {
+		/* if request is outside the MDP reg-map or is not aligned 4 */
+		if (ptr == 0x0 || ptr > 0xF0600 || ptr % 0x4)
+			goto end;
+
+		if (ptr >= 0x90000 && ptr < 0x94000) {
+			if (ptr == 0x90000 || ptr == 0x90070)
+				ret = 1;
+			else if (ptr >= 0x93400 && ptr <= 0x93420)
+				ret = 1;
+			else if (ptr >= 0x93500 && ptr <= 0x93508)
+				ret = 1;
+			else if (ptr >= 0x93580 && ptr <= 0x93588)
+				ret = 1;
+			else if (ptr >= 0x93600 && ptr <= 0x93614)
+				ret = 1;
+			else if (ptr >= 0x93680 && ptr <= 0x93694)
+				ret = 1;
+			else if (ptr >= 0x93800 && ptr <= 0x93BFC)
+				ret = 1;
+		}
+	} else if (mdp_rev >= MDP_REV_40 && mdp_rev <= MDP_REV_44) {
+		/* if request is outside the MDP reg-map or is not aligned 4 */
+		if (ptr > 0xF0600 || ptr % 0x4)
+			goto end;
+
+		if (ptr < 0x90000) {
+			if (ptr == 0x0 || ptr == 0x4 || ptr == 0x28200 ||
+								ptr == 0x28204)
+				ret = 1;
+		} else if (ptr < 0x95000) {
+			if (ptr == 0x90000 || ptr == 0x90070)
+				ret = 1;
+			else if (ptr >= 0x93400 && ptr <= 0x93420)
+				ret = 1;
+			else if (ptr >= 0x93500 && ptr <= 0x93508)
+				ret = 1;
+			else if (ptr >= 0x93580 && ptr <= 0x93588)
+				ret = 1;
+			else if (ptr >= 0x93600 && ptr <= 0x93614)
+				ret = 1;
+			else if (ptr >= 0x93680 && ptr <= 0x93694)
+				ret = 1;
+			else if (ptr >= 0x94800 && ptr <= 0x94BFC)
+				ret = 1;
+		} else if (ptr < 0x9A000) {
+			if (ptr >= 0x98800 && ptr <= 0x9883C)
+				ret = 1;
+			else if (ptr >= 0x98880 && ptr <= 0x988AC)
+				ret = 1;
+			else if (ptr >= 0x98900 && ptr <= 0x9893C)
+				ret = 1;
+			else if (ptr >= 0x98980 && ptr <= 0x989BC)
+				ret = 1;
+			else if (ptr >= 0x98A00 && ptr <= 0x98A3C)
+				ret = 1;
+			else if (ptr >= 0x98A80 && ptr <= 0x98ABC)
+				ret = 1;
+			else if (ptr >= 0x99000 && ptr <= 0x993FC)
+				ret = 1;
+			else if (ptr >= 0x99800 && ptr <= 0x99BFC)
+				ret = 1;
+		} else if (ptr >= 0x9A000 && ptr <= 0x9a08c) {
+			ret = 1;
+		}
+	}
+end:
+	return ret;
+}
+
+int mdp4_calib_config(struct mdp_calib_config_data *cfg)
+{
+	int ret = -1;
+	void *ptr = (void *) cfg->addr;
+
+	if (is_valid_calib_addr(ptr))
+		ret = 0;
+	else
+		return ret;
+
+	ptr = (void *)(((unsigned int) ptr) + MDP_BASE);
+	mdp_clk_ctrl(1);
+	if (cfg->ops & MDP_PP_OPS_READ) {
+		cfg->data = inpdw(ptr);
+		ret = 1;
+	} else if (cfg->ops & MDP_PP_OPS_WRITE) {
+		outpdw(ptr, cfg->data);
+	}
+	mdp_clk_ctrl(0);
+	return ret;
+}
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp.c msm/mdp.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp.c	2013-12-11 02:38:33.000000000 -0800
@@ -52,7 +52,6 @@
 #include "mipi_samsung_octa.h"
 
 uint32 mdp4_extn_disp;
-u32 mdp_iommu_max_map_size;
 static struct clk *mdp_clk;
 static struct clk *mdp_pclk;
 static struct clk *mdp_lut_clk;
@@ -71,11 +70,10 @@
 int mdp_rev;
 int mdp_iommu_split_domain;
 u32 mdp_max_clk = 266667000;
-u64 mdp_max_bw = 2000000000;
-u32 mdp_bw_ab_factor = MDP4_BW_AB_DEFAULT_FACTOR;
-u32 mdp_bw_ib_factor = MDP4_BW_IB_DEFAULT_FACTOR;
+u64 mdp_max_bw = 3080000000UL;
+
 static struct platform_device *mdp_init_pdev;
-static struct regulator *footswitch, *dsi_pll_vdda, *dsi_pll_vddio;
+static struct regulator *footswitch;
 static unsigned int mdp_footswitch_on;
 
 struct completion mdp_ppp_comp;
@@ -173,8 +171,10 @@
 static uint32 mdp_prim_panel_type = NO_PANEL;
 #ifndef CONFIG_FB_MSM_MDP22
 
+#define MDP_HIST_LUT_SIZE (256)
 struct list_head mdp_hist_lut_list;
 DEFINE_MUTEX(mdp_hist_lut_list_mutex);
+uint32_t last_lut[MDP_HIST_LUT_SIZE];
 
 uint32_t mdp_block2base(uint32_t block)
 {
@@ -301,10 +301,13 @@
 
 static int mdp_hist_lut_init(void)
 {
+	int i;
 	struct mdp_hist_lut_mgmt *temp;
 
 	if (mdp_pp_initialized)
 		return -EEXIST;
+	for (i = 0; i < MDP_HIST_LUT_SIZE; i++)
+		last_lut[i] = i | (i << 8) | (i << 16);
 
 	INIT_LIST_HEAD(&mdp_hist_lut_list);
 
@@ -365,7 +368,6 @@
 	return ret;
 }
 
-#define MDP_HIST_LUT_SIZE (256)
 static int mdp_hist_lut_write_off(struct mdp_hist_lut_data *data,
 		struct mdp_hist_lut_info *info, uint32_t offset)
 {
@@ -387,9 +389,11 @@
 	}
 	mdp_clk_ctrl(1);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-	for (i = 0; i < MDP_HIST_LUT_SIZE; i++)
+	for (i = 0; i < MDP_HIST_LUT_SIZE; i++) {
+		last_lut[i] = element[i];
 		MDP_OUTP(MDP_BASE + base + offset + (0x400*(sel)) + (4*i),
 				element[i]);
+	}
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 	mdp_clk_ctrl(0);
 
@@ -560,15 +564,14 @@
 		    copy_from_user(&b, cmap->blue++, sizeof(b)))
 			return -EFAULT;
 
+		last_lut[i] = ((g & 0xff) | ((b & 0xff) << 8) |
+				((r & 0xff) << 16));
 #ifdef CONFIG_FB_MSM_MDP40
 		MDP_OUTP(MDP_BASE + 0x94800 +
 #else
 		MDP_OUTP(MDP_BASE + 0x93800 +
 #endif
-			(0x400*mdp_lut_i) + cmap->start*4 + i*4,
-				((g & 0xff) |
-				 ((b & 0xff) << 8) |
-				 ((r & 0xff) << 16)));
+			(0x400*mdp_lut_i) + cmap->start*4 + i*4, last_lut[i]);
 	}
 
 	return 0;
@@ -576,6 +579,30 @@
 
 static int mdp_lut_push;
 static int mdp_lut_push_i;
+static int mdp_lut_resume_needed;
+
+static void mdp_lut_status_restore(void)
+{
+	unsigned long flags;
+
+	if (mdp_lut_resume_needed) {
+		spin_lock_irqsave(&mdp_lut_push_lock, flags);
+		mdp_lut_push = 1;
+		spin_unlock_irqrestore(&mdp_lut_push_lock,
+					flags);
+	}
+}
+
+static void mdp_lut_status_backup(void)
+{
+	uint32_t status = inpdw(MDP_BASE + 0x90070) & 0x7;
+
+	if (status)
+		mdp_lut_resume_needed = 1;
+	else
+		mdp_lut_resume_needed = 0;
+}
+
 static int mdp_lut_update_nonlcdc(struct fb_info *info, struct fb_cmap *cmap)
 {
 	int ret;
@@ -1530,7 +1557,7 @@
 
 	if (frame_rate == 0) {
 		frame_rate = DEFAULT_FRAME_RATE;
-//		pr_warn("%s frame rate=%d is default\n", __func__, frame_rate);
+		pr_debug("%s frame rate=%d is default\n", __func__, frame_rate);
 	}
 	pr_debug("%s frame rate=%d total_pixel=%d, pixel_rate=%d\n", __func__,
 		frame_rate, total_pixel, pixel_rate);
@@ -2346,7 +2373,8 @@
 	atomic_set(&vsync_cntrl.vsync_resume, 0);
 	complete_all(&vsync_cntrl.vsync_wait);
 	mdp_clk_ctrl(1);
-
+	mdp_lut_status_backup();
+	
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	ret = panel_next_off(pdev);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
@@ -2364,7 +2392,9 @@
 
 	mdp_clk_ctrl(0);
 #ifdef CONFIG_MSM_BUS_SCALING
+	
 	mdp_bus_scale_update_request(0, 0, 0, 0);
+	
 #endif
 	pr_debug("%s:-\n", __func__);
 	return ret;
@@ -2382,22 +2412,30 @@
 
 #endif
 
-static int mdp_bus_scale_restore_request(void);
-
 static int mdp_on(struct platform_device *pdev)
 {
 	int ret = 0;
 	unsigned long flag;
 	struct msm_fb_data_type *mfd;
+	int i;
 	mfd = platform_get_drvdata(pdev);
 
 	pr_debug("%s:+\n", __func__);
 
+
 	if (mdp_rev >= MDP_REV_40) {
 		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 		mdp_clk_ctrl(1);
 		mdp_bus_scale_restore_request();
 		mdp4_hw_init();
+
+		/* Initialize HistLUT to last LUT */
+		for (i = 0; i < MDP_HIST_LUT_SIZE; i++) {
+			MDP_OUTP(MDP_BASE + 0x94800 + i*4, last_lut[i]);
+			MDP_OUTP(MDP_BASE + 0x94C00 + i*4, last_lut[i]);
+		}
+
+		mdp_lut_status_restore();
 		outpdw(MDP_BASE + 0x0038, mdp4_display_intf);
 		if (mfd->panel.type == MIPI_CMD_PANEL) {
 			mdp_vsync_cfg_regs(mfd, FALSE);
@@ -2423,8 +2461,6 @@
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 
-	if (mfd->index == 0)
-		mdp_iommu_max_map_size = mfd->max_map_size;
 	ret = panel_next_on(pdev);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
@@ -2492,7 +2528,7 @@
 #ifdef CONFIG_MSM_BUS_SCALING
 
 #ifndef MDP_BUS_VECTOR_ENTRY_P0
-#define MDP_BUS_VECTOR_ENTRY_P0(ab_val, ib_val)		\
+#define MDP_BUS_VECTOR_ENTRY_P0(ab_val, ib_val)                \
 	{						\
 		.src = MSM_BUS_MASTER_MDP_PORT0,	\
 		.dst = MSM_BUS_SLAVE_EBI_CH0,		\
@@ -2501,47 +2537,48 @@
 	}
 #endif
 #ifndef MDP_BUS_VECTOR_ENTRY_P1
-#define MDP_BUS_VECTOR_ENTRY_P1(ab_val, ib_val)		\
-	{						\
-		.src = MSM_BUS_MASTER_MDP_PORT1,	\
-		.dst = MSM_BUS_SLAVE_EBI_CH0,		\
-		.ab  = (ab_val),			\
-		.ib  = (ib_val),			\
-	}
+#define MDP_BUS_VECTOR_ENTRY_P1(ab_val, ib_val)                \
+       {                                               \
+               .src = MSM_BUS_MASTER_MDP_PORT1,        \
+               .dst = MSM_BUS_SLAVE_EBI_CH0,           \
+               .ab  = (ab_val),                        \
+               .ib  = (ib_val),                        \
+       }
 #endif
 
+
 /*
  *    Entry 0 hold 0 request
  *    Entry 1 and 2 do ping pong request
  */
 static struct msm_bus_vectors mdp_bus_init_vectors[] = {
-	MDP_BUS_VECTOR_ENTRY_P0(0, 0),
-	MDP_BUS_VECTOR_ENTRY_P1(0, 0),
+		MDP_BUS_VECTOR_ENTRY_P0(0, 0),
+		MDP_BUS_VECTOR_ENTRY_P1(0, 0),
 };
 
 static struct msm_bus_vectors mdp_bus_ping_vectors[] = {
-	MDP_BUS_VECTOR_ENTRY_P0(128000000, 160000000),
-	MDP_BUS_VECTOR_ENTRY_P1(128000000, 160000000),
+		MDP_BUS_VECTOR_ENTRY_P0(128000000, 160000000),
+		MDP_BUS_VECTOR_ENTRY_P1(128000000, 160000000),
 };
 
 static struct msm_bus_vectors mdp_bus_pong_vectors[] = {
-	MDP_BUS_VECTOR_ENTRY_P0(128000000, 160000000),
-	MDP_BUS_VECTOR_ENTRY_P1(128000000, 160000000),
+		MDP_BUS_VECTOR_ENTRY_P0(128000000, 160000000),
+		MDP_BUS_VECTOR_ENTRY_P1(128000000, 160000000),
 };
 
 static struct msm_bus_paths mdp_bus_usecases[] = {
-	{
-		ARRAY_SIZE(mdp_bus_init_vectors),
-		mdp_bus_init_vectors,
-	},
-	{
-		ARRAY_SIZE(mdp_bus_ping_vectors),
-		mdp_bus_ping_vectors,
-	},
-	{
-		ARRAY_SIZE(mdp_bus_pong_vectors),
-		mdp_bus_pong_vectors,
-	},
+       {
+               ARRAY_SIZE(mdp_bus_init_vectors),
+               mdp_bus_init_vectors,
+       },
+      {
+               ARRAY_SIZE(mdp_bus_ping_vectors),
+               mdp_bus_ping_vectors,
+       },
+       {
+               ARRAY_SIZE(mdp_bus_pong_vectors),
+               mdp_bus_pong_vectors,
+       },
 };
 
 static struct msm_bus_scale_pdata mdp_bus_scale_table = {
@@ -2582,11 +2619,9 @@
 	bus_index = (bus_index > 2) ? 1 : bus_index;
 
 	mdp_bus_usecases[bus_index].vectors[0].ab = min(ab_p0, mdp_max_bw);
-
    ib_p0 = max(ib_p0, ab_p0);
    mdp_bus_usecases[bus_index].vectors[0].ib = min(ib_p0, mdp_max_bw);
 
-
    mdp_bus_usecases[bus_index].vectors[1].ab = min(ab_p1, mdp_max_bw);
    ib_p1 = max(ib_p1, ab_p1);
    mdp_bus_usecases[bus_index].vectors[1].ib = min(ib_p1, mdp_max_bw);
@@ -2594,18 +2629,17 @@
 	pr_debug("%s: handle=%d index=%d ab=%llu ib=%llu\n", __func__,
 		 (u32)mdp_bus_scale_handle, bus_index,
 		 mdp_bus_usecases[bus_index].vectors[0].ab,
-		 mdp_bus_usecases[bus_index].vectors[0].ib);
-
+		mdp_bus_usecases[bus_index].vectors[0].ib);
 	pr_debug("%s: p1 handle=%d index=%d ab=%llu ib=%llu\n", __func__,
-		 (u32)mdp_bus_scale_handle, bus_index,
-		 mdp_bus_usecases[bus_index].vectors[1].ab,
-		 mdp_bus_usecases[bus_index].vectors[1].ib);
+			(u32)mdp_bus_scale_handle, bus_index,
+			mdp_bus_usecases[bus_index].vectors[1].ab,
+			mdp_bus_usecases[bus_index].vectors[1].ib);
+	
 
 	return msm_bus_scale_client_update_request
 		(mdp_bus_scale_handle, bus_index);
 }
 
-
 int mdp_bus_scale_restore_request(void) 
 { 
 	u64 ab, ib; 
@@ -2630,11 +2664,7 @@
 		mdp_bus_usecases[bus_index].vectors[1].ab,
 		mdp_bus_usecases[bus_index].vectors[1].ib); 
 } 
-#else
-static int mdp_bus_scale_restore_request(void)
-{
-	return 0;
-}
+
 #endif
 DEFINE_MUTEX(mdp_clk_lock);
 int mdp_set_core_clk(u32 rate)
@@ -2683,40 +2713,18 @@
 	}
 	disable_irq(mdp_irq);
 
-	dsi_pll_vdda = regulator_get(&pdev->dev, "dsi_pll_vdda");
-	if (IS_ERR(dsi_pll_vdda)) {
-		dsi_pll_vdda = NULL;
-	} else {
-		if (mdp_rev == MDP_REV_42 || mdp_rev == MDP_REV_44) {
-			ret = regulator_set_voltage(dsi_pll_vdda, 1200000,
-				1200000);
-			if (ret) {
-				pr_err("set_voltage failed for dsi_pll_vdda, ret=%d\n",
-					ret);
-			}
-		}
-	}
-
-	dsi_pll_vddio = regulator_get(&pdev->dev, "dsi_pll_vddio");
-	if (IS_ERR(dsi_pll_vddio)) {
-		dsi_pll_vddio = NULL;
-	} else {
-		if (mdp_rev == MDP_REV_42) {
-			ret = regulator_set_voltage(dsi_pll_vddio, 1800000,
-				1800000);
-			if (ret) {
-				pr_err("set_voltage failed for dsi_pll_vddio, ret=%d\n",
-					ret);
-			}
-		}
-	}
-
 	footswitch = regulator_get(&pdev->dev, "vdd");
-	if (IS_ERR(footswitch)) {
+	if (IS_ERR(footswitch))
 		footswitch = NULL;
-	} else {
+	else {
 		regulator_enable(footswitch);
 		mdp_footswitch_on = 1;
+
+		if (mdp_rev == MDP_REV_42 && !cont_splashScreen) {
+			regulator_disable(footswitch);
+			msleep(20);
+			regulator_enable(footswitch);
+		}
 	}
 
 	mdp_clk = clk_get(&pdev->dev, "core_clk");
@@ -2767,17 +2775,6 @@
 
 	MSM_FB_DEBUG("mdp_clk: mdp_clk=%d\n", (int)clk_get_rate(mdp_clk));
 #endif
-
-	if (mdp_rev == MDP_REV_42 && !cont_splashScreen) {
-		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-		/* DSI Video Timing generator disable */
-		outpdw(MDP_BASE + 0xE0000, 0x0);
-		/* Clear MDP Interrupt Enable register */
-		outpdw(MDP_BASE + 0x50, 0x0);
-		/* Set Overlay Proc 0 to reset state */
-		outpdw(MDP_BASE + 0x10004, 0x3);
-		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-	}
 	return 0;
 }
 
@@ -2817,13 +2814,6 @@
 			return -ENOMEM;
 		}
 
-		if (mdp_pdata->mdp_max_bw)
-			mdp_max_bw = mdp_pdata->mdp_max_bw;
-		if (mdp_pdata->mdp_bw_ab_factor)
-			mdp_bw_ab_factor = mdp_pdata->mdp_bw_ab_factor;
-		if (mdp_pdata->mdp_bw_ib_factor)
-			mdp_bw_ib_factor = mdp_pdata->mdp_bw_ib_factor;
-
 		mdp_rev = mdp_pdata->mdp_rev;
 
 		mdp_iommu_split_domain = mdp_pdata->mdp_iommu_split_domain;
@@ -3277,17 +3267,6 @@
 		return;
 	}
 
-	if (dsi_pll_vddio)
-		regulator_enable(dsi_pll_vddio);
-
-	if (dsi_pll_vdda)
-		regulator_enable(dsi_pll_vdda);
-
-	mipi_dsi_prepare_ahb_clocks();
-	mipi_dsi_ahb_ctrl(1);
-	mipi_dsi_phy_ctrl(1);
-	mipi_dsi_clk_enable();
-
 	if (on && !mdp_footswitch_on) {
 		pr_debug("Enable MDP FS\n");
 		regulator_enable(footswitch);
@@ -3298,18 +3277,6 @@
 		mdp_footswitch_on = 0;
 	}
 
-	mipi_dsi_clk_disable();
-	mipi_dsi_unprepare_clocks();
-	mipi_dsi_phy_ctrl(0);
-	mipi_dsi_ahb_ctrl(0);
-	mipi_dsi_unprepare_ahb_clocks();
-
-	if (dsi_pll_vdda)
-		regulator_disable(dsi_pll_vdda);
-
-	if (dsi_pll_vddio)
-		regulator_disable(dsi_pll_vddio);
-
 	mutex_unlock(&mdp_suspend_mutex);
 }
 
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp_debugfs.c msm/mdp_debugfs.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp_debugfs.c	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp_debugfs.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -620,8 +620,11 @@
 	else
 		base = (char *)msm_pmdh_base;
 
-	if (base == NULL)
+	if (base == NULL) {
+		printk(KERN_INFO "%s: base offset is not set properly. \
+			Please check if MDDI enables correctly\n", __func__);
 		return;
+	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	writel(data, base + off);
@@ -646,8 +649,11 @@
 	else
 		base = msm_pmdh_base;
 
-	if (base == NULL)
+	if (base == NULL) {
+		printk(KERN_INFO "%s: base offset is not set properly. \
+			Please check if MDDI enables correctly\n", __func__);
 		return -EFAULT;
+	}
 
 	reg = mddi_regs_list;
 	bp = debug_buf;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp.h msm/mdp.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdp.h	2013-12-17 17:08:08.018147349 -0800
+++ msm/mdp.h	2013-12-11 02:38:33.000000000 -0800
@@ -778,8 +778,6 @@
 int mdp_lcdc_off(struct platform_device *pdev);
 void mdp_lcdc_update(struct msm_fb_data_type *mfd);
 void mdp4_overlay_dsi_video_start(void);
-
-
 #ifdef CONFIG_FB_MSM_MDP303
 int mdp_dsi_video_on(struct platform_device *pdev);
 int mdp_dsi_video_off(struct platform_device *pdev);
@@ -836,20 +834,22 @@
 
 #ifdef CONFIG_MSM_BUS_SCALING
 int mdp_bus_scale_update_request(u64 ab_p0, u64 ib_p0, u64 ab_p1, u64 ib_p1);
+
+int mdp_bus_scale_restore_request(void);
 #else
 static inline int mdp_bus_scale_update_request(u64 ab_p0,
-					       u64 ib_p0,
-					       u64 ab_p1,
-					       u64 ib_p1)
-{
-	return 0;
-}
+                                              u64 ib_p0,
+                                              u64 ab_p1,
+                                              u64 ib_p1)
+ {
+        return 0;
+ }
 
+ 
 static int mdp_bus_scale_restore_request(void) 
 { 
  return 0; 
 } 
-
 #endif
 void mdp_dma_vsync_ctrl(int enable);
 void mdp_dma_video_vsync_ctrl(int enable);
@@ -884,7 +884,7 @@
 void __mdp_histogram_kickoff(struct mdp_hist_mgmt *mgmt);
 void __mdp_histogram_reset(struct mdp_hist_mgmt *mgmt);
 void mdp_footswitch_ctrl(boolean on);
-int mdp_enable_iommu_clocks(void);
+int mdp_enable_iommu_clocks(void); 
 int mdp_disable_iommu_clocks(void);
 
 #ifdef CONFIG_FB_MSM_MDP303
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdss/mdss_fb.c msm/mdss/mdss_fb.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdss/mdss_fb.c	2013-12-17 17:08:08.022147343 -0800
+++ msm/mdss/mdss_fb.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/*
+*
  * Core MDSS framebuffer driver.
  *
  * Copyright (C) 2007 Google Incorporated
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdss/mdss_mdp.c msm/mdss/mdss_mdp.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mdss/mdss_mdp.c	2013-12-17 17:08:08.022147343 -0800
+++ msm/mdss/mdss_mdp.c	2013-12-11 02:38:33.000000000 -0800
@@ -580,52 +580,6 @@
 	for (i = 0; i < MDSS_MAX_CLK; i++) {
 		if (mdss_res->mdp_clk[i])
 			clk_put(mdss_res->mdp_clk[i]);
-}
-
-static int mdss_iommu_fault_handler(struct iommu_domain *domain,
-		struct device *dev, unsigned long iova, int flags, void *token)
-{
-	pr_err("MDP IOMMU page fault: iova 0x%lx\n", iova);
-	return 0;
-}
-
-int mdss_iommu_attach(struct mdss_data_type *mdata)
-{
-	struct iommu_domain *domain;
-	struct mdss_iommu_map_type *iomap;
-	int i;
-
-	if (mdata->iommu_attached) {
-		pr_warn("mdp iommu already attached\n");
-		return 0;
-	}
-
-	for (i = 0; i < MDSS_IOMMU_MAX_DOMAIN; i++) {
-		iomap = mdata->iommu_map + i;
-
-		domain = msm_get_iommu_domain(iomap->domain_idx);
-		if (!domain) {
-			WARN(1, "could not attach iommu client %s to ctx %s\n",
-				iomap->client_name, iomap->ctx_name);
-			continue;
-		}
-		iommu_attach_device(domain, iomap->ctx);
-	}
-
-	mdata->iommu_attached = true;
-
-	return 0;
-}
-
-int mdss_iommu_dettach(struct mdss_data_type *mdata)
-{
-	struct iommu_domain *domain;
-	struct mdss_iommu_map_type *iomap;
-	int i;
-
-	if (!mdata->iommu_attached) {
-		pr_warn("mdp iommu already dettached\n");
-		return 0;
 	}
 	if (mdss_res->fs)
 		regulator_put(mdss_res->fs);
@@ -640,35 +594,6 @@
 	struct device *dev)
 {
 	struct msm_panel_common_pdata *pdata;
-	struct msm_iova_layout layout;
-	struct iommu_domain *domain;
-	struct mdss_iommu_map_type *iomap;
-	int i;
-
-	if (mdata->iommu_map) {
-		pr_warn("iommu already initialized\n");
-		return 0;
-	}
-
-	for (i = 0; i < MDSS_IOMMU_MAX_DOMAIN; i++) {
-		iomap = &mdss_iommu_map[i];
-
-		layout.client_name = iomap->client_name;
-		layout.partitions = iomap->partitions;
-		layout.npartitions = iomap->npartitions;
-		layout.is_secure = (i == MDSS_IOMMU_DOMAIN_SECURE);
-
-		iomap->domain_idx = msm_register_domain(&layout);
-		if (IS_ERR_VALUE(iomap->domain_idx))
-			return -EINVAL;
-
-		domain = msm_get_iommu_domain(iomap->domain_idx);
-		if (!domain) {
-			pr_err("unable to get iommu domain(%d)\n",
-				iomap->domain_idx);
-			return -EINVAL;
-		}
-		iommu_set_fault_handler(domain, mdss_iommu_fault_handler, NULL);
 
 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl/mhl_8334.c msm/mhl/mhl_8334.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl/mhl_8334.c	2013-12-17 17:08:08.022147343 -0800
+++ msm/mhl/mhl_8334.c	2013-12-11 02:38:33.000000000 -0800
@@ -77,7 +77,7 @@
 {
 	static struct regulator *reg_8038_l20;
 	static struct regulator *reg_8038_l11;
-	int rc;
+	int rc = -EINVAL;
 
 	pr_debug("Inside %s\n", __func__);
 	if (!reg_8038_l20) {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl_v2/Kconfig msm/mhl_v2/Kconfig
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl_v2/Kconfig	2013-12-17 17:08:08.022147343 -0800
+++ msm/mhl_v2/Kconfig	2013-12-11 02:38:33.000000000 -0800
@@ -48,4 +48,13 @@
 	To distinguish TA and USB charger, mhl_version2 support new msc cmd
 	different from mhl_v1.
 
+config MHL_VERSION
+	hex "Number of MHL Version"
+	default 0x20
+	---help---
+	MHL Version
+	For example, those device compliant
+	with MHL Specification version 2.0 
+	shell set this MHL_VERSION to 0x20
+
 endmenu
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl_v2/sii8240.c msm/mhl_v2/sii8240.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl_v2/sii8240.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mhl_v2/sii8240.c	2013-12-11 02:38:33.000000000 -0800
@@ -35,6 +35,7 @@
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/power_supply.h>
 #include <video/edid.h>
 #include <linux/mfd/max77693.h>
 #include "../../../video/edid.h"
@@ -48,12 +49,16 @@
 #include <mach/scm.h>
 #endif
 #define CONFIG_MHL_SWING_LEVEL 0
+#ifdef CONFIG_MFD_MAX77693
+#include <linux/mfd/max77693-private.h>
+#endif
 
 static struct device *sii8240_mhldev;
 static struct sii8240_data *g_sii8240;
 #ifdef SII8240_CHECK_MONITOR
 static struct hdcp_auth_status g_monitor_cmd;
 #endif
+static bool check_vbus_present(void);
 
 struct class *sec_mhl;
 EXPORT_SYMBOL(sec_mhl);
@@ -674,6 +679,7 @@
 			ret = sii8240_tmds_active_hdcp(sii8240);
 			if (unlikely(ret < 0)) {
 				pr_err("[ERROR]sii8240: sii8240_tmds_active_hdcp fail\n");
+				return ret;
 			}
 			break;
 
@@ -725,8 +731,10 @@
 			pr_info("sii8240: %s():%d default !!!\n",
 			__func__, __LINE__);
 			ret = sii8240_hdcp_on(sii8240, false);
-			if (unlikely(ret < 0))
-				pr_info("sii8240: sii8240_hdcp_on fail\n");
+			if (unlikely(ret < 0)) {
+				pr_err("[ERROR] sii8240: sii8240_hdcp_on fail\n");
+				return ret;
+			}
 
 			ret = sii8240_tmds_active_hdcp(sii8240);
 			if (unlikely(ret < 0)) {
@@ -758,6 +766,7 @@
 		if (unlikely(ret < 0)) {
 			pr_err("[ERROR] %s(%d):sii8240_hdcp_on is fail\n",
 				__func__, __LINE__);
+			return ret;
 		}
 		ret = sii8240_tmds_active_hdcp(sii8240);
 		if (unlikely(ret < 0)) {
@@ -800,33 +809,47 @@
 	u16 temp = edid_ext << 7;
 
 	ret = mhl_set_reg(hdmi, EDID_STATUS_HW_ASSIST_REG, HW_EDID_DONE);
-	if (unlikely(ret < 0))
-		goto err_exit;
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR]sii8240: %s():%d failed !\n",
+				__func__, __LINE__);
+		return ret;
+	}
 
 	ret = mhl_write_byte_reg(hdmi, EDID_CTRL_REG,
 			EDID_MODE_EN | EDID_FIFO_ADDR_AUTO);
-	if (unlikely(ret < 0))
-		goto err_exit;
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR]sii8240: %s():%d failed !\n",
+				__func__, __LINE__);
+		return ret;
+	}
 
-	if (!edid_ext)		/* Block-0 */
+	if (!edid_ext) {	/* Block-0 */
 		ret = mhl_write_byte_reg(hdmi, EDID_PAGE_HW_ASSIST_REG,
 			HW_READ_EDID_BLOCK_0);
-
-	else			/* other EDID-extension blocks */
+		if (unlikely(ret < 0)) {
+			pr_err("[ERROR]sii8240: %s():%d failed !\n",
+					__func__, __LINE__);
+			return ret;
+		}
+	} else {		/* other EDID-extension blocks */
 		ret = mhl_write_byte_reg(hdmi, EDID_BLOCK_ADDR_HW_ASSIST_REG,
 			(1<<(edid_ext-1)));
-
-	if (unlikely(ret < 0))
-		goto err_exit;
+		if (unlikely(ret < 0)) {
+			pr_err("[ERROR]sii8240: %s():%d failed !\n",
+					__func__, __LINE__);
+			return ret;
+		}
+	}
 
 	/* TODO: use some completion mechanism or wait_for_completion_timeout
 	 * APIs instead of this loop */
 	do {
 		ret = mhl_read_byte_reg(hdmi, EDID_STATUS_HW_ASSIST_REG,
 			&data);
-		if (unlikely(ret < 0))
+		if (unlikely(ret < 0)) {
+			pr_info("sii8240:edid reg read failed!\n");
 			return ret;
-
+		}
 		if (data & HW_EDID_DONE) {
 			ret = mhl_write_byte_reg(hdmi,
 						EDID_STATUS_HW_ASSIST_REG,
@@ -863,11 +886,16 @@
 	if (i == 100) {
 		pr_info("sii8240:%s():%d EDID READ timeout\n",
 							__func__, __LINE__);
-		return ret;
+		return -ETIMEDOUT;
 	}
 
 	/* CHECK: 0,(1<<7),0,(1<<7) values being used in reference driver */
-	mhl_write_byte_reg(hdmi, EDID_FIFO_ADDR_REG, (temp & 0xFF));
+	ret = mhl_write_byte_reg(hdmi, EDID_FIFO_ADDR_REG, (temp & 0xFF));
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR]sii8240: %s():%d failed !\n",
+				__func__, __LINE__);
+		return ret;
+	}
 
 	/* TODO 1: We can optimize this loop using loop unrolling techniques */
 	/* TODO 2: In one of the reference driver, block read is being used;
@@ -878,14 +906,12 @@
 				I2C_SMBUS_BLOCK_MAX,
 				(&sii8240->edid[i*I2C_SMBUS_BLOCK_MAX +
 				 edid_ext*EDID_LENGTH]));
-		if (unlikely(ret < 0))
-			pr_warn("failed to read EDID_FIFO_RD_DATA_REG\n");
+		if (unlikely(ret < 0)) {
+			pr_err("failed to read EDID_FIFO_RD_DATA_REG\n");
+			return ret;
+		}
 	}
 	return ret;
-
-err_exit:
-	pr_err("failed to read/write registers\n");
-	return ret;
 }
 u8 sii8240_mhl_get_version(void)
 {
@@ -923,8 +949,12 @@
 		edid_exts = 0;
 	}
 
-	if (!edid_exts)
+	if (!edid_exts) {
+		ret = mhl_write_byte_reg(hdmi, EDID_BLOCK_ADDR_HW_ASSIST_REG, (1<<0));
+		if (ret < 0)
+			return ret;
 		goto edid_populated;
+	}
 
 	for (i = 1; i <= edid_exts; i++) {
 		ret = sii8240_read_edid_block(sii8240, i);
@@ -979,10 +1009,11 @@
 		BIT_HPD_CTRL_HPD_OUT_OVR_EN_MASK,
 		BIT_HPD_CTRL_HPD_OUT_OVR_VAL_OFF |
 		BIT_HPD_CTRL_HPD_OUT_OVR_EN_ON);
-	if (unlikely(ret < 0))
+	if (unlikely(ret < 0)) {
 		pr_warn("[ERROR]sii8240: %s():%d failed !\n",
 		__func__, __LINE__);
-
+		return ret;
+	}
 	sii8240->hpd_status = false;
 
 	return ret;
@@ -990,19 +1021,23 @@
 
 static int force_usb_id_switch_open(struct sii8240_data *sii8240)
 {
-	int ret = 0;
+	int ret;
 	struct i2c_client *disc = sii8240->pdata->disc_client;
 
 	ret = mhl_modify_reg(disc, 0x10, 0x1, 0x0);
-	if (unlikely(ret < 0))
-		pr_warn("[ERROR]sii8240: %s():%d !\n",
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR] sii8240: %s():%d !\n",
 			__func__, __LINE__);
+		return ret;
+	}
 
 	ret = mhl_modify_reg(disc, 0x15,
 		BIT_DC6_USB_OVERRIDE_MASK, BIT_DC6_USB_OVERRIDE_ON);
-	if (unlikely(ret < 0))
-		pr_warn("[ERROR]sii8240: %s():%d !\n",
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR] sii8240: %s():%d !\n",
 			__func__, __LINE__);
+		return ret;
+	}
 
 	ret = mhl_write_byte_reg(disc, 0x12, BIT_DC3_COMM_IMME_ON |
 					BIT_DC3_FORCE_MHL_OFF |
@@ -1010,21 +1045,25 @@
 					BIT_DC3_FORCE_USB_OFF |
 					BIT_DC3_USB_EN_OFF |
 					BIT_DC3_DLYTRG_SEL_064ms);
-	if (unlikely(ret < 0))
-		pr_warn("[ERROR]sii8240: %s():%d failed !\n",
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR]sii8240: %s():%d failed !\n",
 			__func__, __LINE__);
+		return ret;
+	}
 
 	ret = mhl_hpd_control_low(sii8240);
-	if (unlikely(ret < 0))
-		pr_warn("[ERROR]sii8240: %s():%d failed !\n",
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR] sii8240: %s():%d failed !\n",
 			__func__, __LINE__);
+		return ret;
+	}
 
 	return ret;
 }
 
 static int release_usb_id_switch_open(struct sii8240_data *sii8240)
 {
-	int ret = 0;
+	int ret;
 	struct i2c_client *disc = sii8240->pdata->disc_client;
 
 	msleep(50);
@@ -1474,10 +1513,12 @@
 		return ret;
 	}
 
-	/*disable intr when cbus open*/
+	/*This code is for disabling intr when cbus open*/
+	/*
 	ret = mhl_write_byte_reg(disc, 0x13, 0xAC);
 	if (unlikely(ret < 0))
 		return ret;
+	*/
 
 	ret = mhl_write_byte_reg(hdmi, TPI_PACKET_FILTER_REG,
 					DROP_GCP_PKT | DROP_AVI_PKT |
@@ -1792,17 +1833,15 @@
 
 static void sii8240_power_down(struct sii8240_data *sii8240)
 {
-	struct i2c_client *disc = sii8240->pdata->disc_client;
-
 	pr_info("%s()\n", __func__);
 
+	mhl_hpd_control_low(sii8240);
+
 	if (sii8240->irq_enabled) {
 		disable_irq_nosync(sii8240->irq);
 		sii8240->irq_enabled = false;
 		pr_info("sii8240: interrupt disabled\n");
 	}
-	if (sii8240->pdata->vbus_present)
-		sii8240->pdata->vbus_present(false, -1);
 
 	sii8240->state = STATE_DISCONNECTED;
 	cancel_work_sync(&sii8240->cbus_work);
@@ -1810,7 +1849,6 @@
 	cancel_work_sync(&sii8240->avi_control_work);
 	del_timer_sync(&sii8240->avi_check_timer);
 
-	mhl_write_byte_reg(disc, POWER_CTRL_REG, 0);
 	if (sii8240->pdata->power)
 		sii8240->pdata->power(0);
 	sii8240->muic_state = MHL_DETTACHED;
@@ -1837,28 +1875,47 @@
 	return ret;
 }
 
+static bool check_vbus_present(void) {
+        bool ret = true;
+        union power_supply_propval value;
+
+        psy_do_property("sec-charger", get, POWER_SUPPLY_PROP_ONLINE, value);
+        pr_info("sec-charger : %d\n", value.intval);
+        if (value.intval == POWER_SUPPLY_TYPE_BATTERY
+                || value.intval == POWER_SUPPLY_TYPE_WIRELESS)
+                ret = false;
+        pr_info("VBUS : %s in %s\n", ret ? "IN" : "OUT", __func__);
+        return ret;
+}
+
 static void sii8240_setup_charging(struct sii8240_data *sii8240)
 {
 	u8 plim, dev_cat;
 	u16 adopter_id;
 	u8 *peer_devcap = sii8240->regs.peer_devcap;
 
-	if (peer_devcap[MHL_DEVCAP_MHL_VERSION] == 0x20) {
+	if ((peer_devcap[MHL_DEVCAP_MHL_VERSION] & 0xF0) >= 0x20) {
 		dev_cat = peer_devcap[MHL_DEVCAP_DEV_CAT];
 		pr_info("sii8240: DEV_CAT 0x%x\n", dev_cat);
 		if (((dev_cat >> 4) & 0x1) == 1) {
 			plim = ((dev_cat >> 5) & 0x3);
 			pr_info("sii8240 : PLIM 0x%x\n", plim);
-			sii8240->pdata->vbus_present(false, plim);
+			if (sii8240->pdata->vbus_present)
+				sii8240->pdata->vbus_present(false, plim);
 		}
-	} else {
+	} else if ((peer_devcap[MHL_DEVCAP_MHL_VERSION] & 0xF0) == 0x10) {
 		adopter_id = peer_devcap[MHL_DEVCAP_ADOPTER_ID_L] |
 				peer_devcap[MHL_DEVCAP_ADOPTER_ID_H] << 8;
 		pr_info("sii8240: adopter id:%d, reserved:%d\n",
 				adopter_id, peer_devcap[MHL_DEVCAP_RESERVED]);
 
-		if (adopter_id == 321 && peer_devcap[MHL_DEVCAP_RESERVED] == 2)
-			sii8240->pdata->vbus_present(false, 0x01);
+		if (adopter_id == 321 && peer_devcap[MHL_DEVCAP_RESERVED] == 2) {
+			if (sii8240->pdata->vbus_present)
+				sii8240->pdata->vbus_present(false, 0x01);
+		}
+	} else {
+		pr_err("sii8240:%s MHL version error - 0x%X\n", __func__,
+				peer_devcap[MHL_DEVCAP_MHL_VERSION]);
 	}
 }
 
@@ -2352,10 +2409,10 @@
 	bool ret = false;
 
 	/*get packed pixcel information*/
-	if (sii8240->support_mhl_timing.avi_infoframe[vic-1] == 1)
+	if (sii8240->support_mhl_timing.avi_infoframe[vic] == 1)
 		ret = true;
 
-	switch (vic-1) {
+	switch (vic) {
 	case HDMI_VFRMT_1280x720p50_16_9:
 	case HDMI_VFRMT_1280x720p60_16_9:
 	case HDMI_VFRMT_1920x1080p24_16_9:
@@ -2528,7 +2585,7 @@
 			goto exit;
 		}
 
-		if ((sii8240->regs.peer_devcap[MHL_DEVCAP_MHL_VERSION] == 0x20)
+		if (((sii8240->regs.peer_devcap[MHL_DEVCAP_MHL_VERSION] & 0xF0) >= 0x20)
 		&& (sii8240->regs.peer_devcap[MHL_DEVCAP_VID_LINK_MODE] &
 					 (MHL_DEV_VID_LINK_SUPP_PPIXEL |
 					MHL_DEV_VID_LINK_SUPPYCBCR422)) &&
@@ -2610,12 +2667,6 @@
 					__func__, __LINE__);
 				goto exit;
 			}
-			ret = sii8240_bypass_avi_info(sii8240);
-			if (unlikely(ret < 0)) {
-				pr_info("sii8240: %s():%d failed\n",
-							__func__, __LINE__);
-				goto exit;
-			}
 			ret = tmds_control(sii8240, true);
 			if (unlikely(ret < 0)) {
 				pr_info("sii8240: %s():%d failed !\n",
@@ -2649,8 +2700,8 @@
 			goto exit;
 		}
 
-		if ((sii8240->regs.peer_devcap[MHL_DEVCAP_MHL_VERSION]
-						& 0x20) &&
+		if (((sii8240->regs.peer_devcap[MHL_DEVCAP_MHL_VERSION] & 0xF0)
+						>= 0x20) &&
 		(sii8240->regs.peer_devcap[MHL_DEVCAP_VID_LINK_MODE] &
 				 MHL_DEV_VID_LINK_SUPP_PPIXEL) &&
 		(sii8240->regs.peer_devcap[MHL_DEVCAP_VID_LINK_MODE] &
@@ -2686,6 +2737,7 @@
 	}
 	sii8240->state = STATE_DISCONNECTED;
 	sii8240->rgnd = RGND_UNKNOWN;
+	mhl_hpd_control_low(sii8240);
 	sii8240->pdata->hw_reset();
 
 	if (sii8240_init_regs(sii8240) < 0) {
@@ -2723,8 +2775,6 @@
 	struct sii8240_data *sii8240 = container_of(this, struct sii8240_data,
 							mhl_nb);
 	int handled = MHL_CON_UNHANDLED;
-	struct i2c_client *disc = sii8240->pdata->disc_client;
-	u8 intr1 = 0, rgnd = 0;
 
 	if (event == sii8240->muic_state) {
 		pr_info("sii8240 : Same muic event, Ignored!\n");
@@ -2736,6 +2786,8 @@
 		sii8240->mhl_connected = true; 
 	} else {
 		pr_info("sii8240:disconnection\n");
+		if (sii8240->pdata->vbus_present)
+			sii8240->pdata->vbus_present(false, -1);
 		sii8240->mhl_connected = false; 
 		mutex_lock(&sii8240->lock);
 		goto power_down;
@@ -2809,10 +2861,6 @@
 
 unhandled:
 	pr_info("sii8240: Detection failed and additional information about sii8240");
-	mhl_read_byte_reg(disc, DISC_INTR_REG, &intr1);
-	mhl_read_byte_reg(disc, DISC_RGND_REG, &rgnd);
-	pr_err("disc intr1 0x%x, rgnd 0x%x\n", intr1, rgnd);
-
 	if (sii8240->state == STATE_DISCONNECTED)
 		pr_cont(" (timeout)");
 	else if (sii8240->state == STATE_CBUS_UNSTABLE)
@@ -2983,27 +3031,28 @@
 		if (sii8240->cbus_ready) {
 			pr_info("sii8240: device capability cbus_ready\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_MHL_VERSION, 0) < 0)
+						MHL_DEVCAP_MHL_VERSION, 0) < 0)
 				pr_info("sii8240: MHL_VERSION read fail\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_ADOPTER_ID_H, 0) < 0)
+						MHL_DEVCAP_ADOPTER_ID_H, 0) < 0)
 				pr_info("sii8240: MHL_ADOPTER_ID_H read fail\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_ADOPTER_ID_L, 0) < 0)
+						MHL_DEVCAP_ADOPTER_ID_L, 0) < 0)
 				pr_info("sii8240: MHL_ADOPTER_ID_L read fail\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_RESERVED, 0) < 0)
+						MHL_DEVCAP_RESERVED, 0) < 0)
 				pr_info("sii8240: MHL_RESERVED read fail\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_DEV_CAT, 0) < 0)
+						MHL_DEVCAP_DEV_CAT, 0) < 0)
 				pr_info("sii8240: DEV_CAT read fail\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_FEATURE_FLAG, 0) < 0)
+						MHL_DEVCAP_FEATURE_FLAG, 0) < 0)
 				pr_info("sii8240: FEATURE_FLAG read fail\n");
 			if (sii8240_queue_cbus_cmd_locked(sii8240, READ_DEVCAP,
-					MHL_DEVCAP_VID_LINK_MODE, 0) < 0)
+						MHL_DEVCAP_VID_LINK_MODE, 0) < 0)
 				pr_info("sii8240: VID_LINK_MODE read fail\n");
 		}
+
 		if (path_en_changed)
 			sii8240_queue_cbus_cmd_locked(sii8240, WRITE_STAT,
 					CBUS_MHL_STATUS_OFFSET_1,
@@ -3473,11 +3522,28 @@
 	pr_info("sii8240_audio_video_intr_control\n");
 #ifdef SFEATURE_HDCP_SUPPORT
 /*TO do*/
-	mhl_read_byte_reg(tpi, HDCP_INTR , &value);
-	mhl_write_byte_reg(tpi, HDCP_INTR , value);
-	if (value)
-		sii8240_hdcp_control(sii8240, value);
+	ret = mhl_read_byte_reg(tpi, HDCP_INTR , &value);
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR] sii8240: %s():%d failed\n",
+				__func__, __LINE__);
+		return ret;
+	}
+
+	ret = mhl_write_byte_reg(tpi, HDCP_INTR , value);
+	if (unlikely(ret < 0)) {
+		pr_err("[ERROR] sii8240: %s():%d failed\n",
+				__func__, __LINE__);
+		return ret;
+	}
 
+	if (value && sii8240->hpd_status) {
+		ret = sii8240_hdcp_control(sii8240, value);
+		if (unlikely(ret < 0)) {
+			pr_err("[ERROR] sii8240: %s():%d failed\n",
+					__func__, __LINE__);
+			return ret;
+		}
+	}
 #endif
 	mhl_read_byte_reg(tmds, US_INTR, &upstatus);
 	mhl_read_byte_reg(tmds, 0x7C, &ceainfo);
@@ -3659,11 +3725,9 @@
 				if (unlikely(ret < 0)) {
 					pr_err("[ERROR] %s() sii8240_discovery_irq_handler\n", __func__);
 					goto err_exit;
-			}
+				}
 			}
 		if (sii8240->state == STATE_MHL_CONNECTED) {
-			sii8240->pdata->vbus_present(false, -1);
-			msleep(100);
 			if (sii8240->pdata->vbus_present)
 				sii8240->pdata->vbus_present(true, 0x03);
 			ret = sii8240_init_regs(sii8240);
@@ -3687,6 +3751,12 @@
 				sii8240->irq_enabled = false;
 				pr_info("sii8240: interrupt disabled\n");
 			}
+		/* If there is VBUS, charging start */
+			if(check_vbus_present()){
+				if (sii8240->pdata->vbus_present)
+					sii8240->pdata->vbus_present(false, 0x03);
+			}
+
 			queue_work(sii8240->cbus_cmd_wqs,
 						 &sii8240->redetect_work);
 		}
@@ -3706,10 +3776,8 @@
 				sii8240->irq_enabled = false;
 				pr_info("sii8240: interrupt disabled\n");
 			}
-			if (sii8240->pdata->vbus_present)
-				sii8240->pdata->vbus_present(false, -1);
-				queue_work(sii8240->cbus_cmd_wqs,
-						 &sii8240->redetect_work);
+			queue_work(sii8240->cbus_cmd_wqs,
+					 &sii8240->redetect_work);
 		}
 		break;
 	case STATE_MHL_DISCOVERY_SUCCESS:
@@ -3724,7 +3792,9 @@
 		/*checking of cbus disconnection*/
 		if (intr1 & BIT_INTR4_CBUS_DISCONNECT) {
 			pr_info("sii8240 : cbus_disconnected\n");
-			sii8240->pdata->vbus_present(false, -1);
+			/* CTS 3.3.22.3 */
+			/* If cbus disconnected, OTG should also be stoped */
+			otg_control(false);
 			mhl_write_byte_reg(hdmi, 0x80, 0xD0);
 			pr_info("sii8240: CBUS DISCONNECTED !!\n");
 			if (sii8240->irq_enabled) {
@@ -3747,7 +3817,7 @@
 		if (int1_status & BIT_INTR1_HPD_CHG) {
 			ret = mhl_read_byte_reg
 				(tmds, MHL_TX_SYSSTAT_REG, &value);
-				memset(&sii8240->current_aviInfoFrame,
+			memset(&sii8240->current_aviInfoFrame,
 					0x00, INFO_BUFFER);
 			memset(&sii8240->output_avi_data,
 					0x00, SIZE_AVI_INFOFRAME);
@@ -3780,11 +3850,26 @@
 					BIT_HPD_CTRL_HPD_OUT_OVR_EN_MASK,
 					BIT_HPD_CTRL_HPD_OUT_OVR_VAL_OFF |
 					BIT_HPD_CTRL_HPD_OUT_OVR_EN_ON);
-
-				sii8240->regs.intr_masks.intr5_mask_value
-						= 0x00;
-					ret = mhl_write_byte_reg
-						(tmds, 0x78, 0x00);
+					if (unlikely(ret < 0)) {
+						pr_err("[ERROR] sii8240: %s():%d failed\n",
+								__func__, __LINE__);
+						goto err_exit;
+					}
+					sii8240->regs.intr_masks.intr5_mask_value = 0x00;
+					ret = mhl_write_byte_reg(tmds, 0x78, 0x00);
+					if (unlikely(ret < 0)) {
+						pr_err("[ERROR] sii8240: %s():%d failed\n",
+								__func__, __LINE__);
+						goto err_exit;
+					}
+					ret = mhl_modify_reg(hdmi, 0xA1,
+							BIT_REG_RX_HDMI_CTRL0_hdmi_mode_overwrite_MASK,
+							BIT_REG_RX_HDMI_CTRL0_hdmi_mode_overwrite_HW_CTRL);
+					if (unlikely(ret < 0)) {
+						pr_err("[ERROR] sii8240: %s():%d failed\n",
+								__func__, __LINE__);
+						goto err_exit;
+					}
 				}
 			}
 		}
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl_v2/sii8240_driver.h msm/mhl_v2/sii8240_driver.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mhl_v2/sii8240_driver.h	2013-12-17 17:08:08.026147338 -0800
+++ msm/mhl_v2/sii8240_driver.h	2013-12-11 02:38:33.000000000 -0800
@@ -28,6 +28,7 @@
 #include "sii8240_rcp.h"
 #include <linux/timer.h>
 #include <linux/switch.h>
+#include <video/msm_hdmi_modes.h>
 #undef MHL_2X_3D
 /* for factory test process */
 #define CONFIG_SS_FACTORY
@@ -210,8 +211,8 @@
  * while sending SET_INT, use these Offset[0x21...0x23]. */
 
 /* 0xC8: CBUS Device Capability Registers */
-#define MHL_VER_MAJOR			(1<<1) /* Most Significant 4-bits */
-#define MHL_VER_MINOR			(0<<0) /* Least significant 4-bits */
+#define MHL_VER_MAJOR			(CONFIG_MHL_VERSION >> 4)/* Most Significant 4-bits */
+#define MHL_VER_MINOR			(CONFIG_MHL_VERSION & 0x0F) /* Least significant 4-bits */
 
 #define DEV_TYPE_SOURCE			0x02
 #define DEV_TYPE_SINK			0x01
@@ -950,8 +951,8 @@
 };
 
 struct mhl_timing {
-	u8 avi_infoframe[60];
-	u8 d_format[60];
+	u8 avi_infoframe[HDMI_VFRMT_MAX];
+	u8 d_format[HDMI_VFRMT_MAX];
 };
 struct sii8240_data;
 struct sii8240_data {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_dsi.c msm/mipi_dsi.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_dsi.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_dsi.c	2013-12-11 02:38:33.000000000 -0800
@@ -87,7 +87,7 @@
 		down(&mfd->dma->mutex);
 
 	if (mfd->panel_info.type == MIPI_CMD_PANEL) {
-		mipi_dsi_prepare_ahb_clocks();
+		mipi_dsi_prepare_clocks();
 		mipi_dsi_ahb_ctrl(1);
 		mipi_dsi_clk_enable();
 
@@ -131,7 +131,6 @@
 	spin_unlock_bh(&dsi_clk_lock);
 
 	mipi_dsi_unprepare_clocks();
-	mipi_dsi_unprepare_ahb_clocks();
 
 	usleep(5000);
 
@@ -143,7 +142,6 @@
 	if (mipi_dsi_pdata && mipi_dsi_pdata->panel_power_save)
 		mipi_dsi_pdata->panel_power_save(0);
 
-
 	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_power_save)
 		mipi_dsi_pdata->dsi_power_save(0);
 
@@ -171,9 +169,6 @@
 	u32 dummy_xres, dummy_yres;
 	int target_type = 0;
 	u32 tmp;
-#if defined(CONFIG_FB_MSM_MIPI_RENESAS_TFT_VIDEO_FULL_HD_PT_PANEL)
-	static int is_booting = 1;
-#endif
 
 	pr_debug("%s+:\n", __func__);
 
@@ -184,37 +179,12 @@
 	fbi = mfd->fbi;
 	var = &fbi->var;
 	pinfo = &mfd->panel_info;
+	esc_byte_ratio = pinfo->mipi.esc_byte_ratio;
 
 	if (mipi_dsi_pdata && mipi_dsi_pdata->power_common)
 		mipi_dsi_pdata->power_common();
 
 #if defined(CONFIG_SUPPORT_SECOND_POWER)
-#if defined(CONFIG_FB_MSM_MIPI_RENESAS_TFT_VIDEO_FULL_HD_PT_PANEL)
-	if( is_booting == 1 )
-	{
-		is_booting = 0;
-#if defined(CONFIG_MACH_JACTIVE_ATT)
-		usleep(5000);
-		if (mipi_dsi_pdata && mipi_dsi_pdata->active_reset)
-				mipi_dsi_pdata->active_reset(0); /* low */
-		usleep(2000);
-
-		if (mipi_dsi_pdata && mipi_dsi_pdata->panel_power_save)
-			mipi_dsi_pdata->panel_power_save(0);
-		msleep(10);
-#elif defined(CONFIG_MACH_JACTIVE_EUR)
-		usleep(5000);
-		if (mipi_dsi_pdata && mipi_dsi_pdata->active_reset)
-				mipi_dsi_pdata->active_reset(0); /* low */
-		usleep(2000);
-
-		if (mipi_dsi_pdata && mipi_dsi_pdata->panel_power_save)
-			mipi_dsi_pdata->panel_power_save(0);
-		msleep(10);
-#endif
-	}
-#endif
-
 	if (mipi_dsi_pdata && mipi_dsi_pdata->panel_power_save)
 		mipi_dsi_pdata->panel_power_save(1);
 #endif
@@ -226,7 +196,7 @@
 		mipi_dsi_pdata->dsi_power_save(1);
 
 	cont_splash_clk_ctrl(0);
-	mipi_dsi_prepare_ahb_clocks();
+	mipi_dsi_prepare_clocks();
 
 	mipi_dsi_ahb_ctrl(1);
 
@@ -389,9 +359,8 @@
 			mipi_dsi_set_tear_on(mfd);
 		}
 		mipi_dsi_clk_disable();
-		mipi_dsi_unprepare_clocks();
 		mipi_dsi_ahb_ctrl(0);
-		mipi_dsi_unprepare_ahb_clocks();
+		mipi_dsi_unprepare_clocks();
 	}
 
 	if (mdp_rev >= MDP_REV_41)
@@ -557,16 +526,15 @@
 
 		if (mipi_dsi_clk_init(pdev))
 			return -EPERM;
+		mipi_dsi_prepare_clocks();
 
 		if (mipi_dsi_pdata->splash_is_enabled &&
 			!mipi_dsi_pdata->splash_is_enabled()) {
-			mipi_dsi_prepare_ahb_clocks();
 			mipi_dsi_ahb_ctrl(1);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x118, 0);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x0, 0);
 			MIPI_OUTP(MIPI_DSI_BASE + 0x200, 0);
 			mipi_dsi_ahb_ctrl(0);
-			mipi_dsi_unprepare_ahb_clocks();
 		}
 		mipi_dsi_resource_initialized = 1;
 
@@ -730,8 +698,6 @@
 
 	pdev_list[pdev_list_cnt++] = pdev;
 
-	esc_byte_ratio = pinfo->mipi.esc_byte_ratio;
-
 return 0;
 
 mipi_dsi_probe_err:
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_dsi.h msm/mipi_dsi.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_dsi.h	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_dsi.h	2013-12-11 02:38:33.000000000 -0800
@@ -330,6 +330,8 @@
 void mipi_dsi_set_tear_off(struct msm_fb_data_type *mfd);
 void mipi_dsi_set_backlight(struct msm_fb_data_type *mfd, int level);
 void mipi_dsi_cmd_backlight_tx(struct dsi_buf *dp);
+void mipi_dsi_clk_enable(void);
+void mipi_dsi_clk_disable(void);
 void mipi_dsi_pre_kickoff_action(void);
 void mipi_dsi_post_kickoff_action(void);
 void mipi_dsi_pre_kickoff_add(struct dsi_kickoff_action *act);
@@ -343,48 +345,16 @@
 irqreturn_t mipi_dsi_isr(int irq, void *ptr);
 
 void mipi_set_tx_power_mode(int mode);
+void mipi_dsi_phy_ctrl(int on);
 void mipi_dsi_phy_init(int panel_ndx, struct msm_panel_info const *panel_info,
 	int target_type);
 int mipi_dsi_clk_div_config(uint8 bpp, uint8 lanes,
 			    uint32 *expected_dsi_pclk);
 int mipi_dsi_clk_init(struct platform_device *pdev);
 void mipi_dsi_clk_deinit(struct device *dev);
-
-#ifdef CONFIG_FB_MSM_MIPI_DSI
-void mipi_dsi_clk_enable(void);
-void mipi_dsi_clk_disable(void);
+void mipi_dsi_prepare_clocks(void);
 void mipi_dsi_unprepare_clocks(void);
-void mipi_dsi_prepare_ahb_clocks(void);
-void mipi_dsi_unprepare_ahb_clocks(void);
 void mipi_dsi_ahb_ctrl(u32 enable);
-void mipi_dsi_phy_ctrl(int on);
-#else
-static inline void mipi_dsi_clk_enable(void)
-{
-	/* empty */
-}
-void mipi_dsi_clk_disable(void)
-{
-	/* empty */
-}
-void mipi_dsi_prepare_clocks(void)
-{
-	/* empty */
-}
-void mipi_dsi_unprepare_clocks(void)
-{
-	/* empty */
-}
-void mipi_dsi_ahb_ctrl(u32 enable)
-{
-	/* empty */
-}
-void mipi_dsi_phy_ctrl(int on)
-{
-	/* empty */
-}
-#endif
-
 void cont_splash_clk_ctrl(int enable);
 void mipi_dsi_turn_on_clks(void);
 void mipi_dsi_turn_off_clks(void);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_dsi_host.c msm/mipi_dsi_host.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_dsi_host.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_dsi_host.c	2013-12-11 02:38:33.000000000 -0800
@@ -58,6 +58,7 @@
 static struct list_head pre_kickoff_list;
 static struct list_head post_kickoff_list;
 
+struct work_struct mdp_reset_work;
 extern struct sec_debug_mdp sec_debug_mdp;
 
 void mipi_dsi_configure_dividers(int fps);
@@ -107,6 +108,11 @@
 }
 #endif
 
+static void mdp_reset_wq_handler(struct work_struct *work)
+{
+	mdp4_mixer_reset(0);
+}
+
 void mipi_dsi_init(void)
 {
 	init_completion(&dsi_dma_comp);
@@ -119,6 +125,7 @@
 	spin_lock_init(&dsi_clk_lock);
 	mutex_init(&cmd_mutex);
 	mutex_init(&clk_mutex);
+	INIT_WORK(&mdp_reset_work, mdp_reset_wq_handler);
 
 	INIT_LIST_HEAD(&pre_kickoff_list);
 	INIT_LIST_HEAD(&post_kickoff_list);
@@ -195,7 +202,7 @@
 	mutex_lock(&clk_mutex);
 	if (on) {
 		if (dsi_clk_cnt == 0) {
-			mipi_dsi_prepare_ahb_clocks();
+			mipi_dsi_prepare_clocks();
 			mipi_dsi_ahb_ctrl(1);
 			mipi_dsi_clk_enable();
 		}
@@ -205,9 +212,8 @@
 			dsi_clk_cnt--;
 			if (dsi_clk_cnt == 0) {
 				mipi_dsi_clk_disable();
-				mipi_dsi_unprepare_clocks();
 				mipi_dsi_ahb_ctrl(0);
-				mipi_dsi_unprepare_ahb_clocks();
+				mipi_dsi_unprepare_clocks();
 			}
 		}
 	}
@@ -218,7 +224,6 @@
 
 void mipi_dsi_turn_on_clks(void)
 {
-	mipi_dsi_prepare_ahb_clocks();
 	mipi_dsi_ahb_ctrl(1);
 	mipi_dsi_clk_enable();
 }
@@ -226,9 +231,7 @@
 void mipi_dsi_turn_off_clks(void)
 {
 	mipi_dsi_clk_disable();
-	mipi_dsi_unprepare_clocks();
 	mipi_dsi_ahb_ctrl(0);
-	mipi_dsi_unprepare_ahb_clocks();
 }
 
 static void mipi_dsi_action(struct list_head *act_list)
@@ -1040,7 +1043,8 @@
 	dsi_ctrl &= ~0x07;
 	if (mode == DSI_VIDEO_MODE) {
 		dsi_ctrl |= 0x03;
-		intr_ctrl = DSI_INTR_CMD_DMA_DONE_MASK;
+		intr_ctrl = (DSI_INTR_CMD_DMA_DONE_MASK |
+					DSI_INTR_VIDEO_DONE_MASK);
 	} else {		/* command mode */
 		dsi_ctrl |= 0x05;
 		intr_ctrl = DSI_INTR_CMD_DMA_DONE_MASK | DSI_INTR_ERROR_MASK |
@@ -1231,6 +1235,10 @@
 	int i, j = 0, k = 0, cmd_len = 0, video_mode;
 	char *cmds_tx;
 	char *bp;
+	if (tp == NULL || cmds == NULL) {
+		pr_err("%s: Null commands", __func__);
+		return -EINVAL;
+	}
 	pr_debug("%s:++\n",__func__);
 
 	/*Set Last Bit, only for last packet */
@@ -1677,9 +1685,7 @@
 		pr_err("%s: dma timeout error\n", __func__);
 		dumpreg(0);
 		dumstate(0);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.mipi_tx_time_out_err_cnt++;
-#endif
 		mdp4_dump_regs();
 		dsi_clk_dump();
 		console_verbose();
@@ -1914,9 +1920,12 @@
 
 	if (status) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0064, status);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.mipi_dsi_ack_err_status = status;
-#endif
+		/*
+		 * base on hw enginner, write an extra 0 needed
+		 * to clear error bits
+		 */
+		MIPI_OUTP(MIPI_DSI_BASE + 0x0064, ~status);
 		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
@@ -1928,9 +1937,7 @@
 	status = MIPI_INP(MIPI_DSI_BASE + 0x00bc);/* DSI_TIMEOUT_STATUS */
 	if (status & 0x0111) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x00bc, status);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.mipi_dsi_timeout_status = status;
-#endif
 		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
@@ -1943,9 +1950,7 @@
 
 	if (status & 0x011111) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x00b0, status);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.mipi_dsi_dln0_phy_err = status;
-#endif
 		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
@@ -1958,10 +1963,10 @@
 
 	if (status & 0x44444489) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0008, status);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.mipi_dsi_fifo_status = status;
-#endif
-		pr_debug("%s: status=%x\n", __func__, status);
+		pr_err("%s: Error: status=%x\n", __func__, status);
+		mipi_dsi_sw_reset();
+		schedule_work(&mdp_reset_work);
 	}
 }
 
@@ -1973,9 +1978,7 @@
 
 	if (status & 0x80000000) {
 		MIPI_OUTP(MIPI_DSI_BASE + 0x0004, status);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.mipi_dsi_status = status;
-#endif
 		pr_debug("%s: status=%x\n", __func__, status);
 	}
 }
@@ -2012,9 +2015,7 @@
 
 	if (!rc) {
 		pr_err("%s: dma timeout error\n", __func__);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.fps_chage_time_out_err_cnt++;
-#endif
 	}
 		
 	mutex_unlock(&fps_done_mutex);
@@ -2051,9 +2052,7 @@
 
 	if (!rc) {
 		pr_err("%s: dma timeout error\n", __func__);
-#ifdef CONFIG_SEC_DEBUG_MDP
 		sec_debug_mdp.dsi_err.fps_chage_time_out_err_cnt++;
-#endif
 	}
 		
 	mutex_unlock(&fps_done_mutex);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_lgit_video_wxga_pt.c msm/mipi_lgit_video_wxga_pt.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_lgit_video_wxga_pt.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_lgit_video_wxga_pt.c	2013-12-11 02:38:33.000000000 -0800
@@ -68,7 +68,6 @@
 	pinfo.bl_max = 0x72;
 	pinfo.bl_min = 0x02;
 	pinfo.fb_num = 2;
-	pinfo.lcd.blt_ctrl = 1;
 
 	pinfo.mipi.mode = DSI_VIDEO_MODE;
 	pinfo.mipi.pulse_mode_hsa_he = FALSE;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_novatek.c msm/mipi_novatek.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_novatek.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_novatek.c	2013-12-11 02:38:33.000000000 -0800
@@ -465,6 +465,12 @@
 {
 	struct dcs_cmd_req cmdreq;
 
+	if (mipi_novatek_pdata &&
+	    mipi_novatek_pdata->gpio_set_backlight) {
+		mipi_novatek_pdata->gpio_set_backlight(mfd->bl_level);
+		return;
+	}
+
 	if ((mipi_novatek_pdata->enable_wled_bl_ctrl)
 	    && (wled_trigger_initialized)) {
 		led_trigger_event(bkl_led_trigger, mfd->bl_level);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_novatek_cmd_qhd_pt.c msm/mipi_novatek_cmd_qhd_pt.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_novatek_cmd_qhd_pt.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_novatek_cmd_qhd_pt.c	2013-12-11 02:38:33.000000000 -0800
@@ -64,7 +64,7 @@
 	pinfo.is_3d_panel = FB_TYPE_3D_PANEL;
 	pinfo.lcd.vsync_enable = TRUE;
 	pinfo.lcd.hw_vsync_mode = TRUE;
-	pinfo.lcd.refx100 = 6000; /* adjust refx100 to prevent tearing */
+	pinfo.lcd.refx100 = 6200; /* adjust refx100 to prevent tearing */
 	pinfo.lcd.v_back_porch = 11;
 	pinfo.lcd.v_front_porch = 10;
 	pinfo.lcd.v_pulse_width = 5;
Only in msm: mipi_NT35590.c
Only in msm: mipi_NT35590_cmd_720p_pt.c
Only in msm: mipi_NT35590.h
Only in msm: mipi_NT35590_video_720p_pt.c
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_renesas_tft_video_full_hd_pt.c msm/mipi_renesas_tft_video_full_hd_pt.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_renesas_tft_video_full_hd_pt.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_renesas_tft_video_full_hd_pt.c	2013-12-11 02:38:33.000000000 -0800
@@ -22,7 +22,7 @@
 enum {
 	GAMMA_0CD	=	1,
 	GAMMA_5CD	=	2,
-	GAMMA_10CD	=	3, // MIN 10 from platform
+	GAMMA_10CD	=	4, // MIN 10 from platform
 	GAMMA_15CD	=	7,
 	GAMMA_20CD	=	10,
 	GAMMA_25CD	=	13,
@@ -121,23 +121,43 @@
 	0x2C,
 };
 
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
 static char renesas_teon_control[] = {
 	0x35,
 	0x01,
 };
 
-static char renesas_teoff_control[] = {
-	0x35,
-	0x00,
-};
-#endif
-
 static char renesas_memory_access_control[] = {
 	0x36,
 	0xC0,
 };
 
+static char renesas_F0_control[] = {
+	0xF0,
+	0x5A,0x5A,
+};
+
+static char renesas_FA_control[] = {
+	0xFA,
+	0x18,0x3F,0x0A,0x08,0x0D,0x0E,0x0E,0x10,0x11,0x11,
+	0x10,0x0C,0x08,0x07,0x0A,0x0E,0x16,0x16,0x15,0x13,
+	0x0F,0x02,0x02,0x0F,0x3F,0x0C,0x0D,0x12,0x15,0x16,
+	0x18,0x1A,0x19,0x18,0x13,0x0D,0x0A,0x0C,0x10,0x17,
+	0x17,0x16,0x13,0x0F,0x03,0x03,0x00,0x3F,0x0F,0x11,
+	0x19,0x1D,0x20,0x22,0x24,0x23,0x22,0x1C,0x14,0x10,
+	0x12,0x15,0x1B,0x1A,0x18,0x15,0x10,0x05,0x06,
+};
+
+static char renesas_FB_control[] = {
+	0xFB,
+	0x18,0x3F,0x0A,0x08,0x0D,0x0E,0x0E,0x10,0x11,0x11,
+	0x10,0x0C,0x08,0x07,0x0A,0x0E,0x16,0x16,0x15,0x13,
+	0x0F,0x02,0x02,0x0F,0x3F,0x0C,0x0D,0x12,0x15,0x16,
+	0x18,0x1A,0x19,0x18,0x13,0x0D,0x0A,0x0C,0x10,0x17,
+	0x17,0x16,0x13,0x0F,0x03,0x03,0x00,0x3F,0x0F,0x11,
+	0x19,0x1D,0x20,0x22,0x24,0x23,0x22,0x1C,0x14,0x10,
+	0x12,0x15,0x1B,0x1A,0x18,0x15,0x10,0x05,0x06,
+};
+
 static char renesas_display_on[] = { 0x29, /* no param */ };
 static char renesas_display_off[] = { 0x28, /* no param */ };
 static char renesas_sleep_in[] = { 0x10, /* no param */ };
@@ -153,21 +173,23 @@
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(renesas_backlight_control), renesas_backlight_control},
 
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(renesas_teon_control), renesas_teon_control},
-#endif
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 120,
 		sizeof(renesas_sleep_out), renesas_sleep_out},
 
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(renesas_F0_control), renesas_F0_control},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(renesas_FA_control), renesas_FA_control},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(renesas_FB_control), renesas_FB_control},
+
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(renesas_display_on), renesas_display_on},
 };
 
 static struct dsi_cmd_desc panel_off_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 40,  sizeof(renesas_display_off), renesas_display_off},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 120, sizeof(renesas_sleep_in), renesas_sleep_in},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
+		sizeof(renesas_display_off), renesas_display_off},
 };
 
 static struct dsi_cmd_desc panel_late_on_cmds[] = {
@@ -219,17 +241,6 @@
 };
 #endif
 
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
-static struct dsi_cmd_desc panel_hsync_on_cmds[] = {
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0,
-		sizeof(renesas_teon_control), renesas_teon_control},
-};
-
-static struct dsi_cmd_desc panel_hsync_off_cmds[] = {
-	{DTYPE_GEN_LWRITE, 1, 0, 0, 0,
-		sizeof(renesas_teoff_control), renesas_teoff_control},
-};
-#endif
 static int get_candela_index(int bl_level)
 {
 	int backlightlevel;
@@ -451,12 +462,6 @@
 	.cabc_disable	= {panel_cabc_disable_cmds
 				, ARRAY_SIZE(panel_cabc_disable_cmds)},
 #endif
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
-	.hsync_on = {panel_hsync_on_cmds
-				, ARRAY_SIZE(panel_hsync_on_cmds)},
-	.hsync_off	= {panel_hsync_off_cmds
-				, ARRAY_SIZE(panel_hsync_off_cmds)},
-#endif
 };
 
 static struct mipi_dsi_phy_ctrl dsi_video_mode_phy_db = {
@@ -464,8 +469,8 @@
 	/* regulator */
 	.regulator = {0x03, 0x0a, 0x04, 0x00, 0x20},
 	/* timing */
-	.timing = {0x5C, 0x37, 0x39, 0x00, 0x62, 0x57, 0x3B, 0x3B,
-	0x44, 0x03, 0x04, 0xa0},
+	.timing = {0xD9, 0x40, 0x3C, 0x00, 0x52, 0x5E, 0x32, 0x40,
+	0x3C, 0x03, 0x04, 0xa0},
 	/* phy ctrl */
 	.ctrl = {0x5f, 0x00, 0x00, 0x10},
 	/* strength */
@@ -522,7 +527,7 @@
 	pinfo.bl_min = 1;
 	pinfo.fb_num = 2;
 
-	pinfo.clk_rate = 906000000;
+	pinfo.clk_rate = 898000000;
 
 	pinfo.mipi.mode = DSI_VIDEO_MODE;
 	pinfo.mipi.pulse_mode_hsa_he = FALSE;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_octa.c msm/mipi_samsung_octa.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_octa.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_samsung_octa.c	2013-12-11 02:38:33.000000000 -0800
@@ -50,8 +50,6 @@
 static int lcd_attached = 1;
 struct mutex dsi_tx_mutex;
 int touch_display_status;
-static int panel_colors = 2;
-extern void panel_load_colors(unsigned int value, struct SMART_DIM *pSmart);
 DEFINE_MUTEX(brightness_mutex);
 
 #if defined(RUMTIME_MIPI_CLK_CHANGE)
@@ -98,6 +96,7 @@
 		if (lock)
 			mutex_lock(&mfd->dma->ov_mutex);
 	}
+	cmdreq.flags =	CMD_REQ_COMMIT;
 
 		switch (cmd) {
 		case PANEL_ON:
@@ -119,6 +118,7 @@
 		case PANEL_BRIGHT_CTRL:
 			cmd_desc = msd.mpd->brightness.cmd;
 			cmd_size = msd.mpd->brightness.size;
+			cmdreq.flags =  CMD_REQ_SINGLE_TX |CMD_REQ_COMMIT;
 			break;
 		case PANEL_MTP_ENABLE:
 			cmd_desc = msd.mpd->mtp_enable.cmd;
@@ -168,7 +168,6 @@
 
 	cmdreq.cmds = cmd_desc;
 	cmdreq.cmds_cnt = cmd_size;
-	cmdreq.flags = CMD_REQ_COMMIT;
 	cmdreq.rlen = 0;
 	cmdreq.cb = NULL;
 
@@ -1131,32 +1130,6 @@
 	return size;
 }
 
-static ssize_t panel_colors_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", panel_colors);
-}
-
-static ssize_t panel_colors_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	int ret;
-	unsigned int value;
-
-	ret = sscanf(buf, "%d\n", &value);
-	if (ret != 1)
-		return -EINVAL;
-
-	if (value < 0)
-		value = 0;
-	else if (value > 4)
-		value = 4;
-
-	panel_colors = value;
-
-	panel_load_colors(panel_colors, &(msd.mpd->smart_se6e8fa));
-
-	return size;
-}
-
 static DEVICE_ATTR(lcd_power, S_IRUGO | S_IWUSR,
 		mipi_samsung_disp_get_power,
 		mipi_samsung_disp_set_power);
@@ -1189,9 +1162,6 @@
 			mipi_samsung_temperature_show,
 			mipi_samsung_temperature_store);
 
-static DEVICE_ATTR(panel_colors, S_IRUGO | S_IWUSR | S_IWGRP,
-			panel_colors_show, panel_colors_store);
-
 #ifdef DDI_VIDEO_ENHANCE_TUNING
 #define MAX_FILE_NAME 128
 #define TUNING_FILE_PATH "/sdcard/"
@@ -1518,13 +1488,6 @@
 				dev_attr_temperature.attr.name);
 	}
 
-	ret = sysfs_create_file(&lcd_device->dev.kobj,
-						&dev_attr_panel_colors.attr);
-	if (ret) {
-		pr_info("sysfs create fail-%s\n",
-				dev_attr_panel_colors.attr.name);
-	}
-
 	printk(KERN_INFO "[lcd] backlight_device_register for panel start\n");
 
 	bd = backlight_device_register("panel", &lcd_device->dev,
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_octa_video_full_hd_pt.c msm/mipi_samsung_octa_video_full_hd_pt.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_octa_video_full_hd_pt.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_samsung_octa_video_full_hd_pt.c	2013-12-11 02:38:33.000000000 -0800
@@ -42,11 +42,6 @@
 	0x5A, 0x5A,
 };
 
-static char samsung_test_key_on2[] = {
-	0xF1,
-	0x5A, 0x5A,
-};
-
 static char samsung_test_key_on3[] = {
 	0xFC,
 	0x5A, 0x5A,
@@ -654,8 +649,6 @@
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
@@ -729,8 +722,6 @@
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
@@ -808,8 +799,6 @@
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
@@ -853,8 +842,6 @@
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
@@ -902,8 +889,6 @@
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
@@ -960,8 +945,6 @@
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
 
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_touchkey_off_revH), samsung_touchkey_off_revH},
@@ -1037,10 +1020,6 @@
 static struct dsi_cmd_desc panel_mtp_enable_cmds[] = {
 	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
 		sizeof(samsung_test_key_on1), samsung_test_key_on1},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on2), samsung_test_key_on2},
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 0,
-		sizeof(samsung_test_key_on3), samsung_test_key_on3},
 };
 
 static struct dsi_cmd_desc panel_mtp_disable_cmds[] = {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_tft.c msm/mipi_samsung_tft.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_tft.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_samsung_tft.c	2013-12-11 02:38:33.000000000 -0800
@@ -133,16 +133,6 @@
 			cmd_size = msd.mpd->cabc_disable.size;
 			break;
 #endif
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
-		case PANEL_HSYNC_ON:
-			cmd_desc = msd.mpd->hsync_on.cmd;
-			cmd_size = msd.mpd->hsync_on.size;
-			break;
-		case PANEL_HSYNC_OFF:
-			cmd_desc = msd.mpd->hsync_off.cmd;
-			cmd_size = msd.mpd->hsync_off.size;
-			break;
-#endif
 		default:
 			goto unknown_command;
 			;
@@ -178,43 +168,6 @@
 	return 0;
 }
 
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
-void lcd_hsync_onoff(bool onoff)
-{
-	struct msm_fb_data_type *mfd;
-	mfd = platform_get_drvdata(msd.msm_pdev);
-
-	if (unlikely(!mfd)) { pr_err("%s : panel no mfd",__func__); return;}
-//		return -ENODEV;
-	if (unlikely(mfd->key != MFD_KEY)) { pr_err("%s : panel mfd invlaid",__func__); return;}
-//		return -EINVAL;
-
-#if defined(CONFIG_MACH_JACTIVE_EUR) /* HW DEFECT under REV 0.5 */
-	if( system_rev > 15 )
-		return;
-#endif
-
-	if (mfd->panel_power_on == TRUE)
-		{ 
-			if( onoff )
-				{
-				msleep(30);
-				mipi_samsung_disp_send_cmd(mfd, PANEL_HSYNC_ON, true);
-				pr_info("%s : HSYNC On\n",__func__);
-				}
-			else
-				{
-				mipi_samsung_disp_send_cmd(mfd, PANEL_HSYNC_OFF, true);
-				msleep(10); /* Need time to discharging by capacitance*/
-				pr_info("%s : HSYNC Off\n",__func__);
-				}
-		}
-	else
-		pr_err("%s : panel power off\n",__func__);
-	
-return;
-}
-#endif
 static char manufacture_id1[2] = {0xDA, 0x00}; /* DTYPE_DCS_READ */
 static char manufacture_id2[2] = {0xDB, 0x00}; /* DTYPE_DCS_READ */
 static char manufacture_id3[2] = {0xDC, 0x00}; /* DTYPE_DCS_READ */
@@ -289,50 +242,6 @@
 	mipi_samsung_disp_send_cmd(mfd, PANEL_MTP_DISABLE, false);
 }
 
-static int mipi_samsung_disp_on_in_video_engine(struct platform_device *pdev)
-{
-	struct msm_fb_data_type *mfd;
-
-	printk(KERN_INFO "[lcd] mipi_samsung_disp_on_in_video_engine start\n" );
-
-	mfd = platform_get_drvdata(pdev);
-	if (unlikely(!mfd))
-		return -ENODEV;
-	if (unlikely(mfd->key != MFD_KEY))
-		return -EINVAL;
-
-	mipi_samsung_disp_send_cmd(mfd, PANEL_ON, false);
-	mfd->resume_state = MIPI_RESUME_STATE;
-
-#if defined(RUMTIME_MIPI_CLK_CHANGE)
-	current_fps = mfd->panel_info.mipi.frame_rate;
-#endif
-	
-#if defined(AUTO_BRIGHTNESS_CABC_FUNCTION)
-	is_disp_on = 1;
-
-	if( is_cabc_on() == true )
-	{
-		mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_ENABLE, false);
-		is_cabc_delayed = 0;
-		printk ( KERN_ERR "%s-PANEL_CABC_ENABLE(keystring)\n", __func__ );
-	}
-	else if( (is_cabc_on() != false) && ((is_cabc_delayed == 1) || (msd.mpd->siop_status == true)) )
-	{
-		mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_ENABLE, false);
-		is_cabc_delayed = 0;
-		printk ( KERN_ERR "%s-PANEL_CABC_ENABLE(delayed)\n", __func__ );
-	}
-#endif
-	
-	printk(KERN_INFO "[lcd] mipi_samsung_disp_on_in_video_engine end %d\n", gpio_get_value(err_fg_gpio));
-	
-#if defined(CONFIG_ESD_ERR_FG_RECOVERY)
-		enable_irq(PM8921_GPIO_IRQ(PM8921_IRQ_BASE, PMIC_GPIO_ERR_FG));
-#endif
-
-	return 0;
-}
 
 static int mipi_samsung_disp_on(struct platform_device *pdev)
 {
@@ -362,8 +271,37 @@
 						PANEL_NEED_FLIP, false);
 	}
 
-	printk(KERN_INFO "[lcd] mipi_samsung_disp_on end\n" );
+	mipi_samsung_disp_send_cmd(mfd, PANEL_ON, false);
+	mfd->resume_state = MIPI_RESUME_STATE;
+
+#if	defined(CONFIG_MDNIE_LITE_TUNING)
+	if (!first_boot_on)
+	{
+		mfd->resume_state = MIPI_RESUME_STATE;
+		first_boot_on = 1;
+	}
+#endif
+
+#if defined(RUMTIME_MIPI_CLK_CHANGE)
+	current_fps = mfd->panel_info.mipi.frame_rate;
+#endif
+
+#if defined(AUTO_BRIGHTNESS_CABC_FUNCTION)
+	is_disp_on = 1;
+
+	if( (is_cabc_delayed == 1) || (msd.mpd->siop_status == true) )
+	{
+		mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_ENABLE, false);
+		is_cabc_delayed = 0;
+		printk ( KERN_ERR "%s-PANEL_CABC_ENABLE(delayed)\n", __func__ );
+	}
+#endif
+
+	printk(KERN_INFO "[lcd] mipi_samsung_disp_on end %d\n", gpio_get_value(err_fg_gpio));
 
+#if defined(CONFIG_ESD_ERR_FG_RECOVERY)
+	enable_irq(PM8921_GPIO_IRQ(PM8921_IRQ_BASE, PMIC_GPIO_ERR_FG));
+#endif
 	return 0;
 }
 
@@ -402,33 +340,22 @@
 static void __devinit mipi_samsung_disp_shutdown(struct platform_device *pdev)
 {
 	static struct mipi_dsi_platform_data *mipi_dsi_pdata = NULL;
-	struct msm_fb_data_type *mfd = NULL;
 
 	if (pdev->id != 0)
 		return;
 
-	mfd = platform_get_drvdata(msd.msm_pdev);
-	if (unlikely(!mfd))
-		return;
-
 	mipi_dsi_pdata = pdev->dev.platform_data;
 	if (mipi_dsi_pdata == NULL) {
 		pr_err("LCD Power off failure: No Platform Data\n");
 		return;
 	}
 
-	mfd->resume_state = MIPI_SUSPEND_STATE;
-	mipi_samsung_disp_send_cmd(mfd, PANEL_OFF, false);
 
 	if (mipi_dsi_pdata && mipi_dsi_pdata->active_reset)
 		mipi_dsi_pdata->active_reset(0); /* low */
 
 	usleep(2000); /*1ms delay(minimum) required between reset low and AVDD off*/
 
-#if defined(CONFIG_MACH_JACTIVE_EUR)
-	msleep ( 10 ); // need more delay for POWER OFF SIGNAL
-#endif
-
 	if (mipi_dsi_pdata && mipi_dsi_pdata->panel_power_save)
 		mipi_dsi_pdata->panel_power_save(0);
 
@@ -545,23 +472,13 @@
 	{
 		if( enable )
 		{
-			if( is_cabc_on() != false )
-			{
-				mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_ENABLE, false);
-				printk ( KERN_ERR "@@@@@%s-PANEL_CABC_ENABLE\n", __func__ );
-			}
-			else
-				printk ( KERN_ERR "@@@@@%s-CABC KEYSTRING is OFF, so skip ENABLE\n", __func__ );
+			mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_ENABLE, false);
+			printk ( KERN_ERR "@@@@@%s-PANEL_CABC_ENABLE\n", __func__ );
 		}
 		else
 		{
-			if( is_cabc_on() != true )
-			{
-				mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_DISABLE, false);
-				printk ( KERN_ERR "@@@@@%s-PANEL_CABC_DISABLE\n", __func__ );
-			}
-			else
-				printk ( KERN_ERR "@@@@@%s-CABC KEYSTRING is ON, so skip DISABLE\n", __func__ );
+			mipi_samsung_disp_send_cmd(mfd, PANEL_CABC_DISABLE, false);
+			printk ( KERN_ERR "@@@@@%s-PANEL_CABC_DISABLE\n", __func__ );
 		}
 	}
 
@@ -1208,7 +1125,6 @@
 };
 
 static struct msm_fb_panel_data samsung_panel_data = {
-	.late_init = mipi_samsung_disp_on_in_video_engine,
 	.on		= mipi_samsung_disp_on,
 	.off		= mipi_samsung_disp_off,
 	.set_backlight	= mipi_samsung_disp_backlight,
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_tft.h msm/mipi_samsung_tft.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_samsung_tft.h	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_samsung_tft.h	2013-12-11 02:38:33.000000000 -0800
@@ -50,10 +50,6 @@
 	PANEL_CABC_ENABLE,
 	PANEL_CABC_DISABLE,
 #endif
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
-	PANEL_HSYNC_ON,
-	PANEL_HSYNC_OFF,
-#endif
 };
 
 enum {
@@ -99,10 +95,6 @@
 	struct cmd_set cabc_enable;
 	struct cmd_set cabc_disable;
 #endif
-#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_PREVENT_HSYNC_LEAKAGE)
-	struct cmd_set hsync_on;
-	struct cmd_set hsync_off;
-#endif
 
 	unsigned int manufacture_id;
 	struct mipi_samsung_driver_data *msd;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_toshiba.c msm/mipi_toshiba.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/mipi_toshiba.c	2013-12-17 17:08:08.026147338 -0800
+++ msm/mipi_toshiba.c	2013-12-11 02:38:33.000000000 -0800
@@ -184,6 +184,7 @@
 static int mipi_toshiba_lcd_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
+	struct dcs_cmd_req cmdreq;
 
 	mfd = platform_get_drvdata(pdev);
 
@@ -192,24 +193,36 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WVGA_PT)
-		mipi_dsi_cmds_tx(&toshiba_tx_buf,
-			toshiba_wvga_display_on_cmds,
-			ARRAY_SIZE(toshiba_wvga_display_on_cmds));
-	else if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WSVGA_PT ||
-		TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WUXGA)
-		mipi_dsi_cmds_tx(&toshiba_tx_buf,
-			toshiba_wsvga_display_on_cmds,
-			ARRAY_SIZE(toshiba_wsvga_display_on_cmds));
-	else
+	if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WVGA_PT) {
+		cmdreq.cmds = toshiba_wvga_display_on_cmds;
+		cmdreq.cmds_cnt = ARRAY_SIZE(toshiba_wvga_display_on_cmds);
+		cmdreq.flags = CMD_REQ_COMMIT;
+		cmdreq.rlen = 0;
+		cmdreq.cb = NULL;
+		mipi_dsi_cmdlist_put(&cmdreq);
+	} else if (TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WSVGA_PT ||
+		TM_GET_PID(mfd->panel.id) == MIPI_DSI_PANEL_WUXGA) {
+		cmdreq.cmds = toshiba_wsvga_display_on_cmds;
+		cmdreq.cmds_cnt = ARRAY_SIZE(toshiba_wsvga_display_on_cmds);
+		cmdreq.flags = CMD_REQ_COMMIT;
+		cmdreq.rlen = 0;
+		cmdreq.cb = NULL;
+		mipi_dsi_cmdlist_put(&cmdreq);
+	} else
 		return -EINVAL;
 
 	return 0;
 }
 
+static int mipi_toshiba_early_off(struct platform_device *pdev)
+{
+	return 0;
+}
+
 static int mipi_toshiba_lcd_off(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
+	struct dcs_cmd_req cmdreq;
 
 	mfd = platform_get_drvdata(pdev);
 
@@ -218,9 +231,13 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	mipi_dsi_cmds_tx(&toshiba_tx_buf, toshiba_display_off_cmds,
-			ARRAY_SIZE(toshiba_display_off_cmds));
+	cmdreq.cmds = toshiba_display_off_cmds;
+	cmdreq.cmds_cnt = ARRAY_SIZE(toshiba_display_off_cmds);
+	cmdreq.flags = CMD_REQ_COMMIT;
+	cmdreq.rlen = 0;
+	cmdreq.cb = NULL;
 
+	mipi_dsi_cmdlist_put(&cmdreq);
 	return 0;
 }
 
@@ -302,6 +319,7 @@
 	.on		= mipi_toshiba_lcd_on,
 	.off		= mipi_toshiba_lcd_off,
 	.late_init	= mipi_toshiba_lcd_late_init,
+	.early_off	= mipi_toshiba_early_off,
 	.set_backlight  = mipi_toshiba_set_backlight,
 };
 
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_dss_io_8960.c msm/msm_dss_io_8960.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_dss_io_8960.c	2013-12-17 17:08:08.030147333 -0800
+++ msm/msm_dss_io_8960.c	2013-12-11 02:38:33.000000000 -0800
@@ -678,12 +678,6 @@
 {
 	static int cont_splash_clks_enabled;
 	if (enable && !cont_splash_clks_enabled) {
-		if (clk_set_rate(dsi_byte_div_clk, 1) < 0)      /* divided by 1 */
-			pr_err("%s: dsi_byte_div_clk - "
-				"clk_set_rate failed\n", __func__);
-		if (clk_set_rate(dsi_esc_clk, esc_byte_ratio) < 0) /* divided by esc */
-			pr_err("%s: dsi_esc_clk - "                      /* clk ratio */
-				"clk_set_rate failed\n", __func__);
 			clk_prepare_enable(dsi_byte_div_clk);
 			clk_prepare_enable(dsi_esc_clk);
 			cont_splash_clks_enabled = 1;
@@ -694,24 +688,24 @@
 	}
 }
 
-void mipi_dsi_prepare_ahb_clocks(void)
+void mipi_dsi_prepare_clocks(void)
 {
 	clk_prepare(amp_pclk);
 	clk_prepare(dsi_m_pclk);
 	clk_prepare(dsi_s_pclk);
-}
-
-void mipi_dsi_unprepare_ahb_clocks(void)
-{
-	clk_unprepare(dsi_m_pclk);
-	clk_unprepare(dsi_s_pclk);
-	clk_unprepare(amp_pclk);
+	clk_set_rate(dsi_byte_div_clk, 1);
+	clk_set_rate(dsi_esc_clk, 1);
+	clk_prepare(dsi_byte_div_clk);
+	clk_prepare(dsi_esc_clk);
 }
 
 void mipi_dsi_unprepare_clocks(void)
 {
 	clk_unprepare(dsi_esc_clk);
 	clk_unprepare(dsi_byte_div_clk);
+	clk_unprepare(dsi_m_pclk);
+	clk_unprepare(dsi_s_pclk);
+	clk_unprepare(amp_pclk);
 }
 
 void mipi_dsi_ahb_ctrl(u32 enable)
@@ -750,16 +744,16 @@
 	MIPI_OUTP(MIPI_DSI_BASE + 0x0200, pll_ctrl | 0x01);
 	mipi_dsi_phy_rdy_poll();
 
-	if (clk_set_rate(dsi_byte_div_clk, 1) < 0)      /* divided by 1 */
+	if (clk_set_rate(dsi_byte_div_clk, 1) < 0)	/* divided by 1 */
 		pr_err("%s: dsi_byte_div_clk - "
 			"clk_set_rate failed\n", __func__);
 	if (clk_set_rate(dsi_esc_clk, esc_byte_ratio) < 0) /* divided by esc */
-		pr_err("%s: dsi_esc_clk - "                      /* clk ratio */
+		pr_err("%s: dsi_esc_clk - "			 /* clk ratio */
 			"clk_set_rate failed\n", __func__);
 	mipi_dsi_pclk_ctrl(&dsi_pclk, 1);
 	mipi_dsi_clk_ctrl(&dsicore_clk, 1);
-	clk_prepare_enable(dsi_byte_div_clk);
-	clk_prepare_enable(dsi_esc_clk);
+	clk_enable(dsi_byte_div_clk);
+	clk_enable(dsi_esc_clk);
 	mipi_dsi_clk_on = 1;
 	mdp4_stat.dsi_clk_on++;
 }
@@ -851,20 +845,11 @@
 void hdmi_msm_init_phy(int video_format)
 {
 	uint32 offset;
-
 	pr_err("Video format is : %u\n", video_format);
 
 	HDMI_OUTP(HDMI_PHY_REG_0, 0x1B);
-	HDMI_OUTP(HDMI_PHY_REG_1, 0xF2);
+	HDMI_OUTP(HDMI_PHY_REG_1, 0xf2);
 
-	/* Set HDMI_PHY_REG1 based on chip source id[30:28] and PTE_HDMI[31] bit
-	 * of QFPROM_RAW_PTE_ROW1_LSB */
-	 if (hdmi_msm_state->pd->source) {
-		if ((hdmi_msm_state->pd->source()) &&
-			(((inpdw(QFPROM_BASE + 0x00c0) & 0xF0000000) >> 28) ==
-									0x1))
-			HDMI_OUTP(HDMI_PHY_REG_1, 0xF1);
-	}
 	offset = HDMI_PHY_REG_4;
 	while (offset <= HDMI_PHY_REG_11) {
 		HDMI_OUTP(offset, 0x0);
@@ -880,7 +865,7 @@
 	HDMI_OUTP_ND(HDMI_PHY_REG_2, 0x7F); /*0b01111111*/
 }
 
-void hdmi_frame_ctrl_cfg(const struct hdmi_disp_mode_timing_type *timing)
+void hdmi_frame_ctrl_cfg(const struct msm_hdmi_mode_timing_info *timing)
 {
 	/*  0x02C8 HDMI_FRAME_CTRL
 	 *  31 INTERLACED_EN   Interlaced or progressive enable bit
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_fb.c msm/msm_fb.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_fb.c	2013-12-17 17:08:08.030147333 -0800
+++ msm/msm_fb.c	2013-12-11 02:38:33.000000000 -0800
@@ -25,7 +25,6 @@
 #include <linux/fb.h>
 #include <linux/msm_mdp.h>
 #include <linux/init.h>
-#include <linux/kthread.h>
 #include <linux/ioport.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
@@ -117,8 +116,8 @@
 static int msm_fb_mmap(struct fb_info *info, struct vm_area_struct * vma);
 static int mdp_bl_scale_config(struct msm_fb_data_type *mfd,
 						struct mdp_bl_scale_data *data);
-static void msm_fb_scale_bl(__u32 *bl_lvl);
-static int msm_fb_commit_thread(void *data);
+static void msm_fb_scale_bl(__u32 bl_max, __u32 *bl_lvl);
+static void msm_fb_commit_wq_handler(struct work_struct *work);
 static int msm_fb_pan_idle(struct msm_fb_data_type *mfd);
 
 #ifdef MSM_FB_ENABLE_DBGFS
@@ -139,7 +138,7 @@
 static int bl_scale, bl_min_lvl;
 
 DEFINE_MUTEX(msm_fb_notify_update_sem);
-static DEFINE_MUTEX(power_state_chagne);
+DEFINE_MUTEX(power_state_chagne);
 
 void msmfb_no_update_notify_timer_cb(unsigned long data)
 {
@@ -363,21 +362,14 @@
 
 	if ((pdev->id == 0) && (pdev->num_resources > 0)) {
 		msm_fb_pdata = pdev->dev.platform_data;
-		if (pdev->resource[0].start) {
-			fbram_size =
-				pdev->resource[0].end -
-				pdev->resource[0].start + 1;
-			fbram_phys = (char *)pdev->resource[0].start;
-			fbram = __va(fbram_phys);
-
-			if (!fbram) {
-				printk(KERN_ERR "fbram ioremap failed!\n");
-				return -ENOMEM;
-			}
-		} else {
-			fbram_size = 0;
-			fbram_phys = NULL;
-			fbram = NULL;
+		fbram_size =
+			pdev->resource[0].end - pdev->resource[0].start + 1;
+		fbram_phys = (char *)pdev->resource[0].start;
+		fbram = __va(fbram_phys);
+
+		if (!fbram) {
+			printk(KERN_ERR "fbram ioremap failed!\n");
+			return -ENOMEM;
 		}
 		MSM_FB_DEBUG("msm_fb_probe:  phy_Addr = 0x%x virt = 0x%x\n",
 			     (int)fbram_phys, (int)fbram);
@@ -422,10 +414,6 @@
 	if (rc)
 		return rc;
 
-	mfd->panel_info.xres_aligned = ALIGN(mfd->panel_info.xres, 64);
-	mfd->panel_info.yres_aligned = ALIGN(mfd->panel_info.yres, 64);
-	mfd->max_map_size = mfd->panel_info.xres_aligned * mfd->panel_info.yres_aligned * 4 * 2;
-
 	err = pm_runtime_set_active(mfd->fbi->dev);
 	if (err < 0)
 		printk(KERN_ERR "pm_runtime: fail to set active.\n");
@@ -503,7 +491,6 @@
 		del_timer(&mfd->msmfb_no_update_notify_timer);
 	complete(&mfd->msmfb_no_update_notify);
 	complete(&mfd->msmfb_update_notify);
-	kthread_stop(mfd->commit_thread);
 
 	/* remove /dev/fb* */
 	unregister_framebuffer(mfd->fbi);
@@ -571,7 +558,18 @@
 	 */
 	mfd->suspend.sw_refreshing_enable = mfd->sw_refreshing_enable;
 	mfd->suspend.op_enable = mfd->op_enable;
-	mfd->suspend.panel_power_on = mfd->panel_power_on;
+
+	/*
+	 * For HDMI/DTV, panel needs not to be turned ON during resume
+	 * as power_ctrl will turn ON the HPD at resume which will turn
+	 * ON the panel in case the HDMI cable is still connected.
+	 */
+	if (mfd->panel_info.type == HDMI_PANEL ||
+	    mfd->panel_info.type == DTV_PANEL)
+		mfd->suspend.panel_power_on = false;
+	else
+		mfd->suspend.panel_power_on = mfd->panel_power_on;
+
 	mfd->suspend.op_suspend = true;
 
 	if (mfd->op_enable) {
@@ -814,14 +812,11 @@
 	struct fb_info *fbi = mfd->fbi;
 	switch (mfd->fbi->var.bits_per_pixel) {
 	case 32:
-		if (fbi->screen_base)
-			memset32_io((void *)fbi->screen_base, 0xFF000000,
-				    fbi->fix.smem_len);
+		memset32_io((void *)fbi->screen_base, 0xFF000000,
+							fbi->fix.smem_len);
 		break;
 	default:
-		if (fbi->screen_base)
-			memset32_io((void *)fbi->screen_base, 0x00,
-				    fbi->fix.smem_len);
+		memset32_io((void *)fbi->screen_base, 0x00, fbi->fix.smem_len);
 		break;
 	}
 #endif
@@ -884,13 +879,23 @@
 	return ret;
 }
 
-static void msm_fb_scale_bl(__u32 *bl_lvl)
+static void msm_fb_scale_bl(__u32 bl_max, __u32 *bl_lvl)
 {
 	__u32 temp = *bl_lvl;
 	pr_debug("%s: input = %d, scale = %d", __func__, temp, bl_scale);
 	if (temp >= bl_min_lvl) {
+		/* checking if temp is below bl_max else capping */
+		if (temp > bl_max) {
+			pr_warn("%s: invalid bl level\n", __func__);
+			temp = bl_max;
+		}
+		/* checking if bl_scale is below 1024 else capping */
+		if (bl_scale > 1024) {
+			pr_warn("%s: invalid bl scale\n", __func__);
+			bl_scale = 1024;
+		}
 		/* bl_scale is the numerator of scaling fraction (x/1024)*/
-		temp = ((*bl_lvl) * bl_scale) / 1024;
+		temp = (temp * bl_scale) / 1024;
 
 		/*if less than minimum level, use min level*/
 		if (temp < bl_min_lvl)
@@ -917,7 +922,7 @@
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 
 	if ((pdata) && (pdata->set_backlight)) {
-		msm_fb_scale_bl(&temp);
+		msm_fb_scale_bl(mfd->panel_info.bl_max, &temp);
 		if (bl_level_old == temp) {
 			return;
 		}
@@ -935,6 +940,9 @@
 	struct msm_fb_panel_data *pdata = NULL;
 	int ret = 0;
 
+	if (!op_enable)
+		return -EPERM;
+
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 	if ((!pdata) || (!pdata->on) || (!pdata->off)) {
 		printk(KERN_ERR "msm_fb_blank_sub: no panel operation detected!\n");
@@ -948,7 +956,9 @@
 		if (!mfd->panel_power_on) {
 			ret = pdata->on(mfd->pdev);
 			if (ret == 0) {
+				down(&mfd->sem);
 				mfd->panel_power_on = TRUE;
+				up(&mfd->sem);
 				mfd->panel_driver_on = mfd->op_enable;
 			}
 		}
@@ -966,7 +976,9 @@
 
 			mfd->op_enable = FALSE;
 			curr_pwr_state = mfd->panel_power_on;
+			down(&mfd->sem);
 			mfd->panel_power_on = FALSE;
+			up(&mfd->sem);
 
 			if (mfd->msmfb_no_update_notify_timer.function)
 				del_timer(&mfd->msmfb_no_update_notify_timer);
@@ -975,9 +987,8 @@
 			bl_updated = 0;
 
 			/* clean fb to prevent displaying old fb */
-			if (info->screen_base)
-				memset((void *)info->screen_base, 0,
-				       info->fix.smem_len);
+			memset((void *)info->screen_base, 0,
+					info->fix.smem_len);
 
 			ret = pdata->off(mfd->pdev);
 			if (ret)
@@ -1138,14 +1149,18 @@
 	if (!start)
 		return -EINVAL;
 
-	if ((vma->vm_end <= vma->vm_start) || (off >= len) ||
-		((vma->vm_end - vma->vm_start) > (len - off)))
+	if ((vma->vm_end <= vma->vm_start) ||
+	    (off >= len) ||
+	    ((vma->vm_end - vma->vm_start) > (len - off)))
 		return -EINVAL;
-	msm_fb_pan_idle(mfd);
 
+	msm_fb_pan_idle(mfd);
 	/* Set VM flags. */
 	start &= PAGE_MASK;
 	off += start;
+	if (off < start)
+		return -EINVAL;
+
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 	/* This is an IO map - tell maydump to skip this VMA */
 	vma->vm_flags |= VM_IO | VM_RESERVED;
@@ -1399,7 +1414,8 @@
 	var->xres = panel_info->xres;
 	var->yres = panel_info->yres;
 	
-#ifdef CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_VIDEO_FULL_HD_PT
+#if defined	(CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_VIDEO_FULL_HD_PT) \
+	|| defined (CONFIG_FB_MSM_MIPI_RENESAS_TFT_VIDEO_FULL_HD_PT_PANEL)
 	var->height = panel_info->height; /* height of picture in mm*/
 	var->width = panel_info->width; /* width of picture in mm*/
 #else
@@ -1475,26 +1491,19 @@
 	init_completion(&mfd->msmfb_no_update_notify);
 	init_completion(&mfd->commit_comp);
 	mutex_init(&mfd->sync_mutex);
-	mutex_init(&mfd->queue_mutex);
-	init_waitqueue_head(&mfd->commit_queue);
-	mfd->commit_thread = kthread_run(msm_fb_commit_thread, mfd,
-			"msmfb_commit_thread");
+	INIT_WORK(&mfd->commit_work, msm_fb_commit_wq_handler);
 	mfd->msm_fb_backup = kzalloc(sizeof(struct msm_fb_backup_type),
 		GFP_KERNEL);
 	if (mfd->msm_fb_backup == 0) {
 		pr_err("error: not enough memory!\n");
 		return -ENOMEM;
 	}
+	fbram_offset = PAGE_ALIGN((int)fbram)-(int)fbram;
+	fbram += fbram_offset;
+	fbram_phys += fbram_offset;
+	fbram_size -= fbram_offset;
 
-	if (fbram) {
-		fbram_offset = PAGE_ALIGN((int)fbram)-(int)fbram;
-		fbram += fbram_offset;
-		fbram_phys += fbram_offset;
-		fbram_size -= fbram_offset;
-	} else
-		fbram_offset = 0;
-
-	if ((!bf_supported || mfd->index == 0) && fbram)
+	if (!bf_supported || mfd->index == 0)
 		if (fbram_size < fix->smem_len) {
 			pr_err("error: no more framebuffer memory!\n");
 			return -ENOMEM;
@@ -1503,33 +1512,31 @@
 	fbi->screen_base = fbram;
 	fbi->fix.smem_start = (unsigned long)fbram_phys;
 
-	if (fbi->fix.smem_start) {
-		msm_iommu_map_contig_buffer(fbi->fix.smem_start,
-					    DISPLAY_WRITE_DOMAIN,
-					    GEN_POOL,
-					    fbi->fix.smem_len,
-					    SZ_4K,
-					    0,
-					    &(mfd->display_iova));
-
-		msm_iommu_map_contig_buffer(fbi->fix.smem_start,
-					    DISPLAY_READ_DOMAIN,
-					    GEN_POOL,
-					    fbi->fix.smem_len,
-					    SZ_4K,
-					    0,
-					    &(mfd->display_iova));
-
-		msm_iommu_map_contig_buffer(fbi->fix.smem_start,
-					    ROTATOR_SRC_DOMAIN,
-					    GEN_POOL,
-					    fbi->fix.smem_len,
-					    SZ_4K,
-					    0,
-					    &(mfd->rotator_iova));
-	}
+	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
+					DISPLAY_WRITE_DOMAIN,
+					GEN_POOL,
+					fbi->fix.smem_len,
+					SZ_4K,
+					0,
+					&(mfd->display_iova));
+
+	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
+					DISPLAY_READ_DOMAIN,
+					GEN_POOL,
+					fbi->fix.smem_len,
+					SZ_4K,
+					0,
+					&(mfd->display_iova));
+
+	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
+					ROTATOR_SRC_DOMAIN,
+					GEN_POOL,
+					fbi->fix.smem_len,
+					SZ_4K,
+					0,
+					&(mfd->rotator_iova));
 
-	if ((!bf_supported || mfd->index == 0) && fbi->screen_base)
+	if (!bf_supported || mfd->index == 0)
 		memset(fbi->screen_base, 0x0, fix->smem_len);
 
 	mfd->op_enable = TRUE;
@@ -1578,11 +1585,9 @@
 		return -EPERM;
 	}
 
-	if (fbram) {
-		fbram += fix->smem_len;
-		fbram_phys += fix->smem_len;
-		fbram_size -= fix->smem_len;
-	}
+	fbram += fix->smem_len;
+	fbram_phys += fix->smem_len;
+	fbram_size -= fix->smem_len;
 
 	MSM_FB_INFO
 	    ("FrameBuffer[%d] %dx%d size=%d bytes is registered successfully!\n",
@@ -1739,6 +1744,7 @@
 static int msm_fb_open(struct fb_info *info, int user)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	bool unblank = true;
 	int result;
 
 	result = pm_runtime_get_sync(info->dev);
@@ -1752,6 +1758,14 @@
 			return 0;
 	}
 
+	if (mfd->op_enable == 0) {
+		if (!mfd->ref_cnt && info->node == 2)
+			return -EPERM;
+		/* if system is in suspend mode, do not unblank */
+		mfd->ref_cnt++;
+		return 0;
+	}
+
 	if (!mfd->ref_cnt) {
 		if (!bf_supported ||
 			(info->node != 1 && info->node != 2))
@@ -1760,9 +1774,14 @@
 			pr_debug("%s:%d no mdp_set_dma_pan_info %d\n",
 				__func__, __LINE__, info->node);
 
-		if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, TRUE)) {
-			printk(KERN_ERR "msm_fb_open: can't turn on display!\n");
-			return -1;
+		if (mfd->is_panel_ready && !mfd->is_panel_ready())
+			unblank = false;
+
+		if (unblank && (mfd->panel_info.type != DTV_PANEL)) {
+			if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, TRUE)) {
+				pr_err("msm_fb_open: can't turn on display\n");
+				return -EINVAL;
+			}
 		}
 	}
 
@@ -1790,6 +1809,15 @@
 
 	if (!mfd->ref_cnt) {
 		if (mfd->op_enable) {
+#if 0
+			if (info->node == 0) {
+				down(&mfd->sem);
+				bl_level = mfd->bl_level;
+				msm_fb_set_backlight(mfd, 0);
+				unset_bl_level = bl_level;
+				up(&mfd->sem);
+			}
+#endif
 			ret = msm_fb_blank_sub(FB_BLANK_POWERDOWN, info,
 							mfd->op_enable);
 			if (ret != 0) {
@@ -1838,28 +1866,25 @@
 {
 	mutex_lock(&mfd->sync_mutex);
 	if (mfd->timeline && !list_empty((const struct list_head *)
-		(&(mfd->timeline->obj.active_list_head)))) {
+				(&(mfd->timeline->obj.active_list_head)))) {
 		sw_sync_timeline_inc(mfd->timeline, 1);
 		mfd->timeline_value++;
 	}
-	if (atomic_read(&mfd->commit_cnt) > 0)
-		atomic_dec(&mfd->commit_cnt);
+	mfd->last_rel_fence = mfd->cur_rel_fence;
+	mfd->cur_rel_fence = 0;
 	mutex_unlock(&mfd->sync_mutex);
 	return 0;
 }
 
 void msm_fb_release_timeline(struct msm_fb_data_type *mfd)
 {
-	u32 commit_cnt;
 	mutex_lock(&mfd->sync_mutex);
-	commit_cnt = atomic_read(&mfd->commit_cnt) + 3;
-	if (commit_cnt < 0)
-		commit_cnt = 0;
 	if (mfd->timeline) {
-		sw_sync_timeline_inc(mfd->timeline, 2 + commit_cnt);
-		mfd->timeline_value += 2 + commit_cnt;
+		sw_sync_timeline_inc(mfd->timeline, 2);
+		mfd->timeline_value += 2;
 	}
-	atomic_set(&mfd->commit_cnt, 0);
+	mfd->last_rel_fence = 0;
+	mfd->cur_rel_fence = 0;
 	mutex_unlock(&mfd->sync_mutex);
 }
 
@@ -1938,8 +1963,6 @@
 			info->var.yoffset =
 				(var->yoffset / info->fix.ypanstep) *
 					info->fix.ypanstep;
-	} else {
-		mdp4_overlay_mdp_perf_upd(mfd, 1);
 	}
 	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
 	memcpy(&fb_backup->info, info, sizeof(struct fb_info));
@@ -1947,28 +1970,13 @@
 		sizeof(struct mdp_display_commit));
 	mfd->is_committing = 1;
 	INIT_COMPLETION(mfd->commit_comp);
-	atomic_inc(&mfd->commit_cnt);
-	mfd->wake_commit_thread = 1;
-	wake_up_interruptible_all(&mfd->commit_queue);
+	schedule_work(&mfd->commit_work);
 	mutex_unlock(&mfd->sync_mutex);
 	if (wait_for_finish)
 		msm_fb_pan_idle(mfd);
 	return ret;
 }
 
-static inline int rt_policy(int policy)
-{
-	if (unlikely(policy == SCHED_FIFO) ||
-	    unlikely(policy == SCHED_RR))
-		return 1;
-	return 0;
-}
-
-static inline int task_has_rt_policy(struct task_struct *p)
-{
-	return rt_policy(p->policy);
-}
-
 static int msm_fb_pan_display(struct fb_var_screeninfo *var,
 			      struct fb_info *info)
 {
@@ -1982,7 +1990,6 @@
 static int msm_fb_pan_display_sub(struct fb_var_screeninfo *var,
 			      struct fb_info *info)
 {
-	struct sched_param s = { .sched_priority = 1 };
 	struct mdp_dirty_region dirty;
 	struct mdp_dirty_region *dirtyPtr = NULL;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
@@ -1997,14 +2004,6 @@
 		return -EPERM;
 	}
 
-	if (!task_has_rt_policy(current)) {
-		struct cred *new = prepare_creds();
-		cap_raise(new->cap_effective, CAP_SYS_NICE);
-		commit_creds(new);
-		if ((sched_setscheduler(current, SCHED_RR, &s)) < 0)
-			pr_err("sched_setscheduler failed\n");
-	}
-
 	if (info->node != 0 || mfd->cont_splash_done)	/* primary */
 		if ((!mfd->op_enable) || (!mfd->panel_power_on))
 			return -EPERM;
@@ -2105,48 +2104,28 @@
 	return 0;
 }
 
-void msm_fb_release_busy(struct msm_fb_data_type *mfd)
+static void msm_fb_commit_wq_handler(struct work_struct *work)
 {
-	mutex_lock(&mfd->sync_mutex);
-	mfd->is_committing = 0;
-	complete_all(&mfd->commit_comp);
-	mutex_unlock(&mfd->sync_mutex);
-}
-static int msm_fb_commit_thread(void *data)
-{
-	int ret = 0;
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *) data;
+	struct msm_fb_data_type *mfd;
 	struct fb_var_screeninfo *var;
 	struct fb_info *info;
 	struct msm_fb_backup_type *fb_backup;
-	u32 overlay_commit = false;
 
-	while (!kthread_should_stop()) {
-		ret = wait_event_interruptible(mfd->commit_queue,
-				mfd->wake_commit_thread);
-		if (ret >= 0) {
-			mfd->wake_commit_thread = 0;
-			mutex_lock(&mfd->queue_mutex);
-			while (atomic_read(&mfd->commit_cnt) > 0) {
-				fb_backup = (struct msm_fb_backup_type *)
-					mfd->msm_fb_backup;
-				info = &fb_backup->info;
-				if (fb_backup->disp_commit.flags &
-						MDP_DISPLAY_COMMIT_OVERLAY) {
-					overlay_commit = true;
-					mdp4_overlay_commit(info);
-				} else {
-					var = &fb_backup->disp_commit.var;
-					msm_fb_pan_display_sub(var, info);
-					msm_fb_release_busy(mfd);
-				}
-			}
-			if (overlay_commit)
-				mdp4_overlay_commit_finish(info);
-			mutex_unlock(&mfd->queue_mutex);
-		}
+	mfd = container_of(work, struct msm_fb_data_type, commit_work);
+	fb_backup = (struct msm_fb_backup_type *)mfd->msm_fb_backup;
+	info = &fb_backup->info;
+	if (fb_backup->disp_commit.flags &
+		MDP_DISPLAY_COMMIT_OVERLAY) {
+			mdp4_overlay_commit(info);
+	} else {
+		var = &fb_backup->disp_commit.var;
+		msm_fb_pan_display_sub(var, info);
 	}
-	return 0;
+	mutex_lock(&mfd->sync_mutex);
+	mfd->is_committing = 0;
+	complete_all(&mfd->commit_comp);
+	mutex_unlock(&mfd->sync_mutex);
+
 }
 
 static int msm_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
@@ -2242,11 +2221,13 @@
 	if ((var->xres == 0) || (var->yres == 0))
 		return -EINVAL;
 
-	if ((var->xres > MAX(mfd->panel_info.xres,
-			     mfd->panel_info.mode2_xres)) ||
-		(var->yres > MAX(mfd->panel_info.yres,
-				 mfd->panel_info.mode2_yres)))
-		return -EINVAL;
+	if (mfd->index == 0) {
+		if ((var->xres > MAX(mfd->panel_info.xres,
+					mfd->panel_info.mode2_xres)) ||
+				(var->yres > MAX(mfd->panel_info.yres,
+					 mfd->panel_info.mode2_yres)))
+			return -EINVAL;
+	}
 
 	if (var->xoffset > (var->xres_virtual - var->xres))
 		return -EINVAL;
@@ -2257,24 +2238,28 @@
 	return 0;
 }
 
-int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd
-						, struct fb_info *info)
+int msm_fb_get_frame_rate(struct fb_var_screeninfo *var)
 {
-	int panel_height, panel_width, var_frame_rate, fps_mod;
-	struct fb_var_screeninfo *var = &info->var;
-	fps_mod = 0;
-	if ((mfd->panel_info.type == DTV_PANEL) ||
-		(mfd->panel_info.type == HDMI_PANEL)) {
-		panel_height = var->yres + var->upper_margin +
+	int panel_height, panel_width;
+
+	panel_height = var->yres + var->upper_margin +
 			var->vsync_len + var->lower_margin;
-		panel_width = var->xres + var->right_margin +
+	panel_width  = var->xres + var->right_margin +
 			var->hsync_len + var->left_margin;
-		var_frame_rate = ((var->pixclock)/(panel_height * panel_width));
-		if (mfd->var_frame_rate != var_frame_rate) {
+	return (var->pixclock)/(panel_height * panel_width);
+}
+
+int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd, struct fb_info *info)
+{
+	int fps_mod = 0;
+	struct fb_var_screeninfo *var = &info->var;
+
+	if ((mfd->panel_info.type == DTV_PANEL) ||
+	    (mfd->panel_info.type == HDMI_PANEL)) {
+		if (mfd->var_frame_rate != msm_fb_get_frame_rate(var))
 			fps_mod = 1;
-			mfd->var_frame_rate = var_frame_rate;
-		}
 	}
+
 	return fps_mod;
 }
 
@@ -2323,13 +2308,20 @@
 				(msm_fb_check_frame_rate(mfd, info))))) {
 		mfd->var_xres = var->xres;
 		mfd->var_yres = var->yres;
-		mfd->var_pixclock = var->pixclock;
+		mfd->var_pixclock   = var->pixclock;
+		mfd->var_frame_rate = msm_fb_get_frame_rate(var);
+
+		if (mfd->update_panel_info)
+			mfd->update_panel_info(mfd);
+
 		blank = 1;
 	}
 	mfd->fbi->fix.line_length = msm_fb_line_length(mfd->index, var->xres,
 						       var->bits_per_pixel/8);
 
-	if (blank) {
+	if ((mfd->panel_info.type == DTV_PANEL) && !mfd->panel_power_on) {
+		msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable);
+	} else if (blank) {
 		msm_fb_blank_sub(FB_BLANK_POWERDOWN, info, mfd->op_enable);
 		msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable);
 	}
@@ -3601,12 +3593,13 @@
 }
 #endif
 
-static int msmfb_notify_update(struct fb_info *info, unsigned long *argp)
+static int msmfb_notify_update(struct fb_info *info, void __user *argp)
 {
-	unsigned int ret = 0, notify = 0;
+	int ret;
+	unsigned int notify;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
 
-	ret = copy_from_user(&notify, argp, sizeof(int));
+	ret = copy_from_user(&notify, argp, sizeof(unsigned int));
 	if (ret) {
 		pr_err("%s:ioctl failed\n", __func__);
 		return ret;
@@ -3685,6 +3678,10 @@
 		ret = mdp4_qseed_cfg((struct mdp_qseed_cfg_data *)
 						&pp_ptr->data.qseed_cfg_data);
 		break;
+	case mdp_op_calib_cfg:
+		ret = mdp4_calib_config((struct mdp_calib_config_data *)
+						&pp_ptr->data.calib_cfg);
+		break;
 #endif
 	case mdp_bl_scale_cfg:
 		ret = mdp_bl_scale_config(mfd, (struct mdp_bl_scale_data *)
@@ -3707,12 +3704,6 @@
 	u32 threshold;
 	int acq_fen_fd[MDP_MAX_FENCE_FD];
 	struct sync_fence *fence;
-	struct sync_pt *release_sync_pt;
-	struct sync_pt *retire_sync_pt;
-	struct sync_fence *release_fence;
-	struct sync_fence *retire_fence;
-	int release_fen_fd;
-	int retire_fen_fd;
 
 	if ((buf_sync->acq_fen_fd_cnt > MDP_MAX_FENCE_FD) ||
 		(mfd->timeline == NULL))
@@ -3728,7 +3719,6 @@
 		pr_err("%s:copy_from_user failed", __func__);
 		return ret;
 	}
-
 	mutex_lock(&mfd->sync_mutex);
 	for (i = 0; i < buf_sync->acq_fen_fd_cnt; i++) {
 		fence = sync_fence_fdget(acq_fen_fd[i]);
@@ -3746,61 +3736,49 @@
 	if (buf_sync->flags & MDP_BUF_SYNC_FLAG_WAIT) {
 		msm_fb_wait_for_fence(mfd);
 	}
-	if ((mfd->panel.type == WRITEBACK_PANEL) ||
-		(mfd->panel.type == MIPI_CMD_PANEL))
+	if (mfd->panel.type == WRITEBACK_PANEL)
 		threshold = 1;
 	else
 		threshold = 2;
-
-	release_fen_fd = get_unused_fd_flags(0);
-	if (release_fen_fd < 0) {
-		pr_err("%s: get_unused_fd_flags failed", __func__);
-		ret  = -EIO;
+	mfd->cur_rel_sync_pt = sw_sync_pt_create(mfd->timeline,
+			mfd->timeline_value + threshold);
+	if (mfd->cur_rel_sync_pt == NULL) {
+		pr_err("%s: cannot create sync point", __func__);
+		ret = -ENOMEM;
 		goto buf_sync_err_1;
 	}
-
-	retire_fen_fd = get_unused_fd_flags(0);
-	if (retire_fen_fd < 0) {
+	/* create fence */
+	mfd->cur_rel_fence = sync_fence_create("mdp-fence",
+			mfd->cur_rel_sync_pt);
+	if (mfd->cur_rel_fence == NULL) {
+		sync_pt_free(mfd->cur_rel_sync_pt);
+		mfd->cur_rel_sync_pt = NULL;
+		pr_err("%s: cannot create fence", __func__);
+		ret = -ENOMEM;
+		goto buf_sync_err_1;
+	}
+	/* create fd */
+	mfd->cur_rel_fen_fd = get_unused_fd_flags(0);
+	if (mfd->cur_rel_fen_fd < 0) {
 		pr_err("%s: get_unused_fd_flags failed", __func__);
 		ret  = -EIO;
 		goto buf_sync_err_2;
 	}
-
-	release_sync_pt = sw_sync_pt_create(mfd->timeline,
-			mfd->timeline_value + threshold +
-			atomic_read(&mfd->commit_cnt));
-	release_fence = sync_fence_create("mdp-fence",
-			release_sync_pt);
-	sync_fence_install(release_fence, release_fen_fd);
-	retire_sync_pt = sw_sync_pt_create(mfd->timeline,
-			mfd->timeline_value + threshold +
-			atomic_read(&mfd->commit_cnt) + 1);
-	retire_fence = sync_fence_create("mdp-retire-fence",
-			retire_sync_pt);
-	sync_fence_install(retire_fence, retire_fen_fd);
-
+	sync_fence_install(mfd->cur_rel_fence, mfd->cur_rel_fen_fd);
 	ret = copy_to_user(buf_sync->rel_fen_fd,
-		&release_fen_fd, sizeof(int));
-	if (ret) {
-		pr_err("%s:copy_to_user failed", __func__);
-		goto buf_sync_err_3;
-	}
-
-	ret = copy_to_user(buf_sync->retire_fen_fd,
-		&retire_fen_fd, sizeof(int));
+		&mfd->cur_rel_fen_fd, sizeof(int));
 	if (ret) {
 		pr_err("%s:copy_to_user failed", __func__);
 		goto buf_sync_err_3;
 	}
-
 	mutex_unlock(&mfd->sync_mutex);
 	return ret;
 buf_sync_err_3:
-	sync_fence_put(release_fence);
-	sync_fence_put(retire_fence);
-	put_unused_fd(retire_fen_fd);
+	put_unused_fd(mfd->cur_rel_fen_fd);
 buf_sync_err_2:
-	put_unused_fd(release_fen_fd);
+	sync_fence_put(mfd->cur_rel_fence);
+	mfd->cur_rel_fence = NULL;
+	mfd->cur_rel_fen_fd = 0;
 buf_sync_err_1:
 	for (i = 0; i < mfd->acq_fen_cnt; i++)
 		sync_fence_put(mfd->acq_fen[i]);
@@ -3846,7 +3824,7 @@
 static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			unsigned long arg)
 {
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	struct msm_fb_data_type *mfd;
 	void __user *argp = (void __user *)arg;
 	struct fb_cursor cursor;
 	struct fb_cmap cmap;
@@ -3866,6 +3844,8 @@
 
 	if (!info || !info->par)
 		return -EINVAL;
+	mfd = (struct msm_fb_data_type *)info->par;
+	msm_fb_pan_idle(mfd);
 
 	switch (cmd) {
 #ifdef CONFIG_FB_MSM_OVERLAY
@@ -4155,6 +4135,8 @@
 			return ret;
 
 		ret = msmfb_handle_pp_ioctl(mfd, &mdp_pp);
+		if (ret == 1)
+			ret = copy_to_user(argp, &mdp_pp, sizeof(mdp_pp));
 		break;
 	case MSMFB_BUFFER_SYNC:
 		sec_debug_mdp_set_value(SEC_DEBUG_BUFFER_SYNC, SEC_DEBUG_IN);
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_fb.h msm/msm_fb.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_fb.h	2013-12-17 17:08:08.030147333 -0800
+++ msm/msm_fb.h	2013-12-11 02:38:33.000000000 -0800
@@ -141,6 +141,8 @@
 	int (*stop_histogram) (struct fb_info *info, uint32_t block);
 	void (*vsync_ctrl) (int enable);
 	void (*vsync_init) (int cndx);
+	void (*update_panel_info)(struct msm_fb_data_type *mfd);
+	bool (*is_panel_ready)(void);
 	void *vsync_show;
 	void *cursor_buf;
 	void *cursor_buf_phys;
@@ -197,25 +199,26 @@
 	void *cpu_pm_hdl;
 	u32 acq_fen_cnt;
 	struct sync_fence *acq_fen[MDP_MAX_FENCE_FD];
+	int cur_rel_fen_fd;
+	struct sync_pt *cur_rel_sync_pt;
+	struct sync_fence *cur_rel_fence;
+	struct sync_fence *last_rel_fence;
 	struct sw_sync_timeline *timeline;
 	int timeline_value;
+	u32 last_acq_fen_cnt;
+	struct sync_fence *last_acq_fen[MDP_MAX_FENCE_FD];
 	struct mutex sync_mutex;
-	struct mutex queue_mutex;
 	struct completion commit_comp;
 	u32 is_committing;
-	atomic_t commit_cnt;
-	struct task_struct *commit_thread;
-	wait_queue_head_t commit_queue;
-	int wake_commit_thread;
+	struct work_struct commit_work;
 	void *msm_fb_backup;
 	boolean panel_driver_on;
 	int vsync_sysfs_created;
 	int resume_state;
-	void *copy_splash_buf;
+	void *copy_splash_buf;			
 	unsigned char *copy_splash_phys;
 	uint32 sec_mapped;
 	uint32 sec_active;
-	uint32 max_map_size;
 };
 struct msm_fb_backup_type {
 	struct fb_info info;
@@ -242,8 +245,6 @@
 void msm_fb_wait_for_fence(struct msm_fb_data_type *mfd);
 int msm_fb_signal_timeline(struct msm_fb_data_type *mfd);
 void msm_fb_release_timeline(struct msm_fb_data_type *mfd);
-void msm_fb_release_busy(struct msm_fb_data_type *mfd);
-
 #ifdef CONFIG_FB_BACKLIGHT
 void msm_fb_config_backlight(struct msm_fb_data_type *mfd);
 #endif
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_fb_panel.h msm/msm_fb_panel.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/msm_fb_panel.h	2013-12-17 17:08:08.030147333 -0800
+++ msm/msm_fb_panel.h	2013-12-11 02:38:33.000000000 -0800
@@ -184,8 +184,6 @@
 	struct lcdc_panel_info lcdc;
 	struct mipi_panel_info mipi;
 	struct lvds_panel_info lvds;
-	__u32 xres_aligned;
-	__u32 yres_aligned;
 };
 
 #define MSM_FB_SINGLE_MODE_PANEL(pinfo)		\
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/smart_mtp_se6e8fa.c msm/smart_mtp_se6e8fa.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/smart_mtp_se6e8fa.c	2013-12-17 17:08:08.030147333 -0800
+++ msm/smart_mtp_se6e8fa.c	2013-12-11 02:38:33.000000000 -0800
@@ -89,15 +89,6 @@
 static char VT_300CD_G;
 static char VT_300CD_B;
 
-static int color_mods[5][9] = {
-	{  0,  0,  5, -18, -16, -10, 0, 0,  3 },
-	{  0,  0,  2,  -9,  -8,  -5, 0, 0,  1 },
-	{  0,  0,  0,   0,   0,   0, 0, 0,  0 },
-	{  0,  0, -2,   9,   8,   5, 0, 0, -1 },
-	{  0,  0, -5,  18,  16,  10, 0, 0, -3 }
-};
-static unsigned int panelval = 2;
-
 static int char_to_int(char data1)
 {
 	int cal_data;
@@ -111,14 +102,6 @@
 	return cal_data;
 }
 
-void panel_load_colors(unsigned int val, struct SMART_DIM *pSmart)
-{
-	if (val < 5) {
-		panelval = val;
-		smart_dimming_init(pSmart);
-	}
-}
-
 static int char_to_int_v255(char data1, char data2)
 {
 	int cal_data;
@@ -144,7 +127,7 @@
 	LSB = char_to_int_v255(pSmart->MTP.R_OFFSET.OFFSET_255_MSB,
 				pSmart->MTP.R_OFFSET.OFFSET_255_LSB);
 	add_mtp = LSB + v255_value;
-	result_1 = result_2 = (v255_coefficient+add_mtp + color_mods[panelval][0]) << BIT_SHIFT;
+	result_1 = result_2 = (v255_coefficient+add_mtp) << BIT_SHIFT;
 	do_div(result_2, v255_denominator);
 	result_3 = (S6E8FA_VREG0_REF * result_2) >> BIT_SHIFT;
 	result_4 = S6E8FA_VREG0_REF - result_3;
@@ -155,7 +138,7 @@
 	LSB = char_to_int_v255(pSmart->MTP.G_OFFSET.OFFSET_255_MSB,
 				pSmart->MTP.G_OFFSET.OFFSET_255_LSB);
 	add_mtp = LSB + v255_value;
-	result_1 = result_2 = (v255_coefficient+add_mtp + color_mods[panelval][1]) << BIT_SHIFT;
+	result_1 = result_2 = (v255_coefficient+add_mtp) << BIT_SHIFT;
 	do_div(result_2, v255_denominator);
 	result_3 = (S6E8FA_VREG0_REF * result_2) >> BIT_SHIFT;
 	result_4 = S6E8FA_VREG0_REF - result_3;
@@ -166,7 +149,7 @@
 	LSB = char_to_int_v255(pSmart->MTP.B_OFFSET.OFFSET_255_MSB,
 				pSmart->MTP.B_OFFSET.OFFSET_255_LSB);
 	add_mtp = LSB + v255_value;
-	result_1 = result_2 = (v255_coefficient+add_mtp + color_mods[panelval][2]) << BIT_SHIFT;
+	result_1 = result_2 = (v255_coefficient+add_mtp) << BIT_SHIFT;
 	do_div(result_2, v255_denominator);
 	result_3 = (S6E8FA_VREG0_REF * result_2) >> BIT_SHIFT;
 	result_4 = S6E8FA_VREG0_REF - result_3;
@@ -228,7 +211,7 @@
 
 	LSB = char_to_int(pSmart->MTP.R_OFFSET.OFFSET_1);
 	add_mtp = LSB + VT_300CD_R;
-	result_1 = result_2 = (vt_coefficient[LSB] + color_mods[panelval][3]) << BIT_SHIFT;
+	result_1 = result_2 = vt_coefficient[LSB] << BIT_SHIFT;
 	do_div(result_2, vt_denominator);
 	result_3 = (S6E8FA_VREG0_REF * result_2) >> BIT_SHIFT;
 	result_4 = S6E8FA_VREG0_REF - result_3;
@@ -236,7 +219,7 @@
 
 	LSB = char_to_int(pSmart->MTP.G_OFFSET.OFFSET_1);
 	add_mtp = LSB + VT_300CD_G;
-	result_1 = result_2 = (vt_coefficient[LSB]  + color_mods[panelval][4]) << BIT_SHIFT;
+	result_1 = result_2 = vt_coefficient[LSB] << BIT_SHIFT;
 	do_div(result_2, vt_denominator);
 	result_3 = (S6E8FA_VREG0_REF * result_2) >> BIT_SHIFT;
 	result_4 = S6E8FA_VREG0_REF - result_3;
@@ -244,7 +227,7 @@
 
 	LSB = char_to_int(pSmart->MTP.B_OFFSET.OFFSET_1);
 	add_mtp = LSB + VT_300CD_B;
-	result_1 = result_2 = (vt_coefficient[LSB]  + color_mods[panelval][5]) << BIT_SHIFT;
+	result_1 = result_2 = vt_coefficient[LSB] << BIT_SHIFT;
 	do_div(result_2, vt_denominator);
 	result_3 = (S6E8FA_VREG0_REF * result_2) >> BIT_SHIFT;
 	result_4 = S6E8FA_VREG0_REF - result_3;
@@ -280,7 +263,7 @@
 	add_mtp = LSB + V203_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 				- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_255);
-	result_2 = (v203_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v203_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v203_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -290,7 +273,7 @@
 	add_mtp = LSB + V203_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 				- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_255);
-	result_2 = (v203_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v203_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v203_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -300,7 +283,7 @@
 	add_mtp = LSB + V203_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 				- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_255);
-	result_2 = (v203_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v203_coefficient+add_mtp) << BIT_SHIFT;
 	do_div(result_2, v203_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -359,7 +342,7 @@
 	add_mtp = LSB + V151_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_203);
-	result_2 = (v151_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v151_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v151_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -369,7 +352,7 @@
 	add_mtp = LSB + V151_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_203);
-	result_2 = (v151_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v151_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v151_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -379,7 +362,7 @@
 	add_mtp = LSB + V151_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_203);
-	result_2 = (v151_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v151_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v151_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -437,7 +420,7 @@
 	add_mtp = LSB + V87_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_151);
-	result_2 = (v87_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v87_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v87_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -447,7 +430,7 @@
 	add_mtp = LSB + V87_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_151);
-	result_2 = (v87_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v87_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v87_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -457,7 +440,7 @@
 	add_mtp = LSB + V87_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_151);
-	result_2 = (v87_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v87_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v87_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -515,7 +498,7 @@
 	add_mtp = LSB + V51_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_87);
-	result_2 = (v51_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v51_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v51_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -525,7 +508,7 @@
 	add_mtp = LSB + V51_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_87);
-	result_2 = (v51_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v51_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v51_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -535,7 +518,7 @@
 	add_mtp = LSB + V51_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_87);
-	result_2 = (v51_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v51_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v51_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -594,7 +577,7 @@
 	add_mtp = LSB + V35_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_51);
-	result_2 = (v35_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v35_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v35_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -604,7 +587,7 @@
 	add_mtp = LSB + V35_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_51);
-	result_2 = (v35_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v35_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v35_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -614,7 +597,7 @@
 	add_mtp = LSB + V35_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_51);
-	result_2 = (v35_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v35_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v35_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -673,7 +656,7 @@
 	add_mtp = LSB + V23_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_35);
-	result_2 = (v23_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v23_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v23_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -683,7 +666,7 @@
 	add_mtp = LSB + V23_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_35);
-	result_2 = (v23_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v23_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v23_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -693,7 +676,7 @@
 	add_mtp = LSB + V23_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_35);
-	result_2 = (v23_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v23_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v23_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -752,7 +735,7 @@
 	add_mtp = LSB + V11_300CD_R;
 	result_1 = (pSmart->GRAY.VT_TABLE.R_Gray)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_23);
-	result_2 = (v11_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v11_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v11_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.R_Gray) - result_3;
@@ -762,7 +745,7 @@
 	add_mtp = LSB + V11_300CD_G;
 	result_1 = (pSmart->GRAY.VT_TABLE.G_Gray)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_23);
-	result_2 = (v11_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v11_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v11_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.G_Gray) - result_3;
@@ -772,7 +755,7 @@
 	add_mtp = LSB + V11_300CD_B;
 	result_1 = (pSmart->GRAY.VT_TABLE.B_Gray)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_23);
-	result_2 = (v11_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v11_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v11_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (pSmart->GRAY.VT_TABLE.B_Gray) - result_3;
@@ -831,7 +814,7 @@
 	add_mtp = LSB + V3_300CD_R;
 	result_1 = (S6E8FA_VREG0_REF)
 			- (pSmart->RGB_OUTPUT.R_VOLTAGE.level_11);
-	result_2 = (v3_coefficient + add_mtp + color_mods[panelval][6]) << BIT_SHIFT;
+	result_2 = (v3_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v3_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (S6E8FA_VREG0_REF) - result_3;
@@ -841,7 +824,7 @@
 	add_mtp = LSB + V3_300CD_G;
 	result_1 = (S6E8FA_VREG0_REF)
 			- (pSmart->RGB_OUTPUT.G_VOLTAGE.level_11);
-	result_2 = (v3_coefficient + add_mtp + color_mods[panelval][7]) << BIT_SHIFT;
+	result_2 = (v3_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v3_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (S6E8FA_VREG0_REF) - result_3;
@@ -851,7 +834,7 @@
 	add_mtp = LSB + V3_300CD_B;
 	result_1 = (S6E8FA_VREG0_REF)
 			- (pSmart->RGB_OUTPUT.B_VOLTAGE.level_11);
-	result_2 = (v3_coefficient + add_mtp + color_mods[panelval][8]) << BIT_SHIFT;
+	result_2 = (v3_coefficient + add_mtp) << BIT_SHIFT;
 	do_div(result_2, v3_denominator);
 	result_3 = (result_1 * result_2) >> BIT_SHIFT;
 	result_4 = (S6E8FA_VREG0_REF) - result_3;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c msm/vidc/1080p/ddl/vcd_ddl_errors.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_errors.c	2013-12-17 17:08:08.030147333 -0800
+++ msm/vidc/1080p/ddl/vcd_ddl_errors.c	2013-12-11 02:38:33.000000000 -0800
@@ -108,6 +108,7 @@
 
 	switch (ddl_context->cmd_err_status) {
 	case VIDC_1080P_ERROR_UNSUPPORTED_FEATURE_IN_PROFILE:
+	case VIDC_1080P_ERROR_RESOLUTION_NOT_SUPPORTED:
 	case VIDC_1080P_ERROR_VOS_END_CODE_RECEIVED:
 	case VIDC_1080P_ERROR_FRAME_RATE_NOT_SUPPORTED:
 	case VIDC_1080P_ERROR_INVALID_QP_VALUE:
@@ -417,6 +418,17 @@
 			ddl_client_fatal_cb(ddl);
 			return true;
 		}
+		if ((ddl_context->cmd_err_status ==
+			VIDC_1080P_ERROR_RESOLUTION_NOT_SUPPORTED)
+			&& (decoder->codec.codec == VCD_CODEC_H263
+			|| decoder->codec.codec == VCD_CODEC_H264
+			|| decoder->codec.codec == VCD_CODEC_MPEG4
+			|| decoder->codec.codec == VCD_CODEC_VC1
+			|| decoder->codec.codec == VCD_CODEC_VC1_RCV)) {
+			DDL_MSG_ERROR("Unsupported resolution");
+			ddl_client_fatal_cb(ddl);
+			return true;
+		}
 
 		DDL_MSG_ERROR("SEQHDR-FAILED");
 		if (decoder->header_in_start) {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c msm/vidc/1080p/ddl/vcd_ddl_properties.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c	2013-12-17 17:08:08.034147327 -0800
+++ msm/vidc/1080p/ddl/vcd_ddl_properties.c	2013-12-11 02:38:33.000000000 -0800
@@ -2015,7 +2015,6 @@
 	decoder->client_frame_size.width  = VCD_DDL_TEST_DEFAULT_WIDTH;
 	decoder->client_frame_size.stride = VCD_DDL_TEST_DEFAULT_WIDTH;
 	decoder->client_frame_size.scan_lines = VCD_DDL_TEST_DEFAULT_HEIGHT;
-	decoder->client_input_buf_req.sz = 2 * 1024 * 1024;
 	decoder->progressive_only = 1;
 	decoder->idr_only_decoding = false;
 	decoder->output_order = VCD_DEC_ORDER_DISPLAY;
@@ -2133,7 +2132,7 @@
 	encoder->rc_level.frame_level_rc = true;
 	encoder->qp_range.min_qp = 0x1;
 	if (codec == VCD_CODEC_H264) {
-		encoder->qp_range.min_qp = 0x2;
+		encoder->qp_range.min_qp = 0x1;
 		encoder->qp_range.max_qp = 0x33;
 		encoder->session_qp.i_frame_qp = 0x14;
 		encoder->session_qp.p_frame_qp = 0x14;
@@ -2143,20 +2142,12 @@
 		encoder->adaptive_rc.disable_dark_region_as_flag = true;
 		encoder->adaptive_rc.disable_smooth_region_as_flag = true;
 		encoder->adaptive_rc.disable_static_region_as_flag = true;
-	} else if (codec == VCD_CODEC_MPEG4) {
-		encoder->qp_range.max_qp       = 0x1f;
-		encoder->qp_range.min_qp       = 0x1;
-		encoder->session_qp.i_frame_qp = 0x2;
-		encoder->session_qp.p_frame_qp = 0x2;
-		encoder->session_qp.b_frame_qp = 0x2;
-		encoder->rc_level.frame_level_rc = true;
-		encoder->rc_level.mb_level_rc  = false;
 	} else {
 		encoder->qp_range.max_qp       = 0x1f;
 		encoder->qp_range.min_qp       = 0x1;
-		encoder->session_qp.i_frame_qp = 0x9;
-		encoder->session_qp.p_frame_qp = 0x9;
-		encoder->session_qp.b_frame_qp = 0x9;
+		encoder->session_qp.i_frame_qp = 0xd;
+		encoder->session_qp.p_frame_qp = 0xd;
+		encoder->session_qp.b_frame_qp = 0xd;
 		encoder->rc_level.frame_level_rc = true;
 		encoder->rc_level.mb_level_rc  = false;
 	}
@@ -2227,6 +2218,8 @@
 		encoder->output_buf_req.min_count + 3;
 	encoder->output_buf_req.max_count    = DDL_MAX_BUFFER_COUNT;
 	encoder->output_buf_req.align	= DDL_LINEAR_BUFFER_ALIGN_BYTES;
+	if (y_cb_cr_size >= VCD_DDL_720P_YUV_BUF_SIZE)
+		y_cb_cr_size = y_cb_cr_size>>1;
 	encoder->output_buf_req.sz =
 		DDL_ALIGN(y_cb_cr_size, DDL_KILO_BYTE(4));
 	ddl_set_default_encoder_metadata_buffer_size(encoder);
@@ -2268,17 +2261,6 @@
 		output_buf_req = &decoder->actual_output_buf_req;
 		input_buf_req = &decoder->actual_input_buf_req;
 		min_dpb = decoder->min_dpb_num;
-		if (decoder->cont_mode &&
-			decoder->codec.codec == VCD_CODEC_H264) {
-			min_dpb = res_trk_get_min_dpb_count();
-			min_dpb_from_res_trk = 1;
-			if (min_dpb < decoder->min_dpb_num) {
-				DDL_MSG_HIGH("Warning: cont_mode dpb count"\
-					"(%u) is less than decoder min dpb count(%u)",
-					min_dpb, decoder->min_dpb_num);
-				min_dpb = decoder->min_dpb_num;
-			}
-		}
 		if ((decoder->buf_format.buffer_format ==
 			VCD_BUFFER_FORMAT_TILE_4x2) &&
 			(frame_size->height < MDP_MIN_TILE_HEIGHT)) {
@@ -2325,16 +2307,7 @@
 	input_buf_req->min_count = 1;
 	input_buf_req->actual_count = input_buf_req->min_count + 1;
 	input_buf_req->max_count = DDL_MAX_BUFFER_COUNT;
-	if (decoder->client_input_buf_req.sz <= DDL_MEGA_BYTE(2)) {
-		input_buf_req->sz = DDL_MEGA_BYTE(2);
-	} else if (decoder->client_input_buf_req.sz <=
-					DDL_MEGA_BYTE(4)) {
-		input_buf_req->sz = DDL_MEGA_BYTE(4);
-	} else {
-		DDL_MSG_ERROR("Setting incorrect input buffer size = %d",
-			decoder->client_input_buf_req.sz);
-		return false;
-	}
+	input_buf_req->sz = (1024 * 1024 * 2);
 	input_buf_req->align = DDL_LINEAR_BUFFER_ALIGN_BYTES;
 	decoder->min_input_buf_req = *input_buf_req;
 	if (frame_height_actual) {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c msm/vidc/1080p/ddl/vcd_ddl_utils.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c	2013-12-17 17:08:08.034147327 -0800
+++ msm/vidc/1080p/ddl/vcd_ddl_utils.c	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -113,11 +113,11 @@
 				goto unmap_ion_alloc;
 			}
 			addr->alloced_phys_addr = (phys_addr_t) iova;
-			
-			msm_ion_do_cache_op(ddl_context->video_ion_client, 
-			addr->alloc_handle, 
-			addr->virtual_base_addr, 
-			sz, ION_IOC_CLEAN_INV_CACHES); 
+
+			msm_ion_do_cache_op(ddl_context->video_ion_client,
+					addr->alloc_handle,
+					addr->virtual_base_addr,
+					sz, ION_IOC_CLEAN_INV_CACHES);
 		}
 		if (!addr->alloced_phys_addr) {
 			DDL_MSG_ERROR("%s():DDL ION client physical failed\n",
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c msm/vidc/1080p/ddl/vcd_ddl_vidc.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2013-12-17 17:08:08.034147327 -0800
+++ msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2013-12-11 02:38:33.000000000 -0800
@@ -24,11 +24,6 @@
 #endif
 static unsigned int run_cnt;
 
-/* MMRND_AVRC. Start */
-#define QCIF_WIDTH   176
-#define QCIF_HEIGHT  144
-/* MMRND_AVRC. End */
-
 void ddl_vidc_core_init(struct ddl_context *ddl_context)
 {
 	struct vidc_1080P_pix_cache_config pixel_cache_config;
@@ -625,15 +620,6 @@
 		(DDL_FRAMERATE_SCALE(DDL_INITIAL_FRAME_RATE)
 		 != scaled_frame_rate))
 		h263_cpfc_enable = true;
-
-/* MMRND_AVRC. Start */
-	/* added for MMS issue - Remove plus header */
-	if ((encoder->codec.codec == VCD_CODEC_H263) &&
-		(encoder->frame_size.width == QCIF_WIDTH) &&
-		(encoder->frame_size.height == QCIF_HEIGHT))
-			h263_cpfc_enable = false;
-/* MMRND_AVRC. End */
-
 	ltr_enable = DDL_IS_LTR_ENABLED(encoder);
 	DDL_MSG_HIGH("ltr_enable = %u", ltr_enable);
 	vidc_sm_set_extended_encoder_control(&ddl->shared_mem
@@ -823,7 +809,8 @@
 	struct vcd_frame_data *stream = &(ddl->output_frame.vcd_frm);
 	struct vcd_frame_data *input_vcd_frm =
 		&(ddl->input_frame.vcd_frm);
-	u32 dpb_addr_y[VIDC_1080P_MAX_DEC_DPB], dpb_addr_c[VIDC_1080P_MAX_DEC_DPB];
+	u32 dpb_addr_y[VIDC_1080P_MAX_DEC_DPB];
+	u32 dpb_addr_c[VIDC_1080P_MAX_DEC_DPB];
 	u32 index, y_addr, c_addr;
 
 	DDL_MSG_LOW("%s\n", __func__);
@@ -944,7 +931,8 @@
 	struct ddl_enc_buffers *enc_buffers = &(encoder->hw_bufs);
 	struct vcd_frame_data *input_vcd_frm =
 		&(ddl->input_frame.vcd_frm);
-	u32 dpb_addr_y[VIDC_1080P_MAX_DEC_DPB], dpb_addr_c[VIDC_1080P_MAX_DEC_DPB];
+	u32 dpb_addr_y[VIDC_1080P_MAX_DEC_DPB];
+	u32 dpb_addr_c[VIDC_1080P_MAX_DEC_DPB];
 	u32 index, y_addr, c_addr;
 	u32 bitstream_size;
 	struct vidc_1080p_enc_slice_batch_in_param *slice_batch_in =
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c msm/vidc/1080p/ddl/vidc_pix_cache.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/ddl/vidc_pix_cache.c	2013-12-17 17:08:08.034147327 -0800
+++ msm/vidc/1080p/ddl/vidc_pix_cache.c	2013-12-11 02:38:33.000000000 -0800
@@ -15,7 +15,6 @@
 #include "vidc_hwio.h"
 #include "vidc_pix_cache.h"
 
-
 #define VIDC_TILE_MULTIPLY_FACTOR 8192
 
 void vidc_pix_cache_sw_reset(void)
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c	2013-12-17 17:08:08.034147327 -0800
+++ msm/vidc/1080p/resource_tracker/vcd_res_tracker.c	2013-12-11 02:38:33.000000000 -0800
@@ -383,8 +383,6 @@
 	mutex_lock(&resource_context.lock);
 	if (clk_set_rate(resource_context.vcodec_clk,
 		hclk_rate)) {
-		VCDRES_MSG_INFO("clk_rate = %u not supported\n",
-			(u32)hclk_rate);
 		status = false;
 	} else
 		resource_context.vcodec_clk_rate = hclk_rate;
@@ -562,7 +560,6 @@
 			dec_perf_level += cctxt_itr->reqd_perf_lvl;
 		else
 			enc_perf_level += cctxt_itr->reqd_perf_lvl;
-
 		cctxt_itr = cctxt_itr->next;
 	}
 
@@ -581,7 +578,6 @@
 		bus_clk_index = 2;
 	else if (!turbo_supported && bus_clk_index == 3)
 		bus_clk_index = 2;
-
 	bus_clk_index = (bus_clk_index << 1) + (client_type + 1);
 	VCDRES_MSG_LOW("%s(), bus_clk_index = %d", __func__, bus_clk_index);
 	VCDRES_MSG_LOW("%s(),context.pcl = %x", __func__, resource_context.pcl);
@@ -636,11 +632,10 @@
 	}
 	if (!turbo_supported &&
 		 *pn_set_perf_lvl == RESTRK_1080P_TURBO_PERF_LEVEL) {
-			
 		vidc_freq = vidc_clk_table[2];
 		*pn_set_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
-		
 	}
+
 	resource_context.perf_level = *pn_set_perf_lvl;
 	VCDRES_MSG_HIGH("VIDC: vidc_freq = %u, req_perf_lvl = %u, "\
 		"set_perf_lvl = %u\n", vidc_freq, req_perf_lvl,
@@ -658,6 +653,8 @@
 			__func__, vidc_freq);
 		if (!res_trk_sel_clk_rate(vidc_freq)) {
 			if (vidc_freq == vidc_clk_table[4]) {
+				VCDRES_MSG_MED("%s(): Setting vidc freq "\
+					"to %u\n", __func__, (u32)vidc_clk_table[3]);
 				if (res_trk_sel_clk_rate(vidc_clk_table[3]))
 					goto ret;
 			}
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/dec/vdec.c msm/vidc/common/dec/vdec.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/dec/vdec.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/dec/vdec.c	2013-12-11 02:38:33.000000000 -0800
@@ -948,12 +948,6 @@
 	vcd_meta_buffer->offset = meta_buffers->offset;
 	vcd_meta_buffer->pmem_fd_iommu = meta_buffers->pmem_fd_iommu;
 
-	if (meta_buffers->count > MAX_META_BUFFERS) {
-		ERR("meta buffers maximum count reached, count = %d",
-			meta_buffers->count);
-		return false;
-	}
-
 	if (!vcd_get_ion_status()) {
 		if (get_pmem_file(vcd_meta_buffer->pmem_fd,
 				(unsigned long *) (&(vcd_meta_buffer->
@@ -1207,12 +1201,6 @@
 	vcd_h264_mv_buffer->pmem_fd = mv_data->pmem_fd;
 	vcd_h264_mv_buffer->offset = mv_data->offset;
 
-	if (mv_data->count > MAX_MV_BUFFERS) {
-		ERR("MV buffers maximum count reached, count = %d",
-			mv_data->count);
-		return false;
-	}
-
 	if (!vcd_get_ion_status()) {
 		if (get_pmem_file(vcd_h264_mv_buffer->pmem_fd,
 			(unsigned long *) (&(vcd_h264_mv_buffer->
@@ -1637,6 +1625,7 @@
 				return false;
 			}
 		}
+
 		client_ctx->stop_called = false;
 	} else {
 		DBG("%s(): Calling vcd_stop()", __func__);
@@ -1942,8 +1931,6 @@
 	case VDEC_IOCTL_SET_PICRES:
 	{
 		struct vdec_picsize video_resoultion;
-		memset((void *)&video_resoultion, 0,
-			sizeof(struct vdec_picsize));
 		DBG("VDEC_IOCTL_SET_PICRES\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1959,8 +1946,6 @@
 	case VDEC_IOCTL_GET_PICRES:
 	{
 		struct vdec_picsize video_resoultion;
-		memset((void *)&video_resoultion, 0,
-			sizeof(struct vdec_picsize));
 		DBG("VDEC_IOCTL_GET_PICRES\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -1984,10 +1969,6 @@
 		struct vdec_allocatorproperty vdec_buf_req;
 		struct vcd_buffer_requirement buffer_req;
 		DBG("VDEC_IOCTL_SET_BUFFER_REQ\n");
-		memset((void *)&vdec_buf_req, 0,
-			sizeof(struct vdec_allocatorproperty));
-		memset((void *)&buffer_req, 0,
-			sizeof(struct vcd_buffer_requirement));
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
 
@@ -2037,8 +2018,6 @@
 	case VDEC_IOCTL_GET_BUFFER_REQ:
 	{
 		struct vdec_allocatorproperty vdec_buf_req;
-		memset((void *)&vdec_buf_req, 0,
-			sizeof(struct vdec_allocatorproperty));
 		DBG("VDEC_IOCTL_GET_BUFFER_REQ\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2070,8 +2049,6 @@
 	case VDEC_IOCTL_SET_BUFFER:
 	{
 		struct vdec_setbuffer_cmd setbuffer;
-		memset((void *)&setbuffer, 0,
-			sizeof(struct vdec_setbuffer_cmd));
 		DBG("VDEC_IOCTL_SET_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2086,8 +2063,6 @@
 	case VDEC_IOCTL_FREE_BUFFER:
 	{
 		struct vdec_setbuffer_cmd setbuffer;
-		memset((void *)&setbuffer, 0,
-			sizeof(struct vdec_setbuffer_cmd));
 		DBG("VDEC_IOCTL_FREE_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2137,8 +2112,6 @@
 		struct vdec_input_frameinfo input_frame_info;
 		u8 *desc_buf = NULL;
 		u32 desc_size = 0;
-		memset((void *)&input_frame_info, 0,
-			sizeof(struct vdec_input_frameinfo));
 		DBG("VDEC_IOCTL_DECODE_FRAME\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2173,7 +2146,7 @@
 	}
 	case VDEC_IOCTL_GET_PERF_LEVEL:
 	{
-		u32 curr_perf_level = 0;
+		u32 curr_perf_level;
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
 		result = vid_dec_get_curr_perf_level(client_ctx,
@@ -2198,8 +2171,6 @@
 	case VDEC_IOCTL_FILL_OUTPUT_BUFFER:
 	{
 		struct vdec_fillbuffer_cmd fill_buffer_cmd;
-		memset((void *)&fill_buffer_cmd, 0,
-			sizeof(struct vdec_fillbuffer_cmd));
 		DBG("VDEC_IOCTL_FILL_OUTPUT_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2229,8 +2200,6 @@
 	case VDEC_IOCTL_GET_NEXT_MSG:
 	{
 		struct vdec_msginfo vdec_msg_info;
-		memset((void *)&vdec_msg_info, 0,
-			sizeof(struct vdec_msginfo));
 		DBG("VDEC_IOCTL_GET_NEXT_MSG\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2254,10 +2223,6 @@
 		struct vdec_seqheader seq_header;
 		struct vcd_sequence_hdr vcd_seq_hdr;
 		unsigned long ionflag;
-		memset((void *)&seq_header, 0,
-			sizeof(struct vdec_seqheader));
-		memset((void *)&vcd_seq_hdr, 0,
-			sizeof(struct vcd_sequence_hdr));
 		DBG("VDEC_IOCTL_SET_SEQUENCE_HEADER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg))) {
 			ERR("Copy from user vdec_msg failed\n");
@@ -2365,7 +2330,7 @@
 	}
 	case VDEC_IOCTL_GET_INTERLACE_FORMAT:
 	{
-		u32 progressive_only = 0, interlace_format = 0;
+		u32 progressive_only, interlace_format;
 		DBG("VDEC_IOCTL_GET_INTERLACE_FORMAT\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2385,7 +2350,7 @@
 
 	case VDEC_IOCTL_GET_ENABLE_SEC_METADATA:
 	{
-		u32 enable_sec_metadata = 0;
+		u32 enable_sec_metadata;
 		DBG("VDEC_IOCTL_GET_ENABLE_SEC_METADATA\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2402,7 +2367,7 @@
 
 	case VDEC_IOCTL_GET_DISABLE_DMX_SUPPORT:
 	{
-		u32 disable_dmx = 0;
+		u32 disable_dmx;
 		DBG("VDEC_IOCTL_GET_DISABLE_DMX_SUPPORT\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2418,7 +2383,7 @@
 	}
 	case VDEC_IOCTL_GET_DISABLE_DMX:
 	{
-		u32 disable_dmx = 0;
+		u32 disable_dmx;
 		DBG("VDEC_IOCTL_GET_DISABLE_DMX\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2443,7 +2408,7 @@
 	}
 	case VDEC_IOCTL_SET_PICTURE_ORDER:
 	{
-		u32 picture_order = 0;
+		u32 picture_order;
 		DBG("VDEC_IOCTL_SET_PICTURE_ORDER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2458,8 +2423,6 @@
 	case VDEC_IOCTL_SET_FRAME_RATE:
 	{
 		struct vdec_framerate frame_rate;
-		memset((void *)&frame_rate, 0,
-			sizeof(struct vdec_framerate));
 		DBG("VDEC_IOCTL_SET_FRAME_RATE\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2473,7 +2436,7 @@
 	}
 	case VDEC_IOCTL_SET_EXTRADATA:
 	{
-		u32 extradata_flag = 0;
+		u32 extradata_flag;
 		DBG("VDEC_IOCTL_SET_EXTRADATA\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2488,8 +2451,6 @@
 	case VDEC_IOCTL_SET_META_BUFFERS:
 	{
 		struct vdec_meta_buffers meta_buffers;
-		memset((void *)&meta_buffers, 0,
-			sizeof(struct vdec_meta_buffers));
 		DBG("VDEC_IOCTL_SET_META_BUFFERS\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2520,8 +2481,6 @@
 	case VDEC_IOCTL_SET_H264_MV_BUFFER:
 	{
 		struct vdec_h264_mv mv_data;
-		memset((void *)&mv_data, 0,
-			sizeof(struct vdec_h264_mv));
 		DBG("VDEC_IOCTL_SET_H264_MV_BUFFER\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
@@ -2545,8 +2504,6 @@
 	case VDEC_IOCTL_GET_MV_BUFFER_SIZE:
 	{
 		struct vdec_mv_buff_size mv_buff;
-		memset((void *)&mv_buff, 0,
-			sizeof(struct vdec_mv_buff_size));
 		DBG("VDEC_IOCTL_GET_MV_BUFFER_SIZE\n");
 		if (copy_from_user(&vdec_msg, arg, sizeof(vdec_msg)))
 			return -EFAULT;
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/enc/venc.c msm/vidc/common/enc/venc.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/enc/venc.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/enc/venc.c	2013-12-11 02:38:33.000000000 -0800
@@ -868,7 +868,6 @@
 	case VEN_IOCTL_CMD_READ_NEXT_MSG:
 	{
 		struct venc_msg cb_msg;
-		memset((void *)&cb_msg, 0, sizeof(struct venc_msg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_CMD_READ_NEXT_MSG\n");
@@ -890,7 +889,6 @@
 	case VEN_IOCTL_CMD_FILL_OUTPUT_BUFFER:
 	{
 		struct venc_buffer enc_buffer;
-		memset((void *)&enc_buffer, 0, sizeof(struct venc_buffer));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_CMD_ENCODE_FRAME"
@@ -916,8 +914,6 @@
 	{
 		enum venc_buffer_dir buffer_dir;
 		struct venc_bufferpayload buffer_info;
-		memset((void *)&buffer_info, 0,
-			sizeof(struct venc_bufferpayload));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_SET_INPUT_BUFFER/VEN_IOCTL_SET_OUTPUT_BUFFER\n");
@@ -941,8 +937,6 @@
 	{
 		enum venc_buffer_dir buffer_dir;
 		struct venc_bufferpayload buffer_info;
-		memset((void *)&buffer_info, 0,
-			sizeof(struct venc_bufferpayload));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -970,8 +964,6 @@
 	case VEN_IOCTL_SET_OUTPUT_BUFFER_REQ:
 	{
 		struct venc_allocatorproperty allocatorproperty;
-		memset((void *)&allocatorproperty, 0,
-			sizeof(struct venc_allocatorproperty));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -999,8 +991,6 @@
 	case VEN_IOCTL_GET_OUTPUT_BUFFER_REQ:
 	{
 		struct venc_allocatorproperty allocatorproperty;
-		memset((void *)&allocatorproperty, 0,
-			sizeof(struct venc_allocatorproperty));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1023,8 +1013,6 @@
 	case VEN_IOCTL_CMD_FLUSH:
 	{
 		struct venc_bufferflush bufferflush;
-		memset((void *)&bufferflush, 0,
-			sizeof(struct venc_bufferflush));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1087,8 +1075,6 @@
 	case VEN_IOCTL_SET_RECON_BUFFER:
 	{
 		struct venc_recon_addr venc_recon;
-		memset((void *)&venc_recon, 0,
-			sizeof(struct venc_recon_addr));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_SET_RECON_BUFFER\n");
@@ -1106,8 +1092,6 @@
 	case VEN_IOCTL_FREE_RECON_BUFFER:
 	{
 		struct venc_recon_addr venc_recon;
-		memset((void *)&venc_recon, 0,
-			sizeof(struct venc_recon_addr));
 		DBG("VEN_IOCTL_FREE_RECON_BUFFER\n");
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1125,8 +1109,6 @@
 	case VEN_IOCTL_GET_RECON_BUFFER_SIZE:
 	{
 		struct venc_recon_buff_size venc_recon_size;
-		memset((void *)&venc_recon_size, 0,
-			sizeof(struct venc_recon_buff_size));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_GET_RECON_BUFFER_SIZE\n");
@@ -1150,8 +1132,6 @@
 	case VEN_IOCTL_GET_QP_RANGE:
 	{
 		struct venc_qprange qprange;
-		memset((void *)&qprange, 0,
-			sizeof(struct venc_qprange));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_G(S)ET_QP_RANGE\n");
@@ -1180,8 +1160,6 @@
 	case VEN_IOCTL_GET_HEC:
 	{
 		struct venc_headerextension headerextension;
-		memset((void *)&headerextension, 0,
-			sizeof(struct venc_headerextension));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_HEC\n");
@@ -1212,8 +1190,6 @@
 	case VEN_IOCTL_GET_TARGET_BITRATE:
 	{
 		struct venc_targetbitrate targetbitrate;
-		memset((void *)&targetbitrate, 0,
-			sizeof(struct venc_targetbitrate));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_TARGET_BITRATE\n");
@@ -1243,8 +1219,6 @@
 	case VEN_IOCTL_GET_FRAME_RATE:
 	{
 		struct venc_framerate framerate;
-		memset((void *)&framerate, 0,
-			sizeof(struct venc_framerate));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_FRAME_RATE\n");
@@ -1274,8 +1248,6 @@
 	case VEN_IOCTL_GET_VOP_TIMING_CFG:
 	{
 		struct venc_voptimingcfg voptimingcfg;
-		memset((void *)&voptimingcfg, 0,
-			sizeof(struct venc_voptimingcfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1305,8 +1277,6 @@
 	case VEN_IOCTL_GET_RATE_CTRL_CFG:
 	{
 		struct venc_ratectrlcfg ratectrlcfg;
-		memset((void *)&ratectrlcfg, 0,
-			sizeof(struct venc_ratectrlcfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_RATE_CTRL_CFG\n");
@@ -1336,8 +1306,6 @@
 	case VEN_IOCTL_GET_MULTI_SLICE_CFG:
 	{
 		struct venc_multiclicecfg multiclicecfg;
-		memset((void *)&multiclicecfg, 0,
-			sizeof(struct venc_multiclicecfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_MULTI_SLICE_CFG\n");
@@ -1367,8 +1335,6 @@
 	case VEN_IOCTL_GET_INTRA_REFRESH:
 	{
 		struct venc_intrarefresh intrarefresh;
-		memset((void *)&intrarefresh, 0,
-			sizeof(struct venc_intrarefresh));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_INTRA_REFRESH\n");
@@ -1397,8 +1363,6 @@
 	case VEN_IOCTL_GET_DEBLOCKING_CFG:
 	{
 		struct venc_dbcfg dbcfg;
-		memset((void *)&dbcfg, 0,
-			sizeof(struct venc_dbcfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1428,8 +1392,6 @@
 	case VEN_IOCTL_GET_ENTROPY_CFG:
 	{
 		struct venc_entropycfg entropy_cfg;
-		memset((void *)&entropy_cfg, 0,
-			sizeof(struct venc_entropycfg));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_ENTROPY_CFG\n");
@@ -1457,8 +1419,6 @@
 	case VEN_IOCTL_GET_SEQUENCE_HDR:
 	{
 		struct venc_seqheader seq_header;
-		memset((void *)&seq_header, 0,
-			sizeof(struct venc_seqheader));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1501,8 +1461,6 @@
 	case VEN_IOCTL_GET_INTRA_PERIOD:
 	{
 		struct venc_intraperiod intraperiod;
-		memset((void *)&intraperiod, 0,
-			sizeof(struct venc_intraperiod));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_INTRA_PERIOD\n");
@@ -1531,8 +1489,6 @@
 	case VEN_IOCTL_GET_SESSION_QP:
 	{
 		struct venc_sessionqp session_qp;
-		memset((void *)&session_qp, 0,
-			sizeof(struct venc_sessionqp));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("VEN_IOCTL_(G)SET_SESSION_QP\n");
@@ -1561,8 +1517,6 @@
 	case VEN_IOCTL_GET_PROFILE_LEVEL:
 	{
 		struct ven_profilelevel profile_level;
-		memset((void *)&profile_level, 0,
-			sizeof(struct ven_profilelevel));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1592,8 +1546,6 @@
 	case VEN_IOCTL_GET_CODEC_PROFILE:
 	{
 		struct venc_profile profile;
-		memset((void *)&profile, 0,
-			sizeof(struct venc_profile));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1623,8 +1575,6 @@
 	case VEN_IOCTL_GET_SHORT_HDR:
 	{
 		struct venc_switch encoder_switch;
-		memset((void *)&encoder_switch, 0,
-			sizeof(struct venc_switch));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		DBG("Getting VEN_IOCTL_(G)SET_SHORT_HDR\n");
@@ -1654,8 +1604,6 @@
 	case VEN_IOCTL_GET_BASE_CFG:
 	{
 		struct venc_basecfg base_config;
-		memset((void *)&base_config, 0,
-			sizeof(struct venc_basecfg));
 		DBG("VEN_IOCTL_SET_BASE_CFG\n");
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1684,8 +1632,6 @@
 	case VEN_IOCTL_GET_LIVE_MODE:
 	{
 		struct venc_switch encoder_switch;
-		memset((void *)&encoder_switch, 0,
-			sizeof(struct venc_switch));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
@@ -1723,11 +1669,9 @@
 	}
 	case VEN_IOCTL_SET_METABUFFER_MODE:
 	{
-		u32 metabuffer_mode = 0, vcd_status = 0;
+		u32 metabuffer_mode, vcd_status;
 		struct vcd_property_hdr vcd_property_hdr;
 		struct vcd_property_live live_mode;
-		memset((void *)&live_mode, 0,
-			sizeof(struct vcd_property_live));
 
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1749,7 +1693,7 @@
 	case VEN_IOCTL_SET_EXTRADATA:
 	case VEN_IOCTL_GET_EXTRADATA:
 	{
-		u32 extradata_flag = 0;
+		u32 extradata_flag;
 		DBG("VEN_IOCTL_(G)SET_EXTRADATA\n");
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1794,8 +1738,6 @@
 		struct vcd_property_sps_pps_for_idr_enable idr_enable;
 		u32 vcd_status = VCD_ERR_FAIL;
 		u32 enabled = 1;
-		memset((void *)&idr_enable, 0,
-			sizeof(struct vcd_property_sps_pps_for_idr_enable));
 
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
@@ -1819,10 +1761,8 @@
 	{
 		struct vcd_property_hdr vcd_property_hdr;
 		struct vcd_property_bitstream_restrict_enable vcd_property_val;
-
 		u32 vcd_status = VCD_ERR_FAIL;
-		memset((void *)&vcd_property_val, 0,
-			sizeof(struct vcd_property_bitstream_restrict_enable));
+
 		vcd_property_hdr.prop_id =
 			VCD_I_ENABLE_VUI_BITSTREAM_RESTRICT_FLAG;
 		vcd_property_hdr.sz = sizeof(struct
@@ -1840,7 +1780,7 @@
 	}
 	case VEN_IOCTL_GET_PERF_LEVEL:
 	{
-		u32 curr_perf_level = 0;
+		u32 curr_perf_level;
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		result = vid_enc_get_curr_perf_level(client_ctx,
@@ -1860,8 +1800,6 @@
 	case VEN_IOCTL_GET_LTRMODE:
 	{
 		struct venc_ltrmode encoder_ltrmode;
-		memset((void *)&encoder_ltrmode, 0,
-			sizeof(struct venc_ltrmode));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		if (cmd == VEN_IOCTL_SET_LTRMODE) {
@@ -1891,8 +1829,6 @@
 	case VEN_IOCTL_GET_LTRCOUNT:
 	{
 		struct venc_ltrcount encoder_ltrcount;
-		memset((void *)&encoder_ltrcount, 0,
-			sizeof(struct venc_ltrcount));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		if (cmd == VEN_IOCTL_SET_LTRCOUNT) {
@@ -1923,8 +1859,6 @@
 	case VEN_IOCTL_GET_LTRPERIOD:
 	{
 		struct venc_ltrperiod encoder_ltrperiod;
-		memset((void *)&encoder_ltrperiod, 0,
-			sizeof(struct venc_ltrperiod));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		if (cmd == VEN_IOCTL_SET_LTRPERIOD) {
@@ -1954,8 +1888,6 @@
 	case VEN_IOCTL_GET_CAPABILITY_LTRCOUNT:
 	{
 		struct venc_range venc_capltrcount;
-		memset((void *)&venc_capltrcount, 0,
-			sizeof(struct venc_range));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 			DBG("VEN_IOCTL_GET_CAPABILITY_LTRCOUNT\n");
@@ -1975,8 +1907,6 @@
 	case VEN_IOCTL_GET_LTRUSE:
 	{
 		struct venc_ltruse encoder_ltruse;
-		memset((void *)&encoder_ltruse, 0,
-			sizeof(struct venc_ltruse));
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 		if (cmd == VEN_IOCTL_SET_LTRUSE) {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/enc/venc_internal.c msm/vidc/common/enc/venc_internal.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/enc/venc_internal.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/enc/venc_internal.c	2013-12-11 02:38:33.000000000 -0800
@@ -971,7 +971,7 @@
 	vcd_property_hdr.sz =
 		sizeof(struct vcd_property_entropy_control);
 	if (set_flag) {
-		switch (entropy_cfg->entropysel) {
+		switch (entropy_cfg->longentropysel) {
 		case VEN_ENTROPY_MODEL_CAVLC:
 			control.entropy_sel = VCD_ENTROPY_SEL_CAVLC;
 			break;
@@ -1024,11 +1024,11 @@
 		} else {
 			switch (control.entropy_sel) {
 			case VCD_ENTROPY_SEL_CABAC:
-				entropy_cfg->entropysel =
+				entropy_cfg->cabacmodel =
 					VEN_ENTROPY_MODEL_CABAC;
 				break;
 			case VCD_ENTROPY_SEL_CAVLC:
-				entropy_cfg->entropysel =
+				entropy_cfg->cabacmodel =
 					VEN_ENTROPY_MODEL_CAVLC;
 				break;
 			default:
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c msm/vidc/common/vcd/vcd_client_sm.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/vcd/vcd_client_sm.c	2013-12-11 02:38:33.000000000 -0800
@@ -1767,7 +1767,7 @@
 	 vcd_get_buffer_requirements_cmn,
 	 NULL,
 	 NULL,
-	 vcd_free_buffer_cmn, //Port flush patch : AU_LINUX_ANDROID_JB_2.2_RB2_3.04.01.02.37.048.
+	 vcd_free_buffer_cmn,
 	 vcd_fill_output_buffer_cmn,
 	 vcd_clnt_cb_in_flushing,
 	 },
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_core.h msm/vidc/common/vcd/vcd_core.h
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_core.h	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/vcd/vcd_core.h	2013-12-11 02:38:33.000000000 -0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -147,7 +147,6 @@
 	u32 reqd_perf_lvl;
 	u32 curr_perf_lvl;
 	u32 set_perf_lvl_pending;
-	bool turbo_mode_set;
 };
 
 struct vcd_clnt_status {
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c msm/vidc/common/vcd/vcd_device_sm.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/vcd/vcd_device_sm.c	2013-12-11 02:38:33.000000000 -0800
@@ -220,7 +220,6 @@
 						   VCD_DEVICE_STATE_INITING,
 						   ev_code);
 	}
-
 	return rc;
 }
 
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c msm/vidc/common/vcd/vcd_power_sm.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/vcd/vcd_power_sm.c	2013-12-11 02:38:33.000000000 -0800
@@ -383,7 +383,6 @@
 			VCD_MSG_ERROR("Failed to get max perf level\n");
 		}
 	}
-
 	if (cctxt->status.req_perf_lvl) {
 		dev_ctxt->reqd_perf_lvl =
 		    dev_ctxt->reqd_perf_lvl - cctxt->reqd_perf_lvl +
diff --unified -r /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_sub.c msm/vidc/common/vcd/vcd_sub.c
--- /home/shade/dev/cm/11/kernel/samsung/jf/drivers/video/msm/vidc/common/vcd/vcd_sub.c	2013-12-17 17:08:08.038147321 -0800
+++ msm/vidc/common/vcd/vcd_sub.c	2013-12-11 02:38:33.000000000 -0800
@@ -1871,7 +1871,7 @@
 					VCD_CLIENT_STATE_EOS,
 					CLIENT_STATE_EVENT_NUMBER
 					(encode_frame));
-        } else {
+		} else {
 			transc = vcd_get_first_in_use_trans_for_clnt(cctxt);
 			if (transc) {
 				transc->flags |= VCD_FRAME_FLAG_EOS;
